module Darklang =
  module Cli =
    module IntegrationTests =
      module FailureRecorder =
        type RecordingResult =
          | Success of gifPath: String
          | SkippedNoVhs
          | Failed of error: String

        let scriptDir = "./packages/darklang/cli/integrationTests/testResults"
        let projectRoot = "."
        let getFailureGifsDir () : String = $"{scriptDir}/failed-tests-gifs"
        let getTapesDir () : String = $"{scriptDir}/tapes"

        let getAbsolutePath (relativePath: String) : String =
          let result = Builtin.cliExecute $"realpath {relativePath}"

          if result.exitCode == 0L then
            Stdlib.String.trim result.stdout
          else
            relativePath // Fallback to relative path


        let checkVhsAvailable () : Bool =
          let result = Builtin.cliExecute "command -v vhs"
          result.exitCode == 0L


        let createDirectories () : Stdlib.Result.Result<Unit, String> =
          let result1 = Builtin.cliExecute $"mkdir -p {getFailureGifsDir ()}"

          if result1.exitCode == 0L then
            let result2 = Builtin.cliExecute $"mkdir -p {getTapesDir ()}"

            if result2.exitCode == 0L then
              Stdlib.Result.Result.Ok()
            else
              Stdlib.Result.Result.Error
                $"Failed to create tapes directory: {result2.stderr}"
          else
            Stdlib.Result.Result.Error
              $"Failed to create failed-tests-gifs directory: {result1.stderr}"


        let generateTimestamp () : String =
          (Stdlib.DateTime.now())
          |> Stdlib.DateTime.toString

        let testNameToSafeFilename (testName: String) : String =
          testName
          |> Stdlib.String.toLowercase
          |> Stdlib.String.replaceAll " " "-"
          |> Stdlib.String.replaceAll "(" ""
          |> Stdlib.String.replaceAll ")" ""
          |> Stdlib.String.replaceAll "[" ""
          |> Stdlib.String.replaceAll "]" ""
          |> Stdlib.String.replaceAll "/" ""
          |> Stdlib.String.replaceAll "\\" ""

        let createTapeFileWithBuiltin
          (testName: String)
          (command: String)
          (tapeFile: String)
          (gifPath: String)
          : Stdlib.Result.Result<Unit, String> =
          let absoluteGifPath = getAbsolutePath gifPath

          let content =
            "Output \""
            ++ absoluteGifPath
            ++ "\"\n"
            ++ "Set FontSize 14\n"
            ++ "Set Width 1200\n"
            ++ "Set Height 600\n"
            ++ "Set TypingSpeed 50ms\n"
            ++ "Set Theme \"Dracula\"\n"
            ++ "\n"
            ++ "Type \""
            ++ command
            ++ "\"\n"
            ++ "Enter\n"
            ++ "Sleep 3s"

          Builtin.fileWrite (Stdlib.String.toBytes content) tapeFile


        let deleteFile (filePath: String) : Unit =
          let result = Builtin.cliExecute $"rm -f \"{filePath}\""
          ()

        let cleanupPreviousFailures () : Unit =
          let gifsDir = getFailureGifsDir ()
          let tapesDir = getTapesDir ()

          // Remove all GIF and tape files from previous runs
          let cleanGifs = Builtin.cliExecute $"rm -f \"{gifsDir}\"/*.gif"
          let cleanTapes = Builtin.cliExecute $"rm -f \"{tapesDir}\"/*.tape"

          if cleanGifs.exitCode == 0L && cleanTapes.exitCode == 0L then
            ()
          else
            Builtin.printLine "‚ö†Ô∏è  Warning: Could not fully clean previous recordings"

        let runVhsRecording (tapeFile: String) : Stdlib.Result.Result<Unit, String> =
          let absoluteTapeFile = getAbsolutePath tapeFile
          let absoluteProjectRoot = getAbsolutePath projectRoot

          // Verify the tape file exists before running VHS
          let checkFile = Builtin.cliExecute $"test -f \"{absoluteTapeFile}\""

          if checkFile.exitCode != 0L then
            Stdlib.Result.Result.Error
              $"Tape file does not exist: {absoluteTapeFile}"
          else
            let command =
              $"cd \"{absoluteProjectRoot}\" && vhs \"{absoluteTapeFile}\""

            let result = Builtin.cliExecute command

            if result.exitCode == 0L then
              Stdlib.Result.Result.Ok()
            else
              let errorMsg =
                $"VHS failed with exit code {Stdlib.Int64.toString result.exitCode}"

              let stderrMsg = result.stderr
              let stdoutMsg = result.stdout

              Stdlib.Result.Result.Error
                $"{errorMsg}. Stderr: {stderrMsg}. Stdout: {stdoutMsg}"


        let recordFailure (testName: String) (command: String) : RecordingResult =
          if Stdlib.Bool.not (checkVhsAvailable ()) then
            Builtin.printLine "‚ö†Ô∏è  VHS not found - skipping failure recording"

            Builtin.printLine
              "Run ./scripts/setup-vhs.sh to install VHS"
            RecordingResult.SkippedNoVhs

          else
            match createDirectories () with
            | Error e -> RecordingResult.Failed e
            | Ok _ ->
              let timestamp = generateTimestamp ()
              let safeTestName = testNameToSafeFilename testName

              let tapeFile =
                $"{getTapesDir ()}/failure-{safeTestName}-{timestamp}.tape"

              let gifName = $"{safeTestName}-failure-{timestamp}.gif"
              let gifPath = $"{getFailureGifsDir ()}/{gifName}"

              match createTapeFileWithBuiltin testName command tapeFile gifPath with
              | Error e -> RecordingResult.Failed $"Failed to create tape file: {e}"
              | Ok _ ->
                Builtin.printLine $"üé¨ Recording failure GIF for {testName}..."

                match runVhsRecording tapeFile with
                | Ok _ ->
                  deleteFile tapeFile
                  Builtin.printLine
                    $"‚úì Failure GIF generated at: {gifPath}"

                  RecordingResult.Success gifPath

                | Error e ->
                  Builtin.printLine "‚úó Failed to generate VHS recording"
                  Builtin.printLine $"üêõ Debug: VHS error: {e}"

                  Builtin.printLine
                    $"üêõ Debug: Tape file left at: {tapeFile} for inspection"

                  RecordingResult.Failed $"VHS recording failed: {e}"

        let validateArgs
          (args: List<String>)
          : Stdlib.Result.Result<(String * String), String> =
          match args with
          | [ testName; command ] -> Stdlib.Result.Result.Ok(testName, command)
          | _ -> Stdlib.Result.Result.Error "Invalid arguments"

        let main (args: List<String>) : Int64 =
          match validateArgs args with
          | Error _ ->
            // TODO: better error message + show usage
            Builtin.printLine "‚úó Error: Invalid arguments"
            1L

          | Ok(testName, command) ->
            match recordFailure testName command with
            | Success _ -> 0L
            | SkippedNoVhs -> 0L
            | Failed error ->
              Builtin.printLine $"‚úó Recording failed: {error}"
              1L

        let recordFailureForTest (testName: String) (command: String) : Bool =
          match recordFailure testName command with
          | Success _ -> true
          | SkippedNoVhs -> true
          | Failed _ -> false