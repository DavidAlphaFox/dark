module Darklang =
  module Cli =
    module IntegrationTests =
      module TestFramework =
        type InteractiveStep =
          | SendInput of input: String
          | ExpectOutput of pattern: String
          | Wait of milliseconds: Int64
          | SendQuit

        type InteractiveCliTest =
          { name: String
            steps: List<InteractiveStep>
            timeoutSeconds: Int64 }

        type CliTest =
          { name: String
            arguments: List<String>
            expectedOutputFile: String
            isInteractive: Bool
            interactiveTest: Stdlib.Option.Option<InteractiveCliTest> }

        type TestResult =
          | Success of message: String
          | Failure of message: String
          | SetupComplete of message: String


        let makeCliTest
          (name: String)
          (arguments: List<String>)
          (expectedOutputFile: String): CliTest =
          CliTest
            { name = name
              arguments = arguments
              expectedOutputFile = expectedOutputFile
              isInteractive = false
              interactiveTest = Stdlib.Option.Option.None }

        let makeInteractiveCliTest
          (name: String)
          (steps: List<InteractiveStep>)
          (timeoutSeconds: Int64): CliTest =
          let interactiveTest =
            InteractiveCliTest
              { name = name
                steps = steps
                timeoutSeconds = timeoutSeconds }
          CliTest
            { name = name
              arguments = []
              expectedOutputFile = ""
              isInteractive = true
              interactiveTest = Stdlib.Option.Option.Some interactiveTest }


        let createDirectories (): Stdlib.Result.Result<Unit, String> =
          match TestUtils.createDirectory (TestConfig.getActualDir ()) with
          | Error e -> Stdlib.Result.Result.Error $"Failed to create actual directory: {e}"
          | Ok _ ->
            match TestUtils.createDirectory (TestConfig.getExpectedDir ()) with
            | Error e -> Stdlib.Result.Result.Error $"Failed to create expected directory: {e}"
            | Ok _ -> Stdlib.Result.Result.Ok ()


        let runCliCommand (command: String) (outputFile: String): Stdlib.Result.Result<Unit, String> =
          let fullCommand = $"cd {TestConfig.projectRoot} && {command} > {outputFile} 2>&1"
          let result = Builtin.cliExecute fullCommand
          if result.exitCode == 0L then
            Stdlib.Result.Result.Ok ()
          else
            Error $"CLI command failed with exit code {Stdlib.Int64.toString result.exitCode}: {result.stderr}"


        let isFileEmpty (filePath: String): Bool =
          match TestUtils.getFileContent filePath with
          | Ok content -> Stdlib.Bool.not (Stdlib.String.isEmpty content)
          | Error _ -> false

        let filesAreEqual (file1: String) (file2: String): Bool =
          let result = Builtin.cliExecute $"diff -q {file1} {file2}"
          result.exitCode == 0L

        let generateDiff (expectedFile: String) (actualFile: String): String =
          let result = Builtin.cliExecute $"diff --unified=3 --color=always {expectedFile} {actualFile}"
          result.stdout

        let copyFile (source: String) (destination: String): Stdlib.Result.Result<Unit, String> =
          match TestUtils.getFileContent source with
          | Ok content -> TestUtils.writeFileContent destination content
          | Error e -> Error e


        module InteractiveTestRunner =
          // Generates input commands for expect script
          let generateInputCommand (input: String): String =
            let escapedInput = TestUtils.escapeForExpect input
            $"send \"{escapedInput}\\r\""  // Send the whole command + Enter

          // Generates a complete expect script that automates CLI interaction
          let generateExpectScript (steps: List<InteractiveStep>) (timeoutSeconds: Int64): Stdlib.Result.Result<String, String> =
            // Find expect executable location
            let expectLocation =
              let whichResult = Builtin.cliExecute "which expect"
              if whichResult.exitCode == 0L then
                Stdlib.Result.Result.Ok (Stdlib.String.trim whichResult.stdout)
              else
                Stdlib.Result.Result.Error "expect command not found. This is unexpected, as expect is installed during the build"

            match expectLocation with
            | Error e -> Stdlib.Result.Result.Error e
            | Ok expectPath ->

              // Script header: shebang, timeout setting, and spawn CLI process
              let header = $"#!{expectPath} -f\nset timeout {Stdlib.Int64.toString timeoutSeconds}\nspawn ./scripts/run-cli\nsleep 1\n"

              // Convert each test step into expect script commands
              let stepCommands =
                steps
                |> Stdlib.List.indexedMap (fun i step ->
                  match step with
                  // SendInput: Simulates user typing a command
                  | SendInput input -> generateInputCommand input

                  // ExpectOutput: Waits for a pattern to appear in CLI output
                  // If pattern doesn't appear within timeout, test fails
                  | ExpectOutput pattern ->
                    $"expect {{\n  -re \"{pattern}\" {{}}\n  timeout {{ puts \"TIMEOUT: Expected '{pattern}'\"; exit 1 }}\n  eof {{ puts \"EOF: Process ended waiting for '{pattern}'\"; exit 1 }}\n}}"
                  | Wait milliseconds -> $"after {Stdlib.Int64.toString milliseconds}"
                  | SendQuit -> "send \"\\033\""  // \033 is Escape key
                )
                |> Stdlib.String.join "\n"

              // Script footer: wait for CLI process to end cleanly
              let footer = "expect eof\n"

              Stdlib.Result.Result.Ok $"{header}{stepCommands}\n{footer}"


          let runInteractiveTest (interactiveTest: InteractiveCliTest): TestResult =
            match generateExpectScript interactiveTest.steps interactiveTest.timeoutSeconds with
            | Error e -> TestResult.Failure $"Failed to generate expect script: {e}"
            | Ok expectScript ->
              let expectFile = $"{TestConfig.testDir}/temp-expect-{TestUtils.safeFileName interactiveTest.name}.exp"

              match TestUtils.writeFileContent expectFile expectScript with
              | Error e -> TestResult.Failure $"Failed to write expect script: {e}"
              | Ok _ ->
                let chmodResult = Builtin.cliExecute $"chmod +x {expectFile}"
                if chmodResult.exitCode != 0L then
                  TestResult.Failure "Failed to make expect script executable"
                else
                  // Run the expect script and capture all output
                  let result = Builtin.cliExecute $"cd {TestConfig.projectRoot} && {expectFile} 2>&1"

                  // Clean up temporary script file
                  TestUtils.deleteFile expectFile

                  if result.exitCode == 0L then
                    TestResult.Success $"Interactive test {interactiveTest.name} passed - all ExpectOutput validations succeeded"
                  else
                    let errorOutput = Stdlib.String.trim result.stdout
                    let specificError =
                      if Stdlib.String.contains errorOutput "TIMEOUT: Expected" then
                        // Extract which pattern failed
                        let parts = Stdlib.String.split errorOutput "TIMEOUT: Expected '"
                        if Stdlib.List.length parts >= 2L then
                          let afterPattern = Stdlib.List.getAt parts 1L
                          match afterPattern with
                          | Some patternPart ->
                            let patternEnd = Stdlib.String.split patternPart "'"
                            let pattern = Stdlib.List.getAt patternEnd 0L
                            match pattern with
                            | Some p -> $"TIMEOUT: Expected pattern '{p}' was not found"
                            | None -> "TIMEOUT: Pattern matching failed"
                          | None -> "TIMEOUT: Pattern matching failed"
                        else
                          // If parsing fails, show the full error output
                          errorOutput
                      else if Stdlib.String.contains errorOutput "EOF: Process ended" then
                        // Extract pattern from EOF message
                        let parts = Stdlib.String.split errorOutput "EOF: Process ended waiting for '"
                        if Stdlib.List.length parts >= 2L then
                          let afterPattern = Stdlib.List.getAt parts 1L
                          match afterPattern with
                          | Some patternPart ->
                            let patternEnd = Stdlib.String.split patternPart "'"
                            let pattern = Stdlib.List.getAt patternEnd 0L
                            match pattern with
                            | Some p -> $"EOF: CLI process ended unexpectedly while waiting for '{p}'"
                            | None -> "EOF: CLI process ended unexpectedly"
                          | None -> "EOF: CLI process ended unexpectedly"
                        else
                          "EOF: CLI process ended unexpectedly"
                      else
                        // If it doesn't match our patterns, show the full error output
                        if Stdlib.String.isEmpty errorOutput then
                          "Interactive test failed with no error output"
                        else
                          $"Interactive test failed: {errorOutput}"

                    TestUtils.printlnColored CliColors.red $"âœ— FAIL - {interactiveTest.name}"
                    TestUtils.printlnColored CliColors.red specificError
                    TestResult.Failure $"Interactive test {interactiveTest.name} failed - {specificError}"


        let runCliTest (config: CliTest): TestResult =
          if config.isInteractive then
            match config.interactiveTest with
            | Some interactiveTest -> InteractiveTestRunner.runInteractiveTest interactiveTest
            | None -> TestResult.Failure "Interactive test configuration missing"
          else
            let expectedFile = TestConfig.getExpectedFilePath config.expectedOutputFile
            let actualFile = TestConfig.getActualFilePath config.name
            let command = TestConfig.buildCliCommand config.arguments

            match createDirectories() with
            | Error e -> TestResult.Failure $"Failed to create directories: {e}"
            | Ok _ ->
              match runCliCommand command actualFile with
              | Error e ->
                TestUtils.printlnColored CliColors.red "âœ— CLI command failed"
                Builtin.printLine "CLI output:"
                match TestUtils.getFileContent actualFile with
                | Ok content when Stdlib.Bool.not (Stdlib.String.isEmpty content) ->
                  Builtin.printLine content
                | _ ->
                  Builtin.printLine "No output captured"
                TestResult.Failure $"CLI command failed: {e}"
              | Ok _ ->
                if Stdlib.Bool.not (isFileEmpty actualFile) then
                  TestUtils.printlnColored CliColors.red "âœ— Output file is empty."
                  TestResult.Failure "Output file is empty"
                else
                  if Stdlib.Bool.not (TestUtils.fileExists expectedFile) then
                    TestUtils.printlnColored CliColors.yellow $"âš  Expected output file not found: {expectedFile}"
                    TestUtils.printlnColored CliColors.yellow "â„¹ Creating it with current output for future comparisons"
                    match copyFile actualFile expectedFile with
                    | Ok _ ->
                      TestUtils.printlnColored CliColors.green "âœ“ Test setup complete. Expected output saved."
                      Builtin.printLine ""
                      TestResult.SetupComplete "Expected output file created"
                    | Error e ->
                      TestResult.Failure $"Failed to create expected file: {e}"
                  else
                    if filesAreEqual expectedFile actualFile then
                      TestUtils.deleteFile actualFile
                      TestResult.Success $"{config.name} output matches expected"
                    else
                      TestUtils.printlnColored CliColors.red $"âœ— FAIL - {config.name} output differs from expected"
                      Builtin.printLine ""
                      TestUtils.printlnColored CliColors.blue "ðŸ“„ Detailed diff:"
                      Builtin.printLine "-----------------"
                      TestUtils.printlnColored CliColors.yellow "Expected vs Actual:"
                      let diffOutput = generateDiff expectedFile actualFile
                      Builtin.printLine diffOutput
                      Builtin.printLine ""
                      TestUtils.printMessageWithBorder
                        "Tip: If the new output is correct, update expected with:"
                        $"cp \"{actualFile}\" \"{expectedFile}\""
                      Builtin.printLine ""
                      TestResult.Failure $"{config.name} output differs from expected"


        let getRecordCommand (config: CliTest): String =
          if config.isInteractive then
            "./scripts/run-cli"
          else
            TestConfig.buildCliCommand config.arguments

        let getInteractiveSteps (config: CliTest): List<InteractiveStep> =
          if config.isInteractive then
            match config.interactiveTest with
            | Some test -> test.steps
            | None -> []
          else
            []

        let testResultToExitCode (result: TestResult): Int64 =
          match result with
          | Success _ -> 0L
          | SetupComplete _ -> 0L
          | Failure _ -> 1L
