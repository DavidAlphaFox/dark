module Darklang =
  module Cli =
    module SelfUpdate =
      let configPath = ".darklang/bin/darklang/config.json"
      let executablePath = ".darklang/bin/darklang/"
      let baseUrl = "https://api.github.com/repos/darklang/dark"
      let bearerToken = "${GITHUB_RELEASES_TOKEN}"

      let shell () : Stdlib.Cli.HostDefaultShell =
        (Darklang.Stdlib.Cli.getShell ()) |> Builtin.unwrap

      type Asset =
        { name: String
          browser_download_url: String }

      type Release =
        { tag_name: String
          assets: List<Asset> }

      let defaultConfig =
        Dict
          { version = "v0.0.0"
            lastUpdateTimestamp = "0" }


      let getFromGithub
        (bearerToken: String)
        (path: String)
        : Stdlib.Result.Result<String, String> =
        let headers =
          [ ("authorization ", "bearer" ++ bearerToken)
            ("accept", "application/vnd.github+json")
            ("user-Agent", "Darklang") ]

        let response = Darklang.Stdlib.HttpClient.request "GET" path headers []

        match response with
        | Ok r ->
          r.body
          |> Darklang.Stdlib.String.fromBytesWithReplacement
          |> Stdlib.Result.Result.Ok
        | Error e -> Stdlib.Result.Result.Error "Failed to make GitHub API request"


      let hostToString
        (host: Darklang.Stdlib.Cli.Host.Host)
        : Stdlib.Result.Result<String, String> =
        match host.os, host.arch with
        | Linux, Armv7l -> "linux-musl-x64" |> Stdlib.Result.Result.Ok
        | Linux, Arm64 -> "linux-arm64" |> Stdlib.Result.Result.Ok
        | Linux, Aarch64 -> "linux-arm64" |> Stdlib.Result.Result.Ok
        | Linux, X86_64 -> "linux-x64" |> Stdlib.Result.Result.Ok
        | MacOS, Arm64 -> "osx-arm64" |> Stdlib.Result.Result.Ok
        | MacOS, X86_64 -> "osx-x64" |> Stdlib.Result.Result.Ok
        | _, _ -> Stdlib.Result.Result.Error "Unsupported OS or Arch"


      /// get tag of most recent release, from github api
      /// (i.e. `v0.0.19`)
      let getLatestReleaseTag () : Stdlib.Result.Result<String, String> =
        (getFromGithub bearerToken $"{baseUrl}/releases")
        |> Stdlib.Result.andThen (fun releases ->
          (Builtin.jsonParse<List<Release>> releases)
          |> Stdlib.Result.map (fun releases ->
            releases
            |> Stdlib.List.map (fun release -> release.tag_name)
            |> Stdlib.List.head
            |> Stdlib.Option.withDefault "v0.0.0"))


      // get download url for latest release based on os and arch
      let getDownloadUrl
        (host: Darklang.Stdlib.Cli.Host.Host)
        : Stdlib.Result.Result<String, String> =
        Builtin.printLine " - Getting download url for latest release"
        let host = (hostToString host) |> Builtin.unwrap

        (getLatestReleaseTag ())
        |> Stdlib.Result.andThen (fun latestTag ->
          (getFromGithub bearerToken $"{baseUrl}/releases/tags/{latestTag}")
          |> Stdlib.Result.andThen (fun release ->
            (Builtin.jsonParse<Release> release)
            |> Stdlib.Result.map (fun release ->
              release.assets
              |> Stdlib.List.filter (fun asset ->
                Stdlib.String.contains asset.name (host))
              |> Stdlib.List.map (fun asset -> asset.browser_download_url)
              |> Stdlib.List.head
              |> Stdlib.Option.withDefault "")))


      // get local release version from config.json
      let readLocalVersionFromConfigJson () : Stdlib.Result.Result<String, String> =
        (Builtin.fileRead configPath)
        |> Stdlib.Result.andThen (fun config ->
          config
          |> Stdlib.String.fromBytesWithReplacement
          |> Builtin.jsonParse<Dict<String>>)
        |> Stdlib.Result.andThen (fun config ->
          config
          |> PACKAGE.Darklang.Stdlib.Dict.get "version"
          |> Stdlib.Option.toResult "Failed to find version key")

      let isLatestVersion () : Bool =
        let localVersion = (readLocalVersionFromConfigJson ()) |> Builtin.unwrap
        let latestVersion = getLatestReleaseTag ()

        match latestVersion with
        | Ok version -> localVersion == version
        | Error e ->
          Stdlib.Result.Result.Error e
          false

      /// ----------------- Download and prepare asset ----------------- ///

      let downloadAsset
        (downloadUrl: String)
        (assetName: String)
        : Stdlib.Result.Result<String, String> =
        Builtin.printLine " - Downloading asset"

        let command =
          $"curl -s -L -o \".darklang/bin/darklang/{assetName}\" {downloadUrl}"

        let result = Stdlib.Process.runCommand command

        if result.exitCode == 0L then
          Stdlib.Result.Result.Ok assetName
        else
          Stdlib.Result.Result.Error "Failed to download asset"


      let getAssetName (downloadUrl: String) : Stdlib.Result.Result<String, String> =
        let result = Stdlib.Process.runCommand $"basename {downloadUrl}"

        if result.exitCode == 0L then
          Stdlib.Result.Result.Ok(result.stdout |> Stdlib.String.trim)
        else
          Stdlib.Result.Result.Error "Failed to get asset name"


      let gunzipAsset
        (assetName: String)
        (executablePath: String)
        : Stdlib.Result.Result<(String * String), String> =
        Builtin.printLine " - Unzipping asset"

        if Stdlib.String.endsWith assetName ".gz" then
          let assetNameWithoutExt = assetName |> Stdlib.String.dropLast 3L
          let zipPath = executablePath ++ assetName
          let newExecutablePath = executablePath ++ assetNameWithoutExt

          match
            (Darklang.Cli.ZipUtils.gunzipToFile "-c" zipPath newExecutablePath)
          with
          | Ok _ ->
            let deleteZip = Stdlib.Process.runCommand $"rm {zipPath}"

            if deleteZip.exitCode == 0L then
              Stdlib.Result.Result.Ok((assetNameWithoutExt, newExecutablePath))
            else
              Builtin.printLine "Failed to remove compressed asset"
              deleteZip.exitCode

          | Error e -> Stdlib.Result.Result.Error e

        else
          Stdlib.Result.Result.Error "Asset is not a .gz file"


      /// ----------------- Update Config ----------------- ///

      let readConfig
        (configPath: String)
        : Stdlib.Result.Result<Dict<String>, String> =
        match Builtin.fileRead configPath with
        | Ok content ->
          let parsedResult =
            Builtin.jsonParse<Dict<String>> (
              content |> Stdlib.String.fromBytesWithReplacement
            )

          Stdlib.Result.mapError parsedResult (fun _ ->
            "Failed to parse config.json")
        | Error _ -> Stdlib.Result.Result.Error "Failed to read config.json"

      let updateConfig
        (latestVersion: String)
        (configPath: String)
        : Stdlib.Result.Result<Dict<String>, String> =
        Builtin.printLine " - Updating config file with latest version"

        (readConfig configPath)
        |> Stdlib.Result.map (fun config ->
          let currentTimestamp =
            (Stdlib.DateTime.now ())
            |> Stdlib.DateTime.toSeconds
            |> Stdlib.Int64.toString

          config
          |> PACKAGE.Darklang.Stdlib.Dict.set "version" latestVersion
          |> PACKAGE.Darklang.Stdlib.Dict.set "lastUpdateTimestamp" currentTimestamp)

      let writeConfig
        (config: Dict<String>)
        (configPath: String)
        : Stdlib.Result.Result<Unit, String> =
        let serializedConfig =
          (Builtin.jsonSerialize<Dict<String>> config) |> Stdlib.String.toBytes

        match (Builtin.fileWrite serializedConfig configPath) with
        | Ok _ -> Stdlib.Result.Result.Ok()
        | Error _ -> Stdlib.Result.Result.Error "Failed to update config.json"


      /// ----------------- Add/Remove Alias ----------------- ///

      let deleteAlias (alias: String) : Stdlib.Result.Result<String, String> =
        Builtin.printLine " - Deleting old alias if it exists"

        if shell () == Darklang.Stdlib.Cli.HostDefaultShell.Zsh then
          Darklang.Cli.Zsh.deleteAlias alias
        else if shell () == Darklang.Stdlib.Cli.HostDefaultShell.Bash then
          Darklang.Cli.Bash.deleteAlias alias
        else
          Stdlib.Result.Result.Error "Unsupported shell"


      let addAlias
        (alias: String)
        (command: String)
        : Stdlib.Result.Result<String, String> =
        Builtin.printLine " - Adding darklang alias"

        if shell () == Darklang.Stdlib.Cli.HostDefaultShell.Zsh then
          Darklang.Cli.Zsh.addAlias alias command
        else if shell () == Darklang.Stdlib.Cli.HostDefaultShell.Bash then
          Darklang.Cli.Bash.addAlias alias command
        else
          Stdlib.Result.Result.Error "Unsupported shell"


      /// ----------------- Add to PATH ----------------- ///
      let addToPathIfNeeded
        (executablePath: String)
        : Stdlib.Result.Result<Unit, String> =
        Builtin.printLine "Do you want to add to your PATH? (y/n): "
        let response = Builtin.stdinReadLine ()

        if response == "y" || response == "Y" then
          if shell () == Darklang.Stdlib.Cli.HostDefaultShell.Zsh then
            Darklang.Cli.Zsh.addToPath executablePath
          else if shell () == Darklang.Stdlib.Cli.HostDefaultShell.Bash then
            Darklang.Cli.Bash.addToPath executablePath
          else
            Stdlib.Result.Result.Error "Unsupported shell"

        else
          Builtin.printLine "Skipping PATH update"
          Stdlib.Result.Result.Ok()


      /// ----------------- Main ----------------- ///
      let downloadAndReplaceRelease () : Stdlib.Result.Result<Int64, String> =
        (Stdlib.Cli.Host.getRunTimeHost ())
        |> Stdlib.Result.andThen (fun host ->
          (getDownloadUrl host)
          |> Stdlib.Result.andThen (fun downloadUrl ->
            (getAssetName downloadUrl)
            |> Stdlib.Result.andThen (fun assetName ->
              (downloadAsset downloadUrl assetName)
              |> Stdlib.Result.andThen (fun _ ->
                (gunzipAsset assetName executablePath)
                |> Stdlib.Result.andThen
                  (fun (assetNameWithoutExt, newExecutablePath) ->
                    (Stdlib.Cli.grantExecutePermission newExecutablePath)
                    |> Stdlib.Result.andThen (fun _ ->
                      let latestVersion =
                        (getLatestReleaseTag ()) |> Builtin.unwrap

                      (updateConfig latestVersion configPath)
                      |> Stdlib.Result.andThen (fun updatedConfig ->
                        (writeConfig updatedConfig configPath)
                        |> Stdlib.Result.andThen (fun _ ->
                          (deleteAlias "darklang")
                          |> Stdlib.Result.andThen (fun _ ->
                            (addAlias "darklang" newExecutablePath)
                            |> Stdlib.Result.map (fun _ -> 0L))))))))))


      /// ----------------- Self Update ----------------- ///

      // check if we should skip self update (if we've updated in the last 24 hours don't update)
      let shouldSkipUpdate () : Bool =
        let config =
          (Builtin.fileRead configPath)
          |> Stdlib.Result.map (fun config ->
            config
            |> Stdlib.String.fromBytesWithReplacement
            |> Builtin.jsonParse<Dict<String>>
            |> (Stdlib.Result.map (fun config ->
              config
              |> PACKAGE.Darklang.Stdlib.Dict.get "lastUpdateTimestamp"
              |> Stdlib.Option.withDefault "0")))

        let lastUpdateTimestamp =
          match config with
          | Ok timestamp -> timestamp |> Stdlib.Result.withDefault "0"
          | Error e -> "0"

        let now = Stdlib.DateTime.now ()

        let secondsSinceLastUpdate =
          Stdlib.DateTime.toSeconds now
          - (lastUpdateTimestamp |> Stdlib.Int64.parse |> Builtin.unwrap)

        let oneDayInSeconds = 86400L
        secondsSinceLastUpdate < oneDayInSeconds


      let runSelfUpdate () : Int64 =
        if shouldSkipUpdate () then
          Builtin.printLine
            "Skipping self update because we've updated in the last 24 hours"

          0L
        else if isLatestVersion () then
          Builtin.printLine "Already on latest version"
          0L
        else
          Builtin.printLine "Running self update..."
          (downloadAndReplaceRelease ()) |> Builtin.unwrap


      /// ----------------- Ensure Darklang Setup ----------------- ///

      let ensureDirectoryExists (path: String) : Int64 =
        if (Builtin.fileExists configPath) != true then
          let makeDir =
            Stdlib.Process.runCommand $"mkdir -p \"$HOME/{executablePath}\""

          if makeDir.exitCode == 0L then
            addToPathIfNeeded executablePath
            0L
          else
            Builtin.printLine "Failed to create darklang dir"
            makeDir.exitCode
        else
          0L

      let ensureConfigExists
        (configPath: String)
        : Stdlib.Result.Result<Unit, String> =
        if (Builtin.fileExists configPath) != true then
          Builtin.fileWrite
            ("""{"version":"v0.0.0","lastUpdateTimestamp":"0"}"""
             |> Stdlib.String.toBytes)
            configPath
        else
          Stdlib.Result.Result.Ok()


      let ensureDarklangSetup () : Int64 =
        let dirSetupResult = ensureDirectoryExists executablePath

        if (dirSetupResult != 0L) then
          Builtin.printLine "Setting up darklang..."
          dirSetupResult
        else
          match ensureConfigExists configPath with
          | Ok _ -> runSelfUpdate ()
          | Error e ->
            Builtin.printLine "Failed to create or update config.json"
            1L