module Darklang =
  module Cli =
    type Command =
      | Help

      | PackageViewer of PackageViewer.Command

      | RunFunction of
        fnName: String *
        flagValue: Stdlib.Option.Option<String> *
        args: List<String>

      | RunScript of String * List<String>

      | Invalid of List<String>



    let parseArguments (args: List<String>) : Command =
      match args with
      | [ "help" ] -> Command.Help

      | "package" :: args ->
        match PackageViewer.parseCommand args with
        | Ok command -> Command.PackageViewer command
        | Error _ -> Command.Invalid [ "Invalid package command" ]

      | opt :: args ->
        // Extract "flag" value from last argument,
        // which is used like `--flag=wip-parser`.
        //
        // TODO: support flags as non-last arguments
        let flagValue, args = // Option<String>, List<String>
          match Stdlib.List.last args with
          | Some last ->
            if Stdlib.String.startsWith "--flag=" last then
              let flagValue = Stdlib.String.dropFirst last 7L
              (Stdlib.Option.Option.Some flagValue, Stdlib.List.dropLast args)
            else
              (Stdlib.Option.Option.None, args)

          // no args
          | None -> (Stdlib.Option.Option.None, args)


        if Stdlib.String.startsWith opt "@" then
          let fnName = opt |> Stdlib.String.dropFirst_v0 1L
          Command.RunFunction(fnName, flagValue, args)
        else
          Command.RunScript(opt, args)

      | _ -> Command.Invalid [ "Invalid arguments" ]



    let runFunction
      (fnName: String)
      (flagValue: Stdlib.Option.Option<String>)
      (args: List<String>)
      : Int64 =
      match flagValue with
      | Some "wip-parser" ->
        let nameResolver = Darklang.LanguageTools.NameResolver.empty ()

        let args =
          args
          |> Stdlib.List.map (fun arg ->
            arg
            |> Darklang.LanguageTools.Parser.parseToSimplifiedTree
            |> Darklang.LanguageTools.Parser.parseCliScript
            |> Builtin.unwrap
            |> fun parsedFile ->
                match parsedFile with
                | CliScript script -> script.exprsToEval)
          |> Stdlib.List.flatten
          |> Stdlib.List.map (fun arg ->
            LanguageTools.WrittenTypesToProgramTypes.Expr.toPT nameResolver arg)

        match Builtin.Cli.executeFunctionWithNewParser fnName args with
        | Ok result ->
          Builtin.printLine result
          0L

        | Error err ->
          Builtin.printLine err
          1L

      // Use old parser
      | _ ->
        match Builtin.Cli.executeFunction fnName args with
        | Ok result ->
          Builtin.printLine result
          0L

        | Error err ->
          Builtin.printLine err
          1L


    let runScript (scriptPath: String) (args: List<String>) : Int64 =
      match Builtin.File.read scriptPath with
      | Ok script ->
        let scriptSourceCode = Stdlib.String.fromBytesWithReplacement script

        let result =
          Builtin.Cli.parseAndExecuteScript
            scriptPath
            scriptSourceCode
            (Dict { args = args })

        match result with
        | Ok exitCode -> exitCode
        | Error e ->
          Builtin.printLine (Darklang.LanguageTools.RuntimeErrors.Error.toString e)

          1L

      | Error e ->
        Builtin.printLine e
        1L


    let executeCommand (command: Command) : Int64 =
      match command with
      | Help ->
        Builtin.printLine
          """Usage:
darklang help                                     Show this help message and exit

darklang [function name]                          Run a function in the package manager
  i.e. `darklang @Darklang.Stdlib.Bool.and true false`

darklang package                                  Explore the contents of the package manager

darklang [script path]                            Run a .dark script
  i.e. `darklang ./my-script.dark`
"""

        0L

      | PackageViewer command -> PackageViewer.executeCommand command

      | RunScript(scriptPath, args) -> runScript scriptPath args

      | RunFunction(fnName, flagValue, args) -> runFunction fnName flagValue args

      | Invalid args ->
        let args = args |> Stdlib.String.join " "

        Builtin.printLine
          $"Invalid command {args}. Use `darklang help` for more information."

        1L


    let executeCliCommand (args: List<String>) : Int64 =
      args |> Darklang.Cli.parseArguments |> Darklang.Cli.executeCommand