module Darklang =
  module Cli =
    module REPL =
      // Helper function that processes a list of messages
      let processMessages (state: State) (msgs: List<Msg>) : State =
        match msgs with
        | [] -> state
        | msg :: remainingMsgs ->
          // Process this message
          let (updatedState, newMsgs) = update state msg

          // First process any new messages generated by this update
          let stateAfterNewMsgs =
            if Stdlib.List.isEmpty newMsgs then
              updatedState
            else
              processMessages updatedState newMsgs

          // Then continue with the remaining messages
          processMessages stateAfterNewMsgs remainingMsgs


      let replInternal (state: State): Int64 =
        // Handle rendering based on the interaction mode
        let stateAfterRender =
          match state.interactionMode with
          // In NonInteractive mode, just render and exit
          // (we do this if you enter any command explicitly when starting the CLI)
          | NonInteractive ->
            Builtin.print (render state)
            { state with isExiting = true }

          // In Regular mode, don't clear the screen, just print the prompt
          | Regular ->
            if state.needsFullRedraw then
              // For command results, print the full render
              Builtin.print (render state)
              { state with needsFullRedraw = false }
            else
              // For regular key input, just update the prompt line in-place
              // Clear the current prompt line and reprint it
              Builtin.print "\r\u001b[K"
              Builtin.print (renderPromptOnly state)
              state

          // In RefreshScreen mode, clear the screen and redraw everything
          | RefreshScreen ->
            if state.needsFullRedraw then
              Builtin.stdoutClear()
              Builtin.print (render state)
              { state with needsFullRedraw = false }
            else
              // For regular key input, just update the prompt line in-place
              Builtin.print "\r\u001b[K"
              Builtin.print (renderPromptOnly state)
              state

        let keyRead = Stdlib.Cli.Stdin.readKey ()
        let msg = Msg.KeyPressed(keyRead.key, keyRead.modifiers, keyRead.keyChar)
        let (newState, messages) = update stateAfterRender msg

        // Process all messages
        let finalState = processMessages newState messages

        // Check if we should exit
        if keyRead.key == Stdlib.Cli.Stdin.Key.Key.Escape || finalState.isExiting then
          0L
        else
          // Continue the REPL loop with the updated state
          replInternal finalState

      /// Starts the REPL with the initial state
      let repl (args: List<String>) : Int64 =
        let state, initialMsgs = init args
        let state = processMessages state initialMsgs
        replInternal state

    type Command =
      | REPL of args: List<String>

    module ExecutionError =
      // TODO migrate this to some ParseAndExecuteScript submodule
      type ExecutionError =
        { msg: String; metadata: Dict<String> }

      let toString (err: ExecutionError.ExecutionError) : String =
        let metadataStr =
          err.metadata
          |> Stdlib.Dict.toList
          |> Stdlib.List.map (fun (k, v) -> $"- {k}: {v}")
          |> Stdlib.String.join "\n"
        $"Error: {err.msg}\n{metadataStr}"


    let parseArguments (args: List<String>) : Command =
      Command.REPL args

    let executeCommand (command: Command) : Int64 =
      match command with
      | REPL args ->
        REPL.repl args

      | Invalid args ->
        let args = args |> Stdlib.String.join " "

        Builtin.printLine
          $"Invalid command {args}. Use `dark help` for more information."

        1L

    let processNormally (args: List<String>) : Int64 =
      args |> parseArguments |> executeCommand

    let executeCliCommand (args: List<String>) : Int64 =
      processNormally args


