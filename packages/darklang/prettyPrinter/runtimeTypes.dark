module Darklang =
  module PrettyPrinter =
    module RuntimeTypes =
      let nameResolutionError
        (nr: PACKAGE.Darklang.LanguageTools.RuntimeErrors.NameResolution.Error)
        : String =
        String.join nr.names "."


      module FQName =
        let builtIn
          (namePart: String)
          (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQName.BuiltIn)
          : String =
          let modulesPart =
            match t.modules with
            | [] -> ""
            | modules -> modules |> String.join "." |> (fun parts -> $"{parts}.")

          let versionPart =
            if t.version == 0 then "" else $"_v{Int.toString t.version}"

          $"{modulesPart}{namePart}{versionPart}"


        let userProgram
          (namePart: String)
          (u: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQName.UserProgram)
          : String =
          // TODO: include modules

          let versionPart =
            if u.version == 0 then "" else $"_v{Int.toString u.version}"

          $"{namePart}{versionPart}"


        let package
          (namePart: String)
          (p: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQName.Package)
          : String =
          let modulesPart = String.join p.modules "."

          let versionPart =
            if p.version == 0 then "" else $"_v{Int.toString p.version}"

          $"PACKAGE.{p.owner}.{modulesPart}.{namePart}{versionPart}"


      module TypeName =
        let name
          (name: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.Name)
          : String =
          match name with
          | TypeName name -> name

        let builtIn
          (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.BuiltIn)
          : String =
          FQName.builtIn (name t.name) t

        let userProgram
          (u: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.UserProgram)
          : String =
          FQName.userProgram (name u.name) u

        let package
          (p: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.Package)
          : String =
          FQName.package (name p.name) p


      let typeName
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName)
        : String =
        match t with
        | BuiltIn b -> TypeName.builtIn b
        | UserProgram u -> TypeName.userProgram u
        | Package p -> TypeName.package p

      // module ConstantName =
      //   let name
      //     (name: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.Name)
      //     : String =
      //     match name with
      //     | ConstantName name -> name

      //   module BuiltIn =
      //     let fullForReference
      //       (c: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.BuiltIn)
      //       : String =
      //       PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.BuiltIn.fullForReference
      //         (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name c.name)
      //         c


      //   module UserProgram =

      //     let fullForReference
      //       (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.UserProgram)
      //       : String =
      //       PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.fullForReference
      //         (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name u.name)
      //         u

      //   module Package =

      //     let fullForReference
      //       (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.Package)
      //       : String =
      //       PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.fullForReference
      //         (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name p.name)
      //         p

      //   let fullForReference
      //     (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.ConstantName)
      //     : String =
      //     match t with
      //     | BuiltIn b ->
      //       PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.BuiltIn.fullForReference
      //         b
      //     | UserProgram u ->
      //       PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.UserProgram.fullForReference
      //         u
      //     | Package p ->
      //       PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.Package.fullForReference
      //         p


      module FnName =
        let name
          (name: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.Name)
          : String =
          match name with
          | FnName name -> name

        let builtIn
          (f: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.BuiltIn)
          : String =
          FQName.builtIn (name f.name) f

        let userProgram
          (u: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.UserProgram)
          : String =
          FQName.userProgram (name u.name) u

        let package
          (p: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.Package)
          : String =
          FQName.package (name p.name) p

      let fnName
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.FnName)
        : String =
        match t with
        | BuiltIn b -> FnName.builtIn b
        | UserProgram u -> FnName.userProgram u
        | Package p -> FnName.package p




      let typeReference
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference)
        : String =
        match t with
        | TUnit -> "Unit"
        | TBool -> "Bool"
        | TInt -> "Int"
        | TFloat -> "Float"
        | TChar -> "Character"
        | TString -> "String"
        | TUuid -> "Uuid"
        | TBytes -> "Bytes"
        | TDateTime -> "DateTime"
        | TPassword -> "Password"


        | TList inner -> $"List<{typeReference inner}>"
        | TTuple(first, second, theRest) ->
          (List.append [ first; second ] theRest)
          |> List.map (fun item -> typeReference item)
          |> String.join " * "
          |> fun parts -> "(" ++ parts ++ ")"

        | TDict inner -> $"Dict<{typeReference inner}>"

        | TDB inner -> $"DB<{typeReference inner}>"

        | TVariable varName -> "'" ++ varName

        | TCustomType(typ, args) ->
          let argsPart =
            match args with
            | [] -> ""
            | args ->
              args
              |> List.map (fun arg -> typeReference arg)
              |> String.join ", "
              |> fun parts -> $"<{parts}>"

          let typeNamePart =
            match typ with
            | Ok name -> typeName name
            | Error e -> nameResolutionError e

          $"{typeNamePart}{argsPart}"


        | TFn(args, ret) ->
          let argPart =
            args
            |> List.map (fun arg -> typeReference arg)
            |> String.join ", "
            |> fun parts -> "(" ++ parts ++ ")"

          $"{argPart} -> {typeReference ret}"