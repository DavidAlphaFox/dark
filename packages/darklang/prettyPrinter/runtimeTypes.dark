module Darklang =
  module PrettyPrinter =
    module RuntimeTypes =
      let nameResolutionError
        (nr: PACKAGE.Darklang.LanguageTools.RuntimeErrors.NameResolution.Error)
        : String =
        PACKAGE.Darklang.Stdlib.String.join nr.names "."

      module FQTypeName =

        let package
          (p: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQTypeName.Package)
          : String =
          let modulesPart = PACKAGE.Darklang.Stdlib.String.join p.modules "."

          let namePart = p.name

          let versionPart =
            if p.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString p.version}"

          $"PACKAGE.{p.owner}.{modulesPart}.{namePart}{versionPart}"


        let userProgram
          (u: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQTypeName.UserProgram)
          : String =
          let modulesPart =
            match u.modules with
            | [] -> ""
            | modules ->
              modules
              |> PACKAGE.Darklang.Stdlib.String.join "."
              |> (fun parts -> $"{parts}.")

          let namePart = u.name

          let versionPart =
            if u.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString u.version}"

          $"{modulesPart}{namePart}{versionPart}"

      // TODO rename to fqtypeName?
      let typeName
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQTypeName.FQTypeName)
        : String =
        match t with
        | Package p -> FQTypeName.package p
        | UserProgram u -> FQTypeName.userProgram u


      module FQConstantName =
        let builtIn
          (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQConstantName.Builtin)
          : String =
          let modulesPart =
            match t.modules with
            | [] -> ""
            | modules ->
              modules
              |> PACKAGE.Darklang.Stdlib.String.join "."
              |> (fun parts -> $"{parts}.")

          let namePart = t.name

          let versionPart =
            if t.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString t.version}"

          $"{modulesPart}{namePart}{versionPart}"

        let package
          (p: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQConstantName.Package)
          : String =
          let modulesPart = PACKAGE.Darklang.Stdlib.String.join p.modules "."

          let namePart = p.name

          let versionPart =
            if p.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString p.version}"

          $"PACKAGE.{p.owner}.{modulesPart}.{namePart}{versionPart}"

        let userProgram
          (u: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQConstantName.UserProgram)
          : String =
          let modulesPart =
            match u.modules with
            | [] -> ""
            | modules ->
              modules
              |> PACKAGE.Darklang.Stdlib.String.join "."
              |> (fun parts -> $"{parts}.")

          let namePart = u.name

          let versionPart =
            if u.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString u.version}"

          $"{modulesPart}{namePart}{versionPart}"

      // TODO rename to fqconstantName?
      let constantName
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQConstantName.FQConstantName)
        : String =
        match t with
        | Builtin b -> FQConstantName.builtIn b
        | Package p -> FQConstantName.package p
        | UserProgram u -> FQConstantName.userProgram u


      module FQFnName =
        let builtIn
          (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQFnName.Builtin)
          : String =
          let modulesPart =
            match t.modules with
            | [] -> ""
            | modules ->
              modules
              |> PACKAGE.Darklang.Stdlib.String.join "."
              |> (fun parts -> $"{parts}.")

          let namePart = t.name

          let versionPart =
            if t.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString t.version}"

          $"{modulesPart}{namePart}{versionPart}"

        let package
          (p: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQFnName.Package)
          : String =
          let modulesPart = PACKAGE.Darklang.Stdlib.String.join p.modules "."

          let namePart = p.name

          let versionPart =
            if p.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString p.version}"

          $"PACKAGE.{p.owner}.{modulesPart}.{namePart}{versionPart}"

        let userProgram
          (u: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQFnName.UserProgram)
          : String =
          let modulesPart =
            match u.modules with
            | [] -> ""
            | modules ->
              modules
              |> PACKAGE.Darklang.Stdlib.String.join "."
              |> (fun parts -> $"{parts}.")

          let namePart = u.name

          let versionPart =
            if u.version == 0L then
              ""
            else
              $"_v{PACKAGE.Darklang.Stdlib.Int64.toString u.version}"

          $"{modulesPart}{namePart}{versionPart}"

      // TODO rename to fqfnName?
      let fnName
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQFnName.FQFnName)
        : String =
        match t with
        | Builtin b -> FQFnName.builtIn b
        | Package p -> FQFnName.package p
        | UserProgram u -> FQFnName.userProgram u

      let typeReference
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference)
        : String =
        match t with
        | TUnit -> "Unit"
        | TBool -> "Bool"
        | TInt64 -> "Int64"
        | TUInt64 -> "UInt64"
        | TInt8 -> "Int8"
        | TUInt8 -> "UInt8"
        | TInt16 -> "Int16"
        | TUInt16 -> "UInt16"
        | TInt32 -> "Int32"
        | TUInt32 -> "UInt32"
        | TInt128 -> "Int128"
        | TUInt128 -> "UInt128"
        | TFloat -> "Float"
        | TChar -> "Char"
        | TString -> "String"
        | TUuid -> "Uuid"
        | TDateTime -> "DateTime"

        | TList inner -> $"List<{typeReference inner}>"
        | TDict inner -> $"Dict<{typeReference inner}>"
        | TTuple(first, second, theRest) ->
          (PACKAGE.Darklang.Stdlib.List.append [ first; second ] theRest)
          |> PACKAGE.Darklang.Stdlib.List.map (fun item -> typeReference item)
          |> PACKAGE.Darklang.Stdlib.String.join " * "
          |> fun parts -> "(" ++ parts ++ ")"

        | TCustomType(typ, args) ->
          let argsPart =
            match args with
            | [] -> ""
            | args ->
              args
              |> PACKAGE.Darklang.Stdlib.List.map (fun arg -> typeReference arg)
              |> PACKAGE.Darklang.Stdlib.String.join ", "
              |> fun parts -> $"<{parts}>"

          let typeNamePart =
            match typ with
            | Ok name -> typeName name
            | Error e -> nameResolutionError e

          $"{typeNamePart}{argsPart}"

        | TFn(args, ret) ->
          let argPart =
            args
            |> PACKAGE.Darklang.Stdlib.List.map (fun arg -> typeReference arg)
            |> PACKAGE.Darklang.Stdlib.String.join ", "
            |> fun parts -> "(" ++ parts ++ ")"

          $"{argPart} -> {typeReference ret}"

        | TDB inner -> $"DB<{typeReference inner}>"

        | TVariable varName -> "'" ++ varName


      let knownType
        (t: PACKAGE.Darklang.LanguageTools.RuntimeTypes.KnownType)
        : String =
        match t with
        | KTUnit -> "Unit"
        | KTBool -> "Bool"
        | KTInt64 -> "Int64"
        | KTUInt64 -> "UInt64"
        | KTInt8 -> "Int8"
        | KTUInt8 -> "UInt8"
        | KTInt16 -> "Int16"
        | KTUInt16 -> "UInt16"
        | KTInt32 -> "Int32"
        | KTUInt32 -> "UInt32"
        | KTInt128 -> "Int128"
        | KTUInt128 -> "UInt128"
        | KTFloat -> "Float"
        | KTChar -> "Char"
        | KTString -> "String"
        | KTDateTime -> "DateTime"
        | KTUuid -> "Uuid"

        | KTList typ -> $"List<{valueType typ}>"
        | KTDict typ -> $"Dict<{valueType typ}>"
        | KTTuple(t1, t2, trest) ->
          (PACKAGE.Darklang.Stdlib.List.append [ t1; t2 ] trest)
          |> PACKAGE.Darklang.Stdlib.List.map (fun item -> valueType item)
          |> PACKAGE.Darklang.Stdlib.String.join ", "
          |> fun s -> $"({s})"

        | KTFn(argTypes, retType) ->
          (Stdlib.List.push argTypes retType)
          |> PACKAGE.Darklang.Stdlib.List.map (fun vt -> valueType vt)
          |> PACKAGE.Darklang.Stdlib.String.join " -> "

        | KTCustomType(name, typeArgs) ->
          let typeArgsPortion =
            match typeArgs with
            | [] -> ""
            | args ->
              args
              |> PACKAGE.Darklang.Stdlib.List.map (fun t -> valueType t)
              |> PACKAGE.Darklang.Stdlib.String.join ", "
              |> fun betweenBrackets -> "<" + betweenBrackets + ">"

          (typeName name) ++ typeArgsPortion

        | KTDB typ -> $"Datastore<{valueType typ}>"


      let valueType
        (vt: PACKAGE.Darklang.LanguageTools.RuntimeTypes.ValueType)
        : String =
        match vt with
        | Known kt -> knownType kt
        | Unknown -> "_"


      module Dval =
        let valueTypeName
          (dv: PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval)
          : String =
          dv |> LanguageTools.RuntimeTypes.Dval.toValueType |> valueType

        let makeSpaces (len: Int64) : String =
          (PACKAGE.Darklang.Stdlib.List.repeat len " ")
          |> Builtin.unwrap
          |> PACKAGE.Darklang.Stdlib.String.join ""

        let withIndent
          (indent: Int64)
          (dv: PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval)
          : String =
          let nl = "\n" ++ (makeSpaces indent)
          let inl = "\n" ++ (makeSpaces (indent + 2L))
          let indent = indent + 2L

          let valueTypeName = valueTypeName dv

          match dv with
          | DUnit -> "()"

          | DBool true -> "true"
          | DBool false -> "false"

          | DChar c ->
            let c = Stdlib.Char.toString c
            $"'{c}'"
          | DString s -> $"\"{s}\""

          | DInt64 i -> Builtin.Int64.toString i
          | DUInt64 i -> Builtin.UInt64.toString i
          | DInt8 i -> Builtin.Int8.toString i
          | DUInt8 i -> Builtin.UInt8.toString i
          | DInt16 i -> Builtin.Int16.toString i
          | DUInt16 i -> Builtin.UInt16.toString i
          | DInt32 i -> Builtin.Int32.toString i
          | DUInt32 i -> Builtin.UInt32.toString i
          | DInt128 i -> Builtin.Int128.toString i
          | DUInt128 i -> Builtin.UInt128.toString i

          | DFloat f -> PACKAGE.Darklang.Stdlib.Float.toString f // CLEANUP: deal with Infinity, NegativeInfinity, and NaN

          | DDateTime d ->
            $"<{valueTypeName}: {PACKAGE.Darklang.Stdlib.DateTime.toString d}>"

          | DUuid uuid ->
            $"<{valueTypeName}: {PACKAGE.Darklang.Stdlib.Uuid.toString uuid}>"



          | DList(vt, l) ->
            if PACKAGE.Darklang.Stdlib.List.isEmpty l then
              $"{valueTypeName} []"
            else
              let elems =
                PACKAGE.Darklang.Stdlib.String.join
                  (PACKAGE.Darklang.Stdlib.List.map l (fun item ->
                    withIndent indent item))
                  ", "

              $"[{inl}{elems}{nl}]"

          | DTuple(first, second, theRest) ->
            let l = PACKAGE.Darklang.Stdlib.List.append [ first; second ] theRest

            let parts =
              PACKAGE.Darklang.Stdlib.List.map l (fun item -> withIndent indent item)

            let short = PACKAGE.Darklang.Stdlib.String.join parts ", "

            if PACKAGE.Darklang.Stdlib.String.length short <= 80L then
              $"({short})"
            else
              let long = PACKAGE.Darklang.Stdlib.String.join parts $"{inl}, "

              $"({inl}{long}{nl})"

          | DRecord(_, typeName, typeArgs, o) ->
            let strs =
              o
              |> PACKAGE.Darklang.Stdlib.Dict.toList
              |> PACKAGE.Darklang.Stdlib.List.map (fun pair ->
                let (key, value) = pair
                $"{key}: {withIndent indent value}")

            let elems = PACKAGE.Darklang.Stdlib.String.join strs $",{inl}"
            let typeStr = typeName typeName

            let typeArgsPart =
              match typeArgs with
              | [] -> ""
              | args ->
                args
                |> PACKAGE.Darklang.Stdlib.List.map (fun t -> valueTypeName t)
                |> PACKAGE.Darklang.Stdlib.String.join ", "
                |> fun betweenBrackets -> "<" + betweenBrackets + ">"

            typeStr ++ typeArgsPart ++ " {" ++ inl ++ elems ++ nl ++ "}"

          | DDict d ->
            if d == PACKAGE.Darklang.Stdlib.Dict.empty then
              "{}"
            else
              let strs =
                d
                |> PACKAGE.Darklang.Stdlib.Dict.toList
                |> PACKAGE.Darklang.Stdlib.List.map (fun pair ->
                  let (key, value) = pair
                  $"{key}: {withIndent indent value}")

              let elems = PACKAGE.Darklang.Stdlib.String.join strs $",{inl}"
              "{" ++ inl ++ elems ++ nl ++ "}"

          | DEnum(_, typeName, typeArgs, caseName, fields) ->
            let typeArgsPart =
              match typeArgs with
              | [] -> ""
              | typeArgs ->
                typeArgs
                |> PACKAGE.Darklang.Stdlib.List.map (fun typeArg ->
                  valueType typeArg)
                |> PACKAGE.Darklang.Stdlib.String.join ", "
                |> fun parts -> $"<{parts}>"

            let short =
              let fieldStr =
                fields
                |> PACKAGE.Darklang.Stdlib.List.map (fun value ->
                  withIndent indent value)
                |> PACKAGE.Darklang.Stdlib.String.join ", "

              let fieldStr = if fieldStr == "" then "" else $"({fieldStr})"

              let typeStr = typeName typeName
              $"{typeStr}{typeArgsPart}.{caseName}{fieldStr}"

            if PACKAGE.Darklang.Stdlib.String.length short <= 80L then
              short
            else
              let fieldStr =
                fields
                |> PACKAGE.Darklang.Stdlib.List.map (fun value ->
                  withIndent indent value)
                |> PACKAGE.Darklang.Stdlib.String.join $",{inl}"

              let fieldStr = if fieldStr == "" then "" else $"({inl}{fieldStr}{nl})"

              let typeStr = typeName typeName
              $"{typeStr}{typeArgsPart}.{caseName}{fieldStr}"


          | DFnVal(NamedFn fnName) ->
            PACKAGE.Darklang.PrettyPrinter.RuntimeTypes.FnName.fnName fnName

          | DFnVal(Lambda impl) ->
            // Note: this use case is safe (RE docs/dblock-serialization.md)
            let ps =
              impl.parameters
              |> Stdlib.List.map Stdlib.Tuple2.second
              |> Stdlib.String.join ", "

            // TODO
            // let body = impl.body |> RuntimeTypes.Expr.toString
            $"\\ {ps} {{ ... }}"


          | DDB name -> $"<{valueTypeName}: {name}>"



      let dval (dv: PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval) : String =
        Dval.withIndent 0L dv