// TODO:
//alias PT = PACKAGE.Darklang.Stdlib.ProgramTypes
//alias RT = PACKAGE.Darklang.Stdlib.RuntimeTypes

// TODO: update all of the 'namePart's to nameToStrings with fn inputs

module Darklang =
  module PrettyPrinter =
    module ProgramTypes =
      module FQName =
        module BuiltIn =
          let fullForReference
            (namePart: String)
            (t: PACKAGE.Darklang.Stdlib.ProgramTypes.FQName.BuiltIn)
            : String =
            let modulesPart =
              match t.modules with
              | [] -> ""
              | modules -> modules |> String.join "." |> (fun parts -> $"{parts}.")

            let versionPart =
              if t.version == 0 then "" else $"_v{Int.toString t.version}"

            $"{modulesPart}{namePart}{versionPart}"


        module UserProgram =
          let atDefinition
            // TODO: take in just typ and version - modules should have already been dealt with
            (namePart: String)
            (u: PACKAGE.Darklang.Stdlib.ProgramTypes.FQName.UserProgram)
            : String =
            match u.modules with
            | [] ->
              let versionPart =
                if u.version == 0 then "" else $"_v{Int.toString u.version}"

              $"{namePart}{versionPart}"
            | _ -> "(UserTypeName.atDefinition unexpected nonempty u.modules)"

          let fullForReference
            (namePart: String)
            (u: PACKAGE.Darklang.Stdlib.ProgramTypes.FQName.UserProgram)
            : String =
            let versionPart =
              if u.version == 0 then "" else $"_v{Int.toString u.version}"

            $"{namePart}{versionPart}"


        module Package =
          let atDefinition
            // TODO: take in just owner, typ, and version - modules should have already been dealt with
            (namePart: String)
            (p: PACKAGE.Darklang.Stdlib.ProgramTypes.FQName.Package)
            : String =
            let versionPart =
              if p.version == 0 then "" else $"_v{Int.toString p.version}"

            $"{namePart}{versionPart}"

          let fullForReference
            (namePart: String)
            (p: PACKAGE.Darklang.Stdlib.ProgramTypes.FQName.Package)
            : String =
            let modulesPart = String.join p.modules "."

            let versionPart =
              if p.version == 0 then "" else $"_v{Int.toString p.version}"

            $"PACKAGE.{p.owner}.{modulesPart}.{namePart}{versionPart}"


      module TypeName =
        let name (name: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.Name) : String =
          match name with
          | TypeName name -> name

        module BuiltIn =
          let fullForReference (t: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.BuiltIn)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.BuiltIn.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name t.name)
              t

        module UserProgram =
          let atDefinition
            (u: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name u.name)
              u

          let fullForReference
            (u: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name u.name)
              u

        module Package =
          let atDefinition
            (p: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name p.name)
              p

          let fullForReference
            (p: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name p.name)
              p

        let atDefinition
          (t: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.T)
          : String =
          match t with
          | BuiltIn b ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.BuiltIn.atDefinition
              b
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.UserProgram.atDefinition
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.Package.atDefinition
              p

        let fullForReference
          (t: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.T)
          : String =
          match t with
          | BuiltIn b ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.BuiltIn.fullForReference
              b
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.UserProgram.fullForReference
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.Package.fullForReference
              p


      module FnName =
        let name (name: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.Name) : String =
          match name with
          | FnName name -> name

        module BuiltIn =
          let fullForReference
            (f: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.BuiltIn)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.BuiltIn.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name f.name)
              f

        module UserProgram =
          let atDefinition
            (u: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name u.name)
              u

          let fullForReference
            (u: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name u.name)
              u

        module Package =
          let atDefinition
            (p: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name p.name)
              p

          let fullForReference
            (p: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name p.name)
              p

        let atDefinition
          (t: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.T)
          : String =
          match t with
          | BuiltIn _b -> "why are you trying to print a stdlib type name _definition_?"
          | UserProgram u -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.UserProgram.atDefinition
              u
          | Package p -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.Package.atDefinition
              p

        let fullForReference
          (t: PACKAGE.Darklang.Stdlib.ProgramTypes.FnName.T)
          : String =
          match t with
          | BuiltIn b ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.BuiltIn.fullForReference
              b
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.UserProgram.fullForReference
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.Package.fullForReference
              p


      let typeReference
        (t: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeReference)
        : String =
        match t with
        | TVariable varName -> "'" ++ varName

        | TUnit -> "Unit"
        | TBool -> "Bool "
        | TInt -> "Int"
        | TFloat -> "Float"
        | TChar -> "Character"
        | TString -> "String"
        | TDateTime -> "DateTime"
        | TUuid -> "Uuid"
        | TBytes -> "Bytes"
        | TPassword -> "Password"

        | TList inner ->
          $"List<{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference inner}>"

        | TTuple(first, second, theRest) ->
          (List.append [ first; second ] theRest)
          |> List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference item)
          |> String.join " * "
          |> fun parts -> "(" ++ parts ++ ")"

        | TOption inner ->
          $"Option<{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference inner}>"

        | TDict inner ->
          $"Dict<{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference inner}>"

        | TCustomType(typ, args) ->
          let argsPart =
            match args with
            | [] -> ""
            | args ->
              args
              |> List.map (fun arg ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference arg)
              |> String.join ", "
              |> fun parts -> $"<{parts}>"

          $"{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference typ}{argsPart}"

        | TDB inner ->
          $"DB<{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference inner}>"

        | TFn(args, ret) ->
          let argPart =
            args
            |> List.map (fun arg ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference arg)
            |> String.join ", "
            |> fun parts -> "(" ++ parts ++ ")"

          $"{argPart} -> {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference ret}"
        | _ ->
          let s =
            match
              Json.serialize<PACKAGE.Darklang.Stdlib.ProgramTypes.TypeReference> t
            with
            | Ok s -> s
            | Error e -> "Err" ++ e

          $"({s})"

      let letPattern (lp: PACKAGE.Darklang.Stdlib.ProgramTypes.LetPattern) : String =
        match lp with
        | LPVariable(_id, name) -> name
        | LPTuple(_id, first, second, theRest) ->
          (List.append [ first; second ] theRest)
          |> List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.letPattern item)
          |> String.join ", "
          |> fun parts -> "(" ++ parts ++ ")"

      let matchPattern
        (mp: PACKAGE.Darklang.Stdlib.ProgramTypes.MatchPattern)
        : String =
        match mp with
        | MPVariable(_id, name) -> name
        | MPUnit _id -> "()"
        | MPBool(_id, b) -> Bool.toString b
        | MPInt(_id, i) -> Int.toString i
        | MPFloat(_id, sign, whole, remainder) ->
          let wholePart = whole

          let remainderPart = $".{remainder}"

          $"{PACKAGE.Darklang.PrettyPrinter.sign sign}{wholePart}{remainderPart}"

        | MPChar(_id, c) -> c
        | MPString(_id, s) -> s

        | MPList(_id, items) ->
          items
          |> List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern item)
          |> String.join ", "
          |> fun parts -> "[" ++ parts ++ "]"

        | MPListCons(_id, head, tail) ->
          let headPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern head

          let tailPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern tail

          $"{headPart} :: {tailPart}"

        | MPTuple(_, first, second, theRest) ->
          (List.append [ first; second ] theRest)
          |> List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern item)
          |> String.join ", "
          |> fun parts -> "(" ++ parts ++ ")"

        | MPEnum(_id, caseName, fieldPats) ->
          match fieldPats with
          | [] -> caseName
          | [ single ] ->
            $"{caseName} {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern single}"
          | fieldPats ->
            let fieldPart =
              fieldPats
              |> List.map (fun pat ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern pat)
              |> String.join ", "

            $"{caseName} ({fieldPart})"


      let binaryOperation
        (b: PACKAGE.Darklang.Stdlib.ProgramTypes.BinaryOperation)
        : String =
        match b with
        // TODO: consider surrounding with spaces
        | BinOpAnd -> "&&"
        | BinOpOr -> "||"

      let infixFnName
        (i: PACKAGE.Darklang.Stdlib.ProgramTypes.InfixFnName)
        : String =
        match i with
        | ArithmeticPlus -> "+"
        | ArithmeticMinus -> "-"
        | ArithmeticMultiply -> "*"
        | ArithmeticDivide -> "/"
        | ArithmeticModulo -> "%"
        | ArithmeticPower -> "^"
        | ComparisonGreaterThan -> ">"
        | ComparisonGreaterThanOrEqual -> ">="
        | ComparisonLessThan -> "<"
        | ComparisonLessThanOrEqual -> "<="
        | ComparisonEquals -> "=="
        | ComparisonNotEquals -> "<>"
        | StringConcat -> "++"

      let infix (i: PACKAGE.Darklang.Stdlib.ProgramTypes.Infix) : String =
        match i with
        | InfixFnCall i -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.infixFnName i
        | BinOp b -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.binaryOperation b

      let stringSegment
        (s: PACKAGE.Darklang.Stdlib.ProgramTypes.StringSegment)
        : String =
        match s with
        | StringText text -> text
        | StringInterpolation expr ->
          $"{{{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr}}}"

      let pipeExpr (p: PACKAGE.Darklang.Stdlib.ProgramTypes.PipeExpr) : String =
        match p with
        | EPipeVariable(_id, varName) -> varName

        | EPipeLambda(_id, args, body) ->
          let argsPart =
            args |> List.map (fun pair -> Tuple2.second pair) |> String.join " "
          let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body
          $"fun {argsPart} -> {bodyPart}"

        | EPipeInfix(_id, infix, expr) ->
          let infixPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.infix infix
          let exprPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr
          $"({infixPart}) {exprPart}"

        | EPipeFnCall(_id, fnName, typeArgs, args) ->
          let fnNamePart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.fullForReference
              fnName

          let typeArgsPart =
            match typeArgs with
            | [] -> ""
            | _ ->
              typeArgs
              |> List.map (fun typeArg ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference typeArg)
              |> String.join ", "
              |> fun parts -> $"<{parts}>"

          let argsPart =
            args
            |> List.map (fun arg ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr arg)
            |> List.map (fun arg -> $"({arg})")
            |> String.join " "

          $"{fnNamePart}{typeArgsPart} {argsPart}"

        // PACKAGE.Darklang.Stdlib.ID *
        // typeName: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeName.T *
        // caseName: String *
        // fields: List<PACKAGE.Darklang.Stdlib.ProgramTypes.Expr>
        | EPipeEnum(_id, typeName, caseName, fields) ->
          let typeNamePart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
              typeName

          match fields with
          | [] -> $"{typeNamePart}.{caseName}"
          | fields ->
            let fieldPart =
              fields
              |> List.map (fun field ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr field)
              |> List.map (fun field -> $"({field})")
              |> String.join " "

            $"{typeNamePart}.{caseName} {fieldPart}"

      let expr (e: PACKAGE.Darklang.Stdlib.ProgramTypes.Expr) : String =
        match e with
        | EUnit _id -> "()"

        // simple data
        | EBool(_id, b) -> Bool.toString b
        | EInt(_id, i) -> Int.toString i
        | EFloat(_id, sign, whole, remainder) ->
          let signPart = PACKAGE.Darklang.PrettyPrinter.sign sign
          let rem = $".{remainder}" |> Float.parse
          let remainderPart =
              match rem with
              | Ok r ->
                  if r == 0.0 then ""
                  else (r  |> Float.toString) |> String.dropFirst 2
              | Error e -> e
          let wholePart =
              match whole with
              | "0" -> if remainderPart != "" then "0" else ""
              | _ -> whole
          let formattedFloat =
              if remainderPart == "" then $"{wholePart}.0"
              else $"{wholePart}.{remainderPart}"
          $"{signPart}{formattedFloat}"


        | EChar(_id, c) -> "\"" ++ c ++ "\""

        | EString(_id, segments) ->
          match segments with
          | [] -> "\"\""
          | [ StringText text ] ->
            let escapedText = String.replaceAll text "\n" "\\n"
            $"\"{escapedText}\""
          | segments ->
            let inner =
              segments
              |> List.map (fun segment ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.stringSegment segment)
              |> String.join ""

            $"$\"{inner}\""


        // structures of data

        | EList(_id, items) ->
          items
          |> List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr item)
          |> String.join "; "
          |> fun parts -> "[" ++ parts ++ "]"

        // | EDict of
        //   PACKAGE.Darklang.Stdlib.ID *
        //   List<String * PACKAGE.Darklang.Stdlib.ProgramTypes.Expr>

        | ETuple(_id, first, second, theRest) ->
          (List.append [ first; second ] theRest)
          |> List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr item)
          |> String.join ", "
          |> fun parts -> "(" ++ parts ++ ")"

        | ERecord(_id, typeName, fields) ->
          let typeNamePart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
              typeName

          let fieldPart =
            fields
            |> List.map (fun pair ->
              let (name, expr) = pair
              $"{name} = {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr}")
            |> String.join "; "
            |> fun parts -> "{ " ++ parts ++ " }"
            |> PACKAGE.Darklang.PrettyPrinter.indent

          $"{typeNamePart}\n{fieldPart}"

        | EEnum(_id, typeName, caseName, fields) ->
          let typeNamePart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
              typeName

          match fields with
          | [] -> $"{typeNamePart}.{caseName}"
          | fields ->
            let fieldPart =
              fields
              |> List.map (fun field ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr field)
              |> String.join ", "

            $"{typeNamePart}.{caseName}({fieldPart})"


        // declaring and accessing variables

        | ELet(_id, pattern, rhs, body) ->
          let patternPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.letPattern pattern

          let rhsPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr rhs
          let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body

          $"let {patternPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent rhsPart}\n{bodyPart}"

        | EFieldAccess(id, expr, fieldName) ->
          let exprPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr

          // TODO: only sometimes need to wrap exprPart in parens

          $"({exprPart}).{fieldName}"

        | EVariable(_id, name) -> name


        // control flow

        | EIf(id, cond, thenBranch, elseBranch) ->
          let condPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr cond

          let thenPart =
            (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr thenBranch)
            |> PACKAGE.Darklang.PrettyPrinter.indent

          let elsePart =
            (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr elseBranch)
            |> PACKAGE.Darklang.PrettyPrinter.indent

          $"if {condPart} then\n{thenPart}\nelse\n{elsePart}"

        | EMatch(_id, arg, cases) ->
          let cases =
            cases
            |> List.map (fun pair ->
              let (pattern, body) = pair

              let patternPart =
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern pattern

              let bodyPart =
                (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body)
                |> PACKAGE.Darklang.PrettyPrinter.indent

              $"| {patternPart} ->\n{bodyPart}")

          let casesPart = String.join cases "\n"

          let argPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr arg

          $"match {argPart} with \n{casesPart}"


        | EPipe(_id, expr, firstPipeExpr, otherPipeExprs) ->
          // PACKAGE.Darklang.Stdlib.ID *
          // PACKAGE.Darklang.Stdlib.ProgramTypes.Expr *
          // PACKAGE.Darklang.Stdlib.ProgramTypes.PipeExpr *
          // List<PACKAGE.Darklang.Stdlib.ProgramTypes.PipeExpr>
          let exprPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr

          let firstPipePart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.pipeExpr firstPipeExpr

          let otherPipeParts =
            otherPipeExprs
            |> List.map (fun (pipeExpr) -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.pipeExpr pipeExpr )
            |> String.join " \n|> "

          let pipesPart =
            if otherPipeParts == "" then firstPipePart
            else $"{firstPipePart}\n|> {otherPipeParts}"

          $"{exprPart} \n|> {pipesPart}"



        // function calls

        | EInfix(_id, infix, left, right) ->
          let infixPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.infix infix

          let leftPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr left

          let rightPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr right

          // TODO: might need to wrap in parens
          $"({leftPart}) {infixPart} ({rightPart})"

        | ELambda(_id, args, body) ->
          let argsPart =
            args |> List.map (fun pair -> Tuple2.second pair) |> String.join " "

          let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body

          $"(fun {argsPart} -> \n {PACKAGE.Darklang.PrettyPrinter.indent bodyPart})"

        | EFnCall(_id, fnName, typeArgs, args) ->
          let fnNamePart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.fullForReference
              fnName

          let argsPart =
            args
            |> List.map (fun arg ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr arg)
            |> String.join " "

          match typeArgs with
          | [] -> $"{fnNamePart} {argsPart}"
          | _ ->
            let typeArgsPart =
              typeArgs
              |> List.map (fun typeArg ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference typeArg)
              |> String.join ", "

            $"{fnNamePart}<{typeArgsPart}> {argsPart}"

        // PACKAGE.Darklang.Stdlib.ID *
        // record: PACKAGE.Darklang.Stdlib.ProgramTypes.Expr *
        // updates: List<String * PACKAGE.Darklang.Stdlib.ProgramTypes.Expr>
        | ERecordUpdate(_id, record, updates) ->
          let recordPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr record

          let updatePart =
            updates
            |> List.map (fun pair ->
              let (fieldName, expr) = pair
              $"{fieldName} = {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr}")
            |> String.join "; "

          // TODO: don't always need the parens

          $"{{ ({recordPart}) with {updatePart} }}"


      let deprecation<'name>
        (m: 'name -> String)
        (d: PACKAGE.Darklang.Stdlib.ProgramTypes.Deprecation)
        : String =
        match d with
        | NotDeprecated -> "NotDeprecated"
        | RenamedTo name -> $"RenamedTo {m name}"
        | ReplacedBy name -> $"ReplacedBy {m name}"
        | DeprecatedBecause reason -> $"DeprecatedBecause {reason}"

      module TypeDeclaration =
        let recordField
          (d: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeDeclaration.RecordField)
          : String =
          // TODO: /// for description
          $"{d.name} : {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference d.typ}"

        let enumField
          (d: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeDeclaration.EnumField)
          : String =
          match d.label with
          | Nothing ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference d.typ
          | Just label ->
            $"{label}: {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference d.typ}"

        let enumCase
          (d: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeDeclaration.EnumCase)
          : String =
          match d.fields with
          | [] -> "| " ++ d.name
          | fields ->
            let fieldPart =
              fields
              |> List.map (fun field ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeDeclaration.enumField
                  field)
              |> String.join " * "

            $"| {d.name} of {fieldPart}"


      let customType
        (d: PACKAGE.Darklang.Stdlib.ProgramTypes.TypeDeclaration.T)
        : String =
        match d with
        | Alias typeRef ->
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference typeRef

        | Record(firstField, additionalFields) ->
          let fieldsPart =
            (List.append [ firstField ] additionalFields)
            |> List.map (fun field ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeDeclaration.recordField
                field)
            |> String.join "\n"

          "{\n" ++ (PACKAGE.Darklang.PrettyPrinter.indent fieldsPart) ++ "\n}"

        | Enum(firstCase, additionalCases) ->
          let cases = List.append [ firstCase ] additionalCases

          cases
          |> List.map (fun case ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeDeclaration.enumCase case)
          |> String.join "\n"


      module Handler =
        let cronInterval
          (c: PACKAGE.Darklang.Stdlib.ProgramTypes.Handler.CronInterval)
          : String =
          match c with
          | EveryDay -> "Every Day"
          | EveryWeek -> "Every Week"
          | EveryFortnight -> "Every Fortnight"
          | EveryHour -> "Every Hour"
          | Every12Hours -> "Every 12 Hours"
          | EveryMinute -> "Every Minute"

        let spec (s: PACKAGE.Darklang.Stdlib.ProgramTypes.Handler.Spec) : String =
          match s with
          | HTTP(route, method) -> $"[<HttpHandler({method}, {route})>]"
          | Worker name -> $"[<Worker({name})>]"
          | Cron(name, interval) ->
            $"[<Cron({name}, {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.Handler.cronInterval interval})>]"
          | REPL name -> $"[<REPL({name})>]"

      let handler (h: PACKAGE.Darklang.Stdlib.ProgramTypes.Handler.T) : String =
        let specPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.Handler.spec h.spec

        $"{specPart}\nlet _handler _ignored =\n  {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr h.ast}"


      let db (db: PACKAGE.Darklang.Stdlib.ProgramTypes.DB.T) : String =
        let versionPart =
          if db.version == 0 then
            ""
          else
            $"_v{Int.toString db.version}"

        let typPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference db.typ

        $"type {db.name}{versionPart} = {typPart}"


      let userType
        (userType: PACKAGE.Darklang.Stdlib.ProgramTypes.UserType)
        : String =
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.UserProgram.atDefinition
            userType.name

        let typeParamPart =
          match userType.typeParams with
          | [] -> ""
          | _ ->
            userType.typeParams
            |> List.map (fun typeParam -> $"'{typeParam}")
            |> String.join ", "
            |> fun parts -> $"<{parts}>"

        let defPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.customType userType.definition

        $"type {namePart}{typeParamPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent defPart}"


      module UserFunction =
        let parameter
          (p: PACKAGE.Darklang.Stdlib.ProgramTypes.UserFunction.Parameter)
          : String =
          // TODO: handle `description`
          let typPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference p.typ

          $"({p.name}: {typPart})"

      let userFunction
        (u: PACKAGE.Darklang.Stdlib.ProgramTypes.UserFunction.T)
        : String =
        // TODO: do something with description and deprecated
        // TODO: shouldn't there be modules here somewhere?
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.UserProgram.atDefinition
            u.name

        let typeParamsPart = String.join u.typeParams " "

        let paramsPart =
          String.join (
            List.map u.parameters (fun p ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.UserFunction.parameter p)
          ) " "

        let retPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference u.returnType

        let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr u.body
        $"let {namePart} {typeParamsPart} {paramsPart} : {retPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent bodyPart}"

      // module Toplevel =
      //   type T =
      //     | TLHandler of Handler.T
      //     | TLDB of DB.T
      //     | TLFunction of UserFunction.T
      //     | TLType of UserType.T


      // let secret (s: PACKAGE.Darklang.Stdlib.Secret.T) : String =
      //   let versionPart = if s.version == 0 then "" else $"_v{Int.toString s.version}"

      //   $"let {s.name}{versionPart} = \"*****\""


      module PackageFn =
        let parameter
          (p: PACKAGE.Darklang.Stdlib.ProgramTypes.PackageFn.Parameter)
          : String =
          // TODO: /// for description
          $"({p.name}: {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference p.typ})"

      let packageFn (p: PACKAGE.Darklang.Stdlib.ProgramTypes.PackageFn.T) : String =
        // TODO: handle `deprecated`, `description`
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.Package.atDefinition
            p.name

        let typeParamPart =
          match p.typeParams with
          | [] -> ""
          | _ ->
            p.typeParams
            |> List.map (fun typeParam -> $"'{typeParam}")
            |> String.join ", "
            |> fun parts -> $"<{parts}>"

        let paramPart =
          p.parameters
          |> List.map (fun param ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.PackageFn.parameter param)
          |> String.join " "

        let retPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference p.returnType

        let bodyPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr p.body

        $"let {namePart}{typeParamPart} {paramPart} : {retPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent bodyPart}"


      let packageType
        (p: PACKAGE.Darklang.Stdlib.ProgramTypes.PackageType.T)
        : String =
        // TODO: take care of deprecated and description
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.Package.atDefinition
            p.name

        let typeParamPart =
          match p.typeParams with
          | [] -> ""
          | _ ->
            p.typeParams
            |> List.map (fun typeParam -> $"'{typeParam}")
            |> String.join ", "
            |> fun parts -> $"<{parts}>"

        let defPart =
          (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.customType p.definition)
          |> PACKAGE.Darklang.PrettyPrinter.indent

        $"type {namePart}{typeParamPart} =\n{defPart}"