module Darklang =
  module Stdlib =
    module Option =

      type Option<'v> =
        | Some of 'v
        | None

      /// If <param option> is {{Some <var value>}}, returns {{fn <var value>}}. The
      /// lambda <fn fn> is applied to <var value> and the result is wrapped in
      /// {{Some}}. Otherwise, returns {{None}}
      let map (option: PACKAGE.Darklang.Stdlib.Option.Option<'a>) (fn: 'a -> 'b) : PACKAGE.Darklang.Stdlib.Option.Option<'b> =
        match option with
        | Some v -> PACKAGE.Darklang.Stdlib.Option.Option.Some (v |> fn)
        | None -> PACKAGE.Darklang.Stdlib.Option.Option.None


      /// If <param option> is {{Some <var value>}}, returns {{fn <var value>}}. The
      /// lambda <fn fn> is applied to <var value> and the result is wrapped in
      /// {{Some}}. Otherwise, returns {{None}}
      let andThen (option: PACKAGE.Darklang.Stdlib.Option.Option<'a>) (fn: 'a -> PACKAGE.Darklang.Stdlib.Option.Option<'b>) : PACKAGE.Darklang.Stdlib.Option.Option<'b> =
        match option with
        | Some v -> v |> fn
        | None -> PACKAGE.Darklang.Stdlib.Option.Option.None

      /// If <param option> is {{Some <var value>}}, returns <var value>. Otherwise,
      /// returns <param default>
      let withDefault (option: PACKAGE.Darklang.Stdlib.Option.Option<'a>) (default_: 'a) : 'a =
        match option with
        | Some v -> v
        | None -> default_





