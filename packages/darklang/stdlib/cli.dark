module Darklang =
  module Stdlib =
    module Cli =
      module Unix =
        /// Grants execute permissions to the specified file.
        /// If successful, returns {{Ok <param path>}}. Otherwise, returns an {{Error <var stderr>}}
        //TODO : pass OS as a parameter to this function, to handle windows
        let grantExecutePermission
          (path: String)
          : Stdlib.Result.Result<String, String> =
          let grantPermission = Stdlib.Process.runCommand $"chmod +x {path}"

          if grantPermission.exitCode == 0L then
            Stdlib.Result.Result.Ok path
          else
            Stdlib.Result.Result.Error grantPermission.stderr


        /// Adds an alias to the user's default shell configuration file. The alias will be available in new shell sessions.
        let addAlias
          (os: Host.OS)
          (shell: Host.HostDefaultShell)
          (alias: String)
          (command: String)
          : Stdlib.Result.Result<String, String> =
          match os, shell with
          | Linux, Bash -> Darklang.Cli.Bash.addAlias alias command
          | Linux, Zsh -> Darklang.Cli.Zsh.addAlias alias command
          | MacOS, Bash -> Darklang.Cli.Bash.addAlias alias command
          | MacOS, Zsh -> Darklang.Cli.Zsh.addAlias alias command
          | _ -> Stdlib.Result.Result.Error "Unsupported OS or shell"


        /// Deletes an alias from the user's default shell configuration file.
        let deleteAlias
          (os: Host.OS)
          (shell: Host.HostDefaultShell)
          (alias: String)
          : Stdlib.Result.Result<String, String> =
          match os, shell with
          | Linux, Bash -> Darklang.Cli.Bash.deleteAlias alias
          | Linux, Zsh -> Darklang.Cli.Zsh.deleteAlias alias
          | MacOS, Bash -> Darklang.Cli.Bash.deleteAlias alias
          | MacOS, Zsh -> Darklang.Cli.Zsh.deleteAlias alias
          | _ -> Stdlib.Result.Result.Error "Unsupported OS or shell"


        /// Adds a path to the user's default shell configuration file. The path will be available in new shell sessions.
        let addToPath
          (os: Host.OS)
          (shell: Host.HostDefaultShell)
          (path: String)
          : Stdlib.Result.Result<String, String> =
          Builtin.printLine "Do you want to add to your PATH? (y/n): "
          let response = Builtin.stdinReadLine ()

          if response == "y" || response == "Y" then
            match os, shell with
            | Linux, Bash -> Darklang.Cli.Bash.addToPath path
            | Linux, Zsh -> Darklang.Cli.Zsh.addToPath path
            | MacOS, Bash -> Darklang.Cli.Bash.addToPath path
            | MacOS, Zsh -> Darklang.Cli.Zsh.addToPath path
            | _ -> Stdlib.Result.Result.Error "Unsupported OS or shell"
          else
            Stdlib.Result.Result.Ok "Skipped adding to PATH"


      module Host =
        type HostDefaultShell =
          | Bash
          | Zsh

        type OS =
          | Linux
          | MacOS
          | Windows

        type Architechture =
          | X86_64
          | Aarch64
          | Arm
          | Arm64
          | Armv7l

        type Host = { os: OS; arch: Architechture }


        /// Determines the default shell used by the current user.
        /// Returns  {{Ok <HostDefaultShell>}} if successful, or {{Error}} with a message if the shell is unsupported or an error occurs.
        let getShell () : Stdlib.Result.Result<HostDefaultShell, String> =
          let shell = Stdlib.Process.runCommand "echo $SHELL"

          if shell.exitCode == 0L then
            let shell = shell.stdout |> Stdlib.String.trim

            match shell with
            | "/bin/bash" -> Stdlib.Result.Result.Ok HostDefaultShell.Bash
            | "/bin/zsh" -> Stdlib.Result.Result.Ok HostDefaultShell.Zsh
            | _ -> Stdlib.Result.Result.Error "Unsupported shell"
          else
            Stdlib.Result.Result.Error shell.stderr


        /// Identifies and returns the operating system and architecture of the runtime host.
        /// Returns {{Ok <Host>}} on success, or an {{Error}} with combined stderr if it fails
        let getRunTimeHost () : Stdlib.Result.Result<Host, String> =
          let os = Stdlib.Process.runCommand "uname"
          let arch = Stdlib.Process.runCommand "uname -m"

          match os.exitCode, arch.exitCode with
          | 0L, 0L ->
            let os = Stdlib.String.trim os.stdout
            let arch = Stdlib.String.trim arch.stdout

            let os =
              match os with
              | "Linux" -> OS.Linux
              | "Darwin" -> OS.MacOS
              | "Windows" -> OS.Windows

            let arch =
              match arch with
              | "x86_64" -> Architechture.X86_64
              | "aarch64" -> Architechture.Aarch64
              | "arm" -> Architechture.Arm
              | "arm64" -> Architechture.Arm64
              | "armv7l" -> Architechture.Armv7l

            Stdlib.Result.Result.Ok(Host { os = os; arch = arch })
          | _, _ -> Stdlib.Result.Result.Error(arch.stderr ++ os.stderr)