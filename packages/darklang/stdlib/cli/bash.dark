module Darklang =
  module Stdlib =
    module Cli =
      module Bash =
        /// Read the content of .bashrc file
        let readBashrc () : Result.Result<String, String> =
          (Builtin.fileRead "$HOME/.bashrc")
          |> Result.map (fun content -> String.fromBytesWithReplacement content)

        /// Apply changes to .bashrc
        let applyBashConfigChanges () : Result.Result<Unit, String> =
          Cli.executeWithUnitOrStdErr "source $HOME/.bashrc"


        /// Write content to .bashrc file
        let overwriteBashrc (content: String) : Result.Result<Unit, String> =
          (Builtin.fileWrite (String.toBytes content) "$HOME/.bashrc")
          |> Result.map (fun _ -> ())


        /// Delete an alias from .bashrc
        let deleteAlias (alias: String) : Result.Result<Unit, String> =
          (readBashrc ())
          |> Result.andThen (fun content ->
            let updatedContent =
              content
              |> String.split "\n"
              |> List.filter (fun line ->
                Bool.not (String.contains line $"alias {alias}="))
              |> String.join "\n"

            overwriteBashrc updatedContent)


        /// Add an alias to .bashrc
        let addAlias
          (alias: String)
          (command: String)
          : Result.Result<Unit, String> =
          let aliasDefinition = $"alias {alias}='{command}'"

          match readBashrc () with
          | Ok content ->
            let updatedContent = content ++ "\n" ++ aliasDefinition
            overwriteBashrc updatedContent // TODO: match on this

            // CLEANUP: in bash `source ~/.bashrc` doesn't work from a subprocess, This is why we need to print a message to the user to run the command manually
            // one workaround is adding `[[ -f ~/.bashrc ]] && . ~/.bashrc` which makes sure .bashrc exists and sources it, applying it configuration to the current shell session.
            Builtin.printLine
              "Changes have been made to your .bashrc file. \nTo apply these changes to your current terminal session, please run the following command:\nsource ~/.bashrc\n\n "

            applyBashConfigChanges ()
          | Error e -> Result.Result.Error e


        /// Add a path to PATH
        ///
        /// If already in PATH, or if already in .bashrc, ignore and return Ok
        let addToPath (path: String) : Result.Result<String, String> =
          let isExecutableInPath =
            // TODO: this seems like a bad check
            Cli.execute $"echo $PATH | grep -q {path}"

          if isExecutableInPath.exitCode == 0L then
            Result.Result.Ok()
          else
            match readBashrc () with
            | Ok content ->
              if String.contains content path then
                Result.Result.Ok()
              else
                let updatedContent = content ++ "\nexport PATH=$PATH:" ++ path
                writeToBashrc updatedContent

                applyBashConfigChanges ()
            | Error e -> Result.Result.Error e


        /// Remove a path from PATH
        /// If the path is not found in PATH, ignores and returns OK
        let removeFromPath (path: String) : Result.Result<Unit, String> =
          match readBashrc () with
          | Ok content ->
            let exportPattern = "\nexport PATH=$PATH:" ++ path

            if String.contains content exportPattern then
              let updatedContent = String.replaceAll content exportPattern ""
              writeToBashrc updatedContent

              applyBashConfigChanges ()
            else
              Result.Result.Ok()
          | Error e -> Result.Result.Error e