(*
  export interface SemanticTokens {
    /// An optional result id. If provided and clients support delta updating
    /// the client will include the result id in the next semantic token request.
    /// A server can then instead of computing all semantic tokens again simply
    /// send a delta.
    resultId?: string;

    /// The actual tokens.
    data: uinteger[];
  }

  //------- 'textDocument/semanticTokens/full' -----

  export interface SemanticTokensParams
    extends
      WorkDoneProgressParams,
      PartialResultParams {

    /// The text document.
    textDocument: TextDocumentIdentifier;
  }

  export namespace SemanticTokensRequest {
    export const method: 'textDocument/semanticTokens/full' = 'textDocument/semanticTokens/full';
    export const messageDirection: MessageDirection = MessageDirection.clientToServer;
    export const type = new ProtocolRequestType<SemanticTokensParams, SemanticTokens | null, SemanticTokensPartialResult, void, SemanticTokensRegistrationOptions>(method);
    export const registrationMethod: typeof SemanticTokensRegistrationType.method  = SemanticTokensRegistrationType.method;
    export type HandlerSignature = RequestHandler<SemanticTokensDeltaParams, SemanticTokens | null, void>;
  }
*)




(*
  /// A set of predefined token types. This set is not fixed and clients can specify
  /// additional token types via the corresponding client capabilities.
  export enum SemanticTokenTypes {
    namespace = 'namespace',
    /// Represents a generic type. Acts as a fallback for types which can't be mapped to
    /// a specific type like class or enum.
    type = 'type',
    class = 'class',
    enum = 'enum',
    interface = 'interface',
    struct = 'struct',
    typeParameter = 'typeParameter',
    parameter = 'parameter',
    variable = 'variable',
    property = 'property',
    enumMember = 'enumMember',
    event = 'event',
    function = 'function',
    method = 'method',
    macro = 'macro',
    keyword = 'keyword',
    modifier = 'modifier',
    comment = 'comment',
    string = 'string',
    number = 'number',
    regexp = 'regexp',
    operator = 'operator',
    decorator = 'decorator'
  }

  /// A set of predefined token modifiers. This set is not fixed
  /// an clients can specify additional token types via the
  /// corresponding client capabilities.
  export enum SemanticTokenModifiers {
    declaration = 'declaration',
    definition = 'definition',
    readonly = 'readonly',
    static = 'static',
    deprecated = 'deprecated',
    abstract = 'abstract',
    async = 'async',
    modification = 'modification',
    documentation = 'documentation',
    defaultLibrary = 'defaultLibrary'
  }

  export interface SemanticTokensLegend {
    /// The token types a server uses.
    tokenTypes: string[];

    /// The token modifiers a server uses.
    tokenModifiers: string[];
  }



  export interface SemanticTokensEdit {
    /// The start offset of the edit.
    start: uinteger;

    /// The count of elements to remove.
    deleteCount: uinteger;

    /// The elements to insert.
    data?: uinteger[];
  }

  export interface SemanticTokensDelta {
    readonly resultId?: string;
    /// The semantic token edits to transform a previous result into a new result.
    edits: SemanticTokensEdit[];
  }



  export interface SemanticTokensPartialResult {
    data: uinteger[];
  }

  export interface SemanticTokensDeltaPartialResult {
    edits: SemanticTokensEdit[];
  }



  //------- 'textDocument/semanticTokens' -----

  export namespace TokenFormat {
    export const Relative: 'relative' = 'relative';
  }

  export type TokenFormat = 'relative';


  /// @proposed
  export interface ClientSemanticTokensRequestFullDelta {
    /// The client will send the `textDocument/semanticTokens/full/delta` request if
    /// the server provides a corresponding handler.
    delta?: boolean;
  }

  /// @proposed
  export interface ClientSemanticTokensRequestOptions  {
    /// The client will send the `textDocument/semanticTokens/range` request if
    /// the server provides a corresponding handler.
    range?: boolean | {};

    /// The client will send the `textDocument/semanticTokens/full` request if
    /// the server provides a corresponding handler.
    full?: boolean | ClientSemanticTokensRequestFullDelta;
  }

  export interface SemanticTokensClientCapabilities {
    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    dynamicRegistration?: boolean;

    /// Which requests the client supports and might send to the server
    /// depending on the server's capability. Please note that clients might not
    /// show semantic tokens or degrade some of the user experience if a range
    /// or full request is advertised by the client but not provided by the
    /// server. If for example the client capability `requests.full` and
    /// `request.range` are both set to true but the server only provides a
    /// range provider the client might not render a minimap correctly or might
    /// even decide to not show any semantic tokens at all.
    requests: ClientSemanticTokensRequestOptions;

    /// The token types that the client supports.
    tokenTypes: string[];

    /// The token modifiers that the client supports.
    tokenModifiers: string[];

    /// The token formats the clients supports.
    formats: TokenFormat[];

    /// Whether the client supports tokens that can overlap each other.
    overlappingTokenSupport?: boolean;

    /// Whether the client supports tokens that can span multiple lines.
    multilineTokenSupport?: boolean;

    /// Whether the client allows the server to actively cancel a
    /// semantic token request, e.g. supports returning
    /// LSPErrorCodes.ServerCancelled. If a server does the client
    /// needs to retrigger the request.
    serverCancelSupport?: boolean;

    /// Whether the client uses semantic tokens to augment existing
    /// syntax tokens. If set to `true` client side created syntax
    /// tokens and semantic tokens are both used for colorization. If
    /// set to `false` the client only uses the returned semantic tokens
    /// for colorization.
    ///
    /// If the value is `undefined` then the client behavior is not
    /// specified.
    augmentsSyntaxTokens?: boolean;
  }


  /// Semantic tokens options to support deltas for full documents
  ///
  /// @proposed
  export interface SemanticTokensFullDelta {
    /// The server supports deltas for full documents.
    delta?: boolean;
  }

  export interface SemanticTokensOptions
    extends
      WorkDoneProgressOptions {

    /// The legend used by the server
    legend: SemanticTokensLegend;

    /// Server supports providing semantic tokens for a specific range
    /// of a document.
    range?: boolean | {};

    /// Server supports providing semantic tokens for a full document.
    full?: boolean | SemanticTokensFullDelta;
  }

  export interface SemanticTokensRegistrationOptions
    extends
      TextDocumentRegistrationOptions,
      SemanticTokensOptions,
      StaticRegistrationOptions {
  }

  export namespace SemanticTokensRegistrationType {
    export const method: 'textDocument/semanticTokens' = 'textDocument/semanticTokens';
    export const type = new RegistrationType<SemanticTokensRegistrationOptions>(method);
  }





  //------- 'textDocument/semanticTokens/edits' -----

  export interface SemanticTokensDeltaParams
    extends
      WorkDoneProgressParams,
      PartialResultParams {

    /// The text document.
    textDocument: TextDocumentIdentifier;

    /// The result id of a previous response. The result Id can either point to a full response
    /// or a delta response depending on what was received last.
    previousResultId: string;
  }

  export namespace SemanticTokensDeltaRequest {
    export const method: 'textDocument/semanticTokens/full/delta' = 'textDocument/semanticTokens/full/delta';
    export const messageDirection: MessageDirection = MessageDirection.clientToServer;
    export const type = new ProtocolRequestType<SemanticTokensDeltaParams, SemanticTokens | SemanticTokensDelta | null, SemanticTokensPartialResult | SemanticTokensDeltaPartialResult, void, SemanticTokensRegistrationOptions>(method);
    export const registrationMethod: typeof SemanticTokensRegistrationType.method  = SemanticTokensRegistrationType.method;
    export type HandlerSignature = RequestHandler<SemanticTokensDeltaParams, SemanticTokens | SemanticTokensDelta | null, void>;
  }



  //------- 'textDocument/semanticTokens/range' -----

  export interface SemanticTokensRangeParams
    extends
      WorkDoneProgressParams,
      PartialResultParams {

    /// The text document.
    textDocument: TextDocumentIdentifier;

    /// The range the semantic tokens are requested for.
    range: Range;
  }

  export namespace SemanticTokensRangeRequest {
    export const method: 'textDocument/semanticTokens/range' = 'textDocument/semanticTokens/range';
    export const messageDirection: MessageDirection = MessageDirection.clientToServer;
    export const type = new ProtocolRequestType<SemanticTokensRangeParams, SemanticTokens | null, SemanticTokensPartialResult, void, void>(method);
    export const registrationMethod: typeof SemanticTokensRegistrationType.method  = SemanticTokensRegistrationType.method;
    export type HandlerSignature = RequestHandler<SemanticTokensRangeParams, SemanticTokens | null, void>;
  }



  //------- 'workspace/semanticTokens/refresh' -----

  export interface SemanticTokensWorkspaceClientCapabilities {
    /// Whether the client implementation supports a refresh request sent from
    /// the server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// semantic tokens currently shown. It should be used with absolute care
    /// and is useful for situation where a server for example detects a project
    /// wide change that requires such a calculation.
    refreshSupport?: boolean;
  }

  export namespace SemanticTokensRefreshRequest {
    export const method: `workspace/semanticTokens/refresh` = `workspace/semanticTokens/refresh`;
    export const messageDirection: MessageDirection = MessageDirection.serverToClient;
    export const type = new ProtocolRequestType0<void, void, void, void>(method);
    export type HandlerSignature = RequestHandler0<void, void>;
  }
*)