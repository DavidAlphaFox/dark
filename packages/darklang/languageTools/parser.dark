module Darklang =
  module LanguageTools =
    /// Maps `TreeSitter.ParsedNode`s to structures defined in `WrittenTypes`
    module Parser =
      // TODO: these should be UInts of some size
      // (UInt8 might even be enough - how many lines are over 255chars?)
      type Point = { row: Int64; column: Int64 }

      type Range = { start: Point; end_: Point }

      type ParsedNode =
        {
          // e.g., a node of `typ` `let_expression` has a child node with a `body` field name
          fieldName: Stdlib.Option.Option<String>

          /// e.g. `source_file`, `fn_decl`, `expression`, `let_expression`
          typ: String

          /// The text of this node as it was in the unparsed source code
          text: String

          /// Where in the source code is this node written/contained
          /// i.e. Line 1, Column 2 to Line 1, Column 5
          sourceRange: Range

          children: List<ParsedNode>
        }


      let parseToSimplifiedTree (text: String) : ParsedNode =
        Builtin.parserParseToSimplifiedTree text

      let parseName (fnName: String) : Darklang.Stdlib.Result.Result<String> =
        if (Darklang.Stdlib.String.contains fnName "_v") then
          // Todo : check if the name is valid
          Darklang.Stdlib.Result.Result.Ok fnName
        else
          Darklang.Stdlib.Result.Result.Ok(fnName ++ "_v0")

      // // TODO: maybe re-frame this into expected/actual or something
      // type ParseError =
      //   { sourceRange: Range
      //     sourceText: String
      //     message: String }


      // --------------------
      // Helper functions
      // --------------------

      let getText (node: ParsedNode) : String = node.text
      let getRange (node: ParsedNode) : Range = node.sourceRange

      let findNodeByFieldName
        (node: ParsedNode)
        (fieldName: String)
        : Stdlib.Option.Option<ParsedNode> =
        let filteredChildren =
          node.children
          |> Stdlib.List.filter (fun c ->
            match c.fieldName with
            | Some fName -> fName == fieldName
            | None -> false)

        match filteredChildren with
        | [ c ] -> Stdlib.Option.Option.Some c
        | [] -> Stdlib.Option.Option.None
        | _ -> Stdlib.Option.Option.None // TODO: this should error, there are multiple matches




      // --------------------
      // Parsing to WrittenTypes
      // --------------------

      module Identifiers =
        let extractModuleIdentifiersHelper
          (modulesSoFarInReverse:
            List<WrittenTypes.ModuleIdentifier * WrittenTypes.SourceRange>)
          (nodes: List<ParsedNode>)
          : (List<WrittenTypes.ModuleIdentifier * WrittenTypes.SourceRange> *
            ParsedNode)
          =
          match nodes with
          | modulePart :: symbolPart :: otherParts ->
            if modulePart.typ != "module_identifier" then
              $"Unexpected - modulePart should be a module_identifier but is {modulePart.typ}"
            elif symbolPart.typ != "symbol" then
              $"Unexpected - symbolPart should be a symbol but is {symbolPart.typ}"
            else
              let moduleIdentifier =
                WrittenTypes.ModuleIdentifier
                  { range = modulePart.sourceRange
                    name = modulePart.text }

              let updatedModules =
                Stdlib.List.push
                  modulesSoFarInReverse
                  ((moduleIdentifier, symbolPart.sourceRange))

              extractModuleIdentifiersHelper updatedModules otherParts

          | [ lastPart ] -> (modulesSoFarInReverse, lastPart)

          | [] ->
            "Unexpected - there should be an odd number of parts to a qualified name"

        /// Parses a qualified name (either type, or function, or (future) something else)
        ///
        /// These names come in the form of `module1.module2.module3.name`,
        /// and we need to parse out the `module1.module2.module3.` part,
        /// ensuring that we take note of the `.` source ranges after each module name
        let extractModuleIdentifiers
          (nodes: List<ParsedNode>)
          : (List<WrittenTypes.ModuleIdentifier * WrittenTypes.SourceRange> *
            ParsedNode)
          =
          let (modulesInReverse, lastNode) = extractModuleIdentifiersHelper [] nodes
          (Stdlib.List.reverse modulesInReverse, lastNode)

        let parseVariable (n: ParsedNode) : WrittenTypes.VariableIdentifier =
          WrittenTypes.VariableIdentifier { range = n.sourceRange; name = n.text }

        let parseType (n: ParsedNode) : WrittenTypes.TypeIdentifier =
          WrittenTypes.TypeIdentifier { range = n.sourceRange; name = n.text }

        let parseFn (n: ParsedNode) : WrittenTypes.FnIdentifier =
          WrittenTypes.FnIdentifier { range = n.sourceRange; name = n.text }


        let parseQualifiedType
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.QualifiedTypeIdentifier, String> =
          if node.typ == "qualified_type_name" then
            let (modules, typeIdentifierNode) =
              extractModuleIdentifiers node.children

            (WrittenTypes.QualifiedTypeIdentifier
              { range = node.sourceRange
                modules = modules
                typ = parseType typeIdentifierNode })
            |> Stdlib.Result.Result.Ok
          else
            Stdlib.Result.Result.Error
              $"Can't parse qualified_type_name from {node.typ}"


        let parseQualifiedFunction
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.QualifiedFnIdentifier, String> =
          if node.typ == "qualified_fn_name" then
            let (modules, fnIdentifierNode) = extractModuleIdentifiers node.children

            (WrittenTypes.QualifiedFnIdentifier
              { range = node.sourceRange
                modules = modules
                fn = parseFn fnIdentifierNode })
            |> Stdlib.Result.Result.Ok
          else
            Stdlib.Result.Result.Error
              $"Can't parse qualified_fn_name from {node.typ}"



      module TypeReference =
        let parseBuiltIn
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeReference.Builtin, WrittenTypes.Unparseable> =
          if node.typ == "builtin_type" then
            match node.text with
            | "Unit" ->
              (WrittenTypes.TypeReference.Builtin.TUnit node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Bool" ->
              (WrittenTypes.TypeReference.Builtin.TBool node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int8" ->
              (WrittenTypes.TypeReference.Builtin.TInt8 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt8" ->
              (WrittenTypes.TypeReference.Builtin.TUInt8 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int16" ->
              (WrittenTypes.TypeReference.Builtin.TInt16 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt16" ->
              (WrittenTypes.TypeReference.Builtin.TUInt16 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int32" ->
              (WrittenTypes.TypeReference.Builtin.TInt32 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt32" ->
              (WrittenTypes.TypeReference.Builtin.TUInt32 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int64" ->
              (WrittenTypes.TypeReference.Builtin.TInt64 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt64" ->
              (WrittenTypes.TypeReference.Builtin.TUInt64 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int128" ->
              (WrittenTypes.TypeReference.Builtin.TInt128 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt128" ->
              (WrittenTypes.TypeReference.Builtin.TUInt128 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Float" ->
              (WrittenTypes.TypeReference.Builtin.TFloat node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Char" ->
              (WrittenTypes.TypeReference.Builtin.TChar node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "String" ->
              (WrittenTypes.TypeReference.Builtin.TString node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            Stdlib.Result.Result.Error(WrittenTypes.Unparseable { source = node })



        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeReference.TypeReference, WrittenTypes.Unparseable> =
          if node.typ == "type_reference" then
            match node.children with
            | [ single ] ->
              if single.typ == "builtin_type" then
                match (parseBuiltIn single) with
                | Ok builtin ->
                  (WrittenTypes.TypeReference.TypeReference.Builtin builtin)
                  |> Stdlib.Result.Result.Ok
                | Error _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              elif single.typ == "qualified_type_name" then
                match (Identifiers.parseQualifiedType single) with
                | Ok qualifiedType ->
                  (WrittenTypes.TypeReference.TypeReference.QualifiedName
                    qualifiedType)
                  |> Stdlib.Result.Result.Ok

                | Error _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              else
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

            | _ -> Stdlib.Result.Result.Error "Not a single child"

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


      module TypeDeclaration =
        let parseDefinition
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeDeclaration.Definition, WrittenTypes.Unparseable> =
          if node.typ == "type_reference" then
            match (TypeReference.parse node) with
            | Ok typeRef ->
              (WrittenTypes.TypeDeclaration.Definition.Alias typeRef)
              |> Stdlib.Result.Result.Ok

            | Error _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error

        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeDeclaration.TypeDeclaration, WrittenTypes.Unparseable> =
          if node.typ == "type_decl" then

            let nameNode =
              match (findNodeByFieldName node "name") with
              | Some nameNode ->
                (Identifiers.parseType nameNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No name node found in type_decl"

            let defNode =
              match (findNodeByFieldName node "typ") with
              | Some defNode -> (parseDefinition defNode)
              | None ->
                Stdlib.Result.Result.Error "No definition node found in type_decl"

            let keywordTypeNode =
              match (findNodeByFieldName node "keyword_type") with
              | Some keywordTypeNode ->
                (getRange keywordTypeNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error "No keyword_type node found in type_decl"

            let symbolEqualsNode =
              match (findNodeByFieldName node "symbol_equals") with
              | Some symbolEqualsNode ->
                (getRange symbolEqualsNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error "No symbol_equals node found in type_decl"

            match nameNode, defNode, keywordTypeNode, symbolEqualsNode with
            | Ok name, Ok def, Ok keywordTypeNode, Ok symbolEqualsNode ->
              (WrittenTypes.TypeDeclaration.TypeDeclaration
                { range = node.sourceRange
                  name = name
                  definition = def
                  keywordType = keywordTypeNode
                  symbolEquals = symbolEqualsNode })
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


      module Expr =
        let parseBoolLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "bool_literal" then
            let b =
              // TODO: error-handling
              match getText node with
              | "true" -> true |> Stdlib.Result.Result.Ok
              | "false" -> false |> Stdlib.Result.Result.Ok
              | _ ->
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

            match b with
            | Ok b ->
              (WrittenTypes.Expr.EBool(node.sourceRange, b))
              |> Stdlib.Result.Result.Ok
            | Error _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseIntLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let supportedInts =
            [ "int8_literal"
              "uint8_literal"
              "int16_literal"
              "uint16_literal"
              "int32_literal"
              "uint32_literal"
              "int64_literal"
              "uint64_literal"
              "int128_literal"
              "uint128_literal" ]

          if Stdlib.List.member_v0 supportedInts node.typ then
            let intPart =
              (findNodeByFieldName node "digits")
              |> Stdlib.Option.toResult "No digits node found in int_literal"

            let suffixPart =
              (findNodeByFieldName node "suffix")
              |> Stdlib.Option.toResult "No suffix node found in int_literal"

            match intPart, suffixPart with
            | Ok intPart, Ok suffixPart ->
              let intText = getText intPart

              let parsedResult =
                match node.typ with
                | "int8_literal" ->
                  (Stdlib.Int8.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt8(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint8_literal" ->
                  (Stdlib.UInt8.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt8(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int16_literal" ->
                  (Stdlib.Int16.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt16(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint16_literal" ->
                  (Stdlib.UInt16.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt16(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int32_literal" ->
                  (Stdlib.Int32.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt32(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint32_literal" ->
                  (Stdlib.UInt32.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt32(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int64_literal" ->
                  (Stdlib.Int64.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt64(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint64_literal" ->
                  (Stdlib.UInt64.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt64(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int128_literal" ->
                  (Stdlib.Int128.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt128(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint128_literal" ->
                  (Stdlib.UInt128.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt128(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              match parsedResult with
              | Ok expr -> Stdlib.Result.Result.Ok expr
              | Error _ ->
                Stdlib.Result.Result.Error(
                  WrittenTypes.Unparseable { source = node }
                )
              | _ ->
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error

        let parseFloatLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "float_literal" then
            let floatStr = getText node

            match Stdlib.Float.parse floatStr with
            | Ok floatValue ->
              let (sign, whole, remainder) =
                let (sign, unsignedFloat) =
                  if Stdlib.String.startsWith floatStr "-" then
                    (Darklang.LanguageTools.Sign.Negative,
                     Stdlib.String.dropFirst floatStr 1L)
                  else
                    (Darklang.LanguageTools.Sign.Positive, floatStr)

                let parts = Stdlib.String.split unsignedFloat "."

                let whole =
                  parts |> Stdlib.List.head |> Stdlib.Option.withDefault "0"

                let remainder =
                  parts
                  |> Stdlib.List.tail
                  |> Stdlib.Option.withDefault [ "0" ]
                  |> Stdlib.List.head
                  |> Stdlib.Option.withDefault "0"

                (sign, whole, remainder)


              (WrittenTypes.Expr.EFloat(node.sourceRange, sign, whole, remainder))
              |> Stdlib.Result.Result.Ok

            | Error _ ->
              Stdlib.Result.Result.Error(WrittenTypes.Unparseable { source = node })

          else
            Stdlib.Result.Result.Error(WrittenTypes.Unparseable { source = node })


        let parseStringLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "string_literal" then
            let openQuoteNode =
              (findNodeByFieldName node "symbol_open_quote")
              |> Stdlib.Option.toResult
                "No symbol_open_quote node found in string_literal"

            let contents =
              match findNodeByFieldName node "content" with
              | Some contentPart ->
                Stdlib.Option.Option.Some(
                  (contentPart.sourceRange, contentPart.text)
                )
              | None -> Stdlib.Option.Option.None

            let closeQuoteNode =
              (findNodeByFieldName node "symbol_close_quote")
              |> Stdlib.Option.toResult
                "No symbol_close_quote node found in string_literal"

            match openQuoteNode, closeQuoteNode with
            | Ok openQuoteNode, Ok closeQuoteNode ->
              (WrittenTypes.Expr.EString(
                node.sourceRange,
                contents,
                openQuoteNode.sourceRange,
                closeQuoteNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseLetExpr
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "let_expression" then
            let keywordLetNode =
              (findNodeByFieldName node "keyword_let")
              |> Stdlib.Option.toResult "No keyword_let node found in let_expression"

            let identifierNode =
              (findNodeByFieldName node "identifier")
              |> Stdlib.Option.toResult "No identifier node found in let_expression"

            let symbolEqualsNode =
              (findNodeByFieldName node "symbol_equals")
              |> Stdlib.Option.toResult
                "No symbol_equals node found in let_expression"

            let expr =
              match (findNodeByFieldName node "expr") with
              | Some exprNode -> (Expr.parse exprNode)
              | None ->
                Stdlib.Result.Result.Error "No expr node found in let_expression"

            let body =
              match (findNodeByFieldName node "body") with
              | Some bodyNode -> (Expr.parse bodyNode)
              | None ->
                Stdlib.Result.Result.Error "No body node found in let_expression"

            match keywordLetNode, identifierNode, symbolEqualsNode, expr, body with
            | Ok keywordLetNode,
              Ok identifierNode,
              Ok symbolEqualsNode,
              Ok expr,
              Ok body ->
              (WrittenTypes.Expr.ELet(
                node.sourceRange,
                WrittenTypes.LetPattern.LPVariable(
                  identifierNode.sourceRange,
                  identifierNode.text
                ),
                expr,
                body,
                keywordLetNode.sourceRange,
                symbolEqualsNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseInfixOperation
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "infix_operation" then
            let leftArg =
              match (findNodeByFieldName node "left") with
              | Some leftArgNode -> (Expr.parse leftArgNode)
              | None ->
                Stdlib.Result.Result.Error "No left node found in infix_operation"

            let operatorNode =
              (findNodeByFieldName node "operator")
              |> Stdlib.Option.toResult "No operator node found in infix_operation"

            let operator =
              // TODO revisit error-handling here
              match operatorNode with
              | Ok operatorNode ->
                match getText operatorNode with
                | "+" -> WrittenTypes.InfixOperator.ArithmeticPlus
                | "-" -> WrittenTypes.InfixOperator.ArithmeticMinus
                | _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

            let rightArg =
              match (findNodeByFieldName node "right") with
              | Some rightArgNode -> (Expr.parse rightArgNode)
              | None ->
                Stdlib.Result.Result.Error "No right node found in infix_operation"

            match leftArg, operatorNode, rightArg with
            | Ok leftArg, Ok operatorNode, Ok rightArg ->
              (WrittenTypes.Expr.EInfix(
                node.sourceRange,
                ((operatorNode.sourceRange, operator)),
                leftArg,
                rightArg
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error


        let parseFunctionCall
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "function_call" then

            let fnNameNode =
              match (findNodeByFieldName node "fn") with
              | Some fnNameNode -> (Identifiers.parseQualifiedFunction fnNameNode)
              | None ->
                Stdlib.Result.Result.Error "No fn node found in function_call"

            let args =
              node.children
              |> Stdlib.List.filter (fun c ->
                match c.fieldName with
                | Some fName -> fName == "args"
                | None -> false)
              |> Stdlib.List.map Expr.parse
              |> Stdlib.List.map (fun expr ->
                match expr with
                | Ok exp -> exp
                | Error _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error)

            let symbolLeftParen =
              (findNodeByFieldName node "symbol_left_paren")
              |> Stdlib.Option.toResult
                "No symbol_left_paren node found in function_call"

            let symbolRightParen =
              (findNodeByFieldName node "symbol_right_paren")
              |> Stdlib.Option.toResult
                "No symbol_right_paren node found in function_call"

            match fnNameNode, args, symbolLeftParen, symbolRightParen with
            | Ok fnName, args, Ok symbolLeftParen, Ok symbolRightParen ->
              (WrittenTypes.Expr.EFnCall(
                node.sourceRange,
                fnName,
                args,
                symbolLeftParen.sourceRange,
                symbolRightParen.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        /// this parses one of the Expr cases
        let parseCase
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =

          match node.typ with
          // simple
          | "paren_expression" ->
            match (findNodeByFieldName node "expr") with
            | Some exprNode -> (Expr.parse exprNode)
            | None -> (WrittenTypes.Unparseable { source = node })

          | "unit" ->
            (WrittenTypes.Expr.EUnit node.sourceRange) |> Stdlib.Result.Result.Ok
          | "bool_literal" -> parseBoolLiteral node
          | "int8_literal" -> parseIntLiteral node
          | "uint8_literal" -> parseIntLiteral node
          | "int16_literal" -> parseIntLiteral node
          | "uint16_literal" -> parseIntLiteral node
          | "int32_literal" -> parseIntLiteral node
          | "uint32_literal" -> parseIntLiteral node
          | "int64_literal" -> parseIntLiteral node
          | "uint64_literal" -> parseIntLiteral node
          | "int128_literal" -> parseIntLiteral node
          | "uint128_literal" -> parseIntLiteral node
          | "float_literal" -> parseFloatLiteral node
          | "string_literal" -> parseStringLiteral node

          // assigning and accessing variables
          | "let_expression" -> parseLetExpr node
          | "variable_identifier" ->
            (WrittenTypes.Expr.EVariable(node.sourceRange, getText node))
            |> Stdlib.Result.Result.Ok

          // fn calls
          | "infix_operation" -> parseInfixOperation node
          | "function_call" -> parseFunctionCall node

          | _ ->
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        /// this parses the 'container' of an expression
        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "expression" then
            match node.children with
            | [ single ] -> parseCase single
            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error
          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


      module FunctionDeclaration =
        /// Parses a package function declaration parameter
        ///
        /// i.e. in `let foo (x: Int): ...`, this parses `(x: Int)`
        let parseFnDeclParam
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.FnDeclaration.Parameter, WrittenTypes.Unparseable> =
          if node.typ == "unit" then
            (WrittenTypes.FnDeclaration.UnitParameter { range = node.sourceRange })
            |> WrittenTypes.FnDeclaration.Parameter.Unit
            |> Stdlib.Result.Result.Ok

          elif node.typ == "fn_decl_param" then
            let nameNode =
              match (findNodeByFieldName node "identifier") with
              | Some nameNode ->
                (Identifiers.parseVariable nameNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No identifier node found in fn_decl_param"

            let typNode =
              match (findNodeByFieldName node "typ") with
              | Some typNode -> (TypeReference.parse typNode)
              | None ->
                Stdlib.Result.Result.Error "No typ node found in fn_decl_param"

            let symbolLeftParenNode =
              match (findNodeByFieldName node "symbol_left_paren") with
              | Some symbolLeftParenNode ->
                (getRange symbolLeftParenNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No symbol_left_paren node found in fn_decl_param"

            let symbolColonNode =
              match (findNodeByFieldName node "symbol_colon") with
              | Some symbolColonNode ->
                (getRange symbolColonNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No symbol_colon node found in fn_decl_param"

            let symbolRightParenNode =
              match (findNodeByFieldName node "symbol_right_paren") with
              | Some symbolRightParenNode ->
                (getRange symbolRightParenNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No symbol_right_paren node found in fn_decl_param"

            match
              nameNode,
              typNode,
              symbolLeftParenNode,
              symbolColonNode,
              symbolRightParenNode
            with
            | Ok name,
              Ok typ,
              Ok symbolLeftParen,
              Ok symbolColon,
              Ok symbolRightParen ->
              (WrittenTypes.FnDeclaration.NormalParameter
                { range = node.sourceRange
                  name = name
                  typ = typ
                  symbolLeftParen = symbolLeftParen
                  symbolColon = symbolColon
                  symbolRightParen = symbolRightParen })
              |> WrittenTypes.FnDeclaration.Parameter.Normal
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error

        /// Parses a package function definition's parameters
        let parseParams
          (node: ParsedNode)
          : Stdlib.Result.Result<List<WrittenTypes.FnDeclaration.Parameter>, WrittenTypes.Unparseable> =
          if node.typ == "fn_decl_params" then
            let defs =
              Stdlib.List.fold
                node.children
                (Stdlib.Result.Result.Ok [])
                (fun defs param ->
                  match defs, parseFnDeclParam param with
                  | Ok defs, Ok fnDeclParam ->
                    (Stdlib.List.push defs fnDeclParam) |> Stdlib.Result.Result.Ok

                  | _ ->
                    (WrittenTypes.Unparseable { source = node })
                    |> Stdlib.Result.Result.Error)

            match defs with
            | Error _e -> defs
            | Ok defs -> (Stdlib.List.reverse defs) |> Stdlib.Result.Result.Ok
          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        /// Parses a package function declaration
        ///
        /// i.e. `let add (x: Int64) (y: Int64): Int64 = x + y`,
        ///
        /// - `add` is the function name
        /// - `x: Int` and `y: Int` are the parameters
        /// - `Int` is the return type
        /// - `x + y` is the body
        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.FnDeclaration.FnDeclaration, WrittenTypes.Unparseable> =
          if node.typ == "fn_decl" then
            let nameNode =
              match (findNodeByFieldName node "name") with
              | Some nameNode ->
                (Identifiers.parseFn nameNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No name node found in fn_decl"

            let paramsNode =
              match (findNodeByFieldName node "params") with
              | Some paramsNode -> (parseParams paramsNode)
              | None -> Stdlib.Result.Result.Error "No params node found in fn_decl"

            let returnTypeNode =
              match (findNodeByFieldName node "return_type") with
              | Some returnTypeNode -> (TypeReference.parse returnTypeNode)
              | None -> Stdlib.Result.Result.Error "No return_type node"

            let bodyNode =
              match (findNodeByFieldName node "body") with
              | Some bodyNode -> (Expr.parse bodyNode)
              | None -> Stdlib.Result.Result.Error "No body node found in fn_decl"

            let keywordLetNode =
              match (findNodeByFieldName node "keyword_let") with
              | Some keywordLetNode ->
                (getRange keywordLetNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No keyword_let node found"

            let symbolColonNode =
              match (findNodeByFieldName node "symbol_colon") with
              | Some symbolColonNode ->
                (getRange symbolColonNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No symbol_colon node found"

            let symbolEqualsNode =
              match (findNodeByFieldName node "symbol_equals") with
              | Some symbolEqualsNode ->
                (getRange symbolEqualsNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No symbol_equals node found"

            match
              nameNode,
              paramsNode,
              returnTypeNode,
              bodyNode,
              keywordLetNode,
              symbolColonNode,
              symbolEqualsNode
            with
            | Ok name,
              Ok params,
              Ok returnType,
              Ok body,
              Ok keywordLetNode,
              Ok symbolColonNode,
              Ok symbolEqualsNode ->
              (WrittenTypes.FnDeclaration.FnDeclaration
                { range = node.sourceRange
                  name = name
                  parameters = params
                  returnType = returnType
                  body = body
                  keywordLet = keywordLetNode
                  symbolColon = symbolColonNode
                  symbolEquals = symbolEqualsNode })
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error


      /// Map a ParsedNode to a WrittenTypes.ParsedFile
      ///
      /// This is the entrypoint for mapping a ParsedNode to WrittenTypes
      let parseCliScript
        (node: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.ParsedFile, String> =
        if node.typ == "source_file" then
          let init =
            WrittenTypes.CliScript
              { range = node.sourceRange
                typesAndFns = []
                unparseableStuff = []
                exprsToEval = [] }

          let result =
            node.children
            |> Stdlib.List.fold (Stdlib.Result.Result.Ok init) (fun result decl ->
              match result with
              | Error e -> Stdlib.Result.Result.Error e

              | Ok result ->
                match decl.typ with

                | "type_decl" ->
                  match TypeDeclaration.parse decl with
                  | Error e ->
                    { result with
                        unparseableStuff =
                          Stdlib.List.pushBack result.unparseableStuff e }
                    |> Stdlib.Result.Result.Ok

                  | Ok parsedTypeDef ->
                    let newType = WrittenTypes.CliScriptTypeOrFn.Type parsedTypeDef

                    { result with
                        typesAndFns =
                          Stdlib.List.pushBack result.typesAndFns newType }
                    |> Stdlib.Result.Result.Ok

                | "fn_decl" ->
                  match FunctionDeclaration.parse decl with
                  | Error e ->
                    { result with
                        unparseableStuff =
                          Stdlib.List.pushBack result.unparseableStuff e }
                    |> Stdlib.Result.Result.Ok

                  | Ok parsedFnDecl ->
                    let newFn = WrittenTypes.CliScriptTypeOrFn.Function parsedFnDecl

                    { result with
                        typesAndFns = Stdlib.List.pushBack result.typesAndFns newFn }
                    |> Stdlib.Result.Result.Ok

                | "expression" ->
                  match Expr.parse decl with
                  | Error e ->
                    { result with
                        unparseableStuff =
                          Stdlib.List.pushBack result.unparseableStuff e }
                    |> Stdlib.Result.Result.Ok
                  | Ok parsedExpr ->
                    { result with
                        exprsToEval =
                          Stdlib.List.pushBack result.exprsToEval parsedExpr }
                    |> Stdlib.Result.Result.Ok

                | _ ->
                  { result with
                      unparseableStuff =
                        Stdlib.List.pushBack
                          result.unparseableStuff
                          (WrittenTypes.Unparseable { source = decl }) }
                  |> Stdlib.Result.Result.Ok)

          match result with
          | Error e -> Stdlib.Result.Result.Error e
          | Ok result ->
            (WrittenTypes.ParsedFile.CliScript result) |> Stdlib.Result.Result.Ok

        else
          Stdlib.Result.Result.Error $"Not a source_file: {node.typ}"