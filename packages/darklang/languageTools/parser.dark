module Darklang =
  module LanguageTools =
    /// Maps `TreeSitter.ParsedNode`s to structures defined in `WrittenTypes`
    module Parser =
      // TODO: these should be UInts of some size
      // (UInt8 might even be enough - how many lines are over 255chars?)
      type Point = { row: Int64; column: Int64 }

      type Range = { start: Point; end_: Point }

      type ParsedNode =
        {
          // e.g., a node of `typ` `let_expression` has a child node with a `body` field name
          fieldName: Stdlib.Option.Option<String>

          /// e.g. `source_file`, `fn_decl`, `expression`, `let_expression`
          typ: String

          /// The text of this node as it was in the unparsed source code
          text: String

          /// Where in the source code is this node written/contained
          /// i.e. Line 1, Column 2 to Line 1, Column 5
          sourceRange: Range

          children: List<ParsedNode>
        }


      let parseToSimplifiedTree (text: String) : ParsedNode =
        Builtin.parserParseToSimplifiedTree text

      let parseName (fnName: String) : Stdlib.Result.Result<String> =
        if (Stdlib.String.contains fnName "_v") then
          // Todo : check if the name is valid
          Stdlib.Result.Result.Ok fnName
        else
          Stdlib.Result.Result.Ok(fnName ++ "_v0")

      // // TODO: maybe re-frame this into expected/actual or something
      // type ParseError =
      //   { sourceRange: Range
      //     sourceText: String
      //     message: String }


      // --------------------
      // Helper functions
      // --------------------

      let getText (node: ParsedNode) : String = node.text
      let getRange (node: ParsedNode) : Range = node.sourceRange

      let findNodeByFieldName
        (node: ParsedNode)
        (fieldName: String)
        : Stdlib.Option.Option<ParsedNode> =
        let filteredChildren =
          node.children
          |> Stdlib.List.filter (fun c ->
            match c.fieldName with
            | Some fName -> fName == fieldName
            | None -> false)

        match filteredChildren with
        | [ c ] -> Stdlib.Option.Option.Some c
        | [] -> Stdlib.Option.Option.None
        | _ -> Stdlib.Option.Option.None // TODO: this should error, there are multiple matches

      // --------------------
      // Parsing to WrittenTypes
      // --------------------

      module Identifiers =
        let extractModuleIdentifiersHelper
          (modulesSoFarInReverse:
            List<WrittenTypes.ModuleIdentifier * WrittenTypes.SourceRange>)
          (nodes: List<ParsedNode>)
          : (List<WrittenTypes.ModuleIdentifier * WrittenTypes.SourceRange> *
            ParsedNode)
          =
          match nodes with
          | modulePart :: symbolPart :: otherParts ->
            if modulePart.typ != "module_identifier" then
              $"Unexpected - modulePart should be a module_identifier but is {modulePart.typ}"
            elif symbolPart.typ != "symbol" then
              $"Unexpected - symbolPart should be a symbol but is {symbolPart.typ}"
            else
              let moduleIdentifier =
                WrittenTypes.ModuleIdentifier
                  { range = modulePart.sourceRange
                    name = modulePart.text }

              let updatedModules =
                Stdlib.List.push
                  modulesSoFarInReverse
                  ((moduleIdentifier, symbolPart.sourceRange))

              extractModuleIdentifiersHelper updatedModules otherParts

          | [ lastPart ] -> (modulesSoFarInReverse, lastPart)

          | [] ->
            "Unexpected - there should be an odd number of parts to a qualified name"

        /// Parses a qualified name (either type, or function, or (future) something else)
        ///
        /// These names come in the form of `module1.module2.module3.name`,
        /// and we need to parse out the `module1.module2.module3.` part,
        /// ensuring that we take note of the `.` source ranges after each module name
        let extractModuleIdentifiers
          (nodes: List<ParsedNode>)
          : (List<WrittenTypes.ModuleIdentifier * WrittenTypes.SourceRange> *
            ParsedNode)
          =
          let (modulesInReverse, lastNode) = extractModuleIdentifiersHelper [] nodes
          (Stdlib.List.reverse modulesInReverse, lastNode)

        let parseVariable (n: ParsedNode) : WrittenTypes.VariableIdentifier =
          WrittenTypes.VariableIdentifier { range = n.sourceRange; name = n.text }

        let parseType (n: ParsedNode) : WrittenTypes.TypeIdentifier =
          WrittenTypes.TypeIdentifier { range = n.sourceRange; name = n.text }

        let parseFn (n: ParsedNode) : WrittenTypes.FnIdentifier =
          WrittenTypes.FnIdentifier { range = n.sourceRange; name = n.text }


        let parseQualifiedType
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.QualifiedTypeIdentifier, String> =
          if node.typ == "qualified_type_name" then
            let (modules, typeIdentifierNode) =
              extractModuleIdentifiers node.children

            (WrittenTypes.QualifiedTypeIdentifier
              { range = node.sourceRange
                modules = modules
                typ = parseType typeIdentifierNode })
            |> Stdlib.Result.Result.Ok
          else
            Stdlib.Result.Result.Error
              $"Can't parse qualified_type_name from {node.typ}"


        let parseQualifiedFunction
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.QualifiedFnIdentifier, String> =
          if node.typ == "qualified_fn_name" then
            let (modules, fnIdentifierNode) = extractModuleIdentifiers node.children

            (WrittenTypes.QualifiedFnIdentifier
              { range = node.sourceRange
                modules = modules
                fn = parseFn fnIdentifierNode })
            |> Stdlib.Result.Result.Ok
          else
            Stdlib.Result.Result.Error
              $"Can't parse qualified_fn_name from {node.typ}"



      module TypeReference =
        let parseBuiltIn
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeReference.Builtin, WrittenTypes.Unparseable> =
          if node.typ == "builtin_type" then
            match node.text with
            | "Unit" ->
              (WrittenTypes.TypeReference.Builtin.TUnit node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Bool" ->
              (WrittenTypes.TypeReference.Builtin.TBool node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int8" ->
              (WrittenTypes.TypeReference.Builtin.TInt8 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt8" ->
              (WrittenTypes.TypeReference.Builtin.TUInt8 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int16" ->
              (WrittenTypes.TypeReference.Builtin.TInt16 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt16" ->
              (WrittenTypes.TypeReference.Builtin.TUInt16 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int32" ->
              (WrittenTypes.TypeReference.Builtin.TInt32 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt32" ->
              (WrittenTypes.TypeReference.Builtin.TUInt32 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int64" ->
              (WrittenTypes.TypeReference.Builtin.TInt64 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt64" ->
              (WrittenTypes.TypeReference.Builtin.TUInt64 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Int128" ->
              (WrittenTypes.TypeReference.Builtin.TInt128 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "UInt128" ->
              (WrittenTypes.TypeReference.Builtin.TUInt128 node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Float" ->
              (WrittenTypes.TypeReference.Builtin.TFloat node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "Char" ->
              (WrittenTypes.TypeReference.Builtin.TChar node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | "String" ->
              (WrittenTypes.TypeReference.Builtin.TString node.sourceRange)
              |> Stdlib.Result.Result.Ok

            | _ ->
              let firstChild = node.children |> Stdlib.List.head |> Builtin.unwrap

              match firstChild.typ with
              | "dict_type_reference" ->
                let dictKeyword =
                  (findNodeByFieldName firstChild "keyword_type_constructor")
                  |> Stdlib.Option.toResult
                    "No keyword_type_constructor node found in dict_type_reference"

                let openBracket =
                  (findNodeByFieldName firstChild "symbol_open_angle")
                  |> Stdlib.Option.toResult
                    "No symbol_open_angle node found in dict_type_reference"

                let valueTypeNode =
                  match findNodeByFieldName firstChild "value_type" with
                  | Some valueTypeNode -> parse valueTypeNode
                  | None ->
                    Stdlib.Result.Result.Error
                      "No type_param node found in dict_type_reference"

                let closeBracket =
                  (findNodeByFieldName firstChild "symbol_close_angle")
                  |> Stdlib.Option.toResult
                    "No symbol_close_angle node found in dict_type_reference"

                match dictKeyword, openBracket, valueTypeNode, closeBracket with
                | Ok dictKeyword, Ok openBracket, Ok valueTypeNode, Ok closeBracket ->
                  (WrittenTypes.TypeReference.Builtin.TDict
                    firstChild.sourceRange
                    dictKeyword.sourceRange
                    openBracket.sourceRange
                    valueTypeNode
                    closeBracket.sourceRange)
                  |> Stdlib.Result.Result.Ok

              | "tuple_type_reference" ->
                let leftParen =
                  (findNodeByFieldName firstChild "symbol_left_paren")
                  |> Stdlib.Option.toResult
                    "No symbol_left_paren node found in tuple_type_reference"

                let first =
                  match findNodeByFieldName firstChild "first" with
                  | Some firstNode -> TypeReference.parse firstNode
                  | None ->
                    Stdlib.Result.Result.Error
                      "No first node found in tuple_type_reference"

                let second =
                  match findNodeByFieldName firstChild "second" with
                  | Some secondNode -> TypeReference.parse secondNode
                  | None ->
                    Stdlib.Result.Result.Error
                      "No second node found in tuple_type_reference"

                let rest =
                  firstChild
                  |> findNodeByFieldName "rest"
                  |> Stdlib.Option.map (fun restNode ->
                    restNode.children
                    |> Stdlib.List.chunkBySize 2L
                    |> Builtin.unwrap
                    |> Stdlib.List.map (fun chunk ->
                      match chunk with
                      | [ symbol; typeNode ] ->
                        let typeRef = TypeReference.parse typeNode

                        match typeRef with
                        | Ok typeRef -> (symbol.sourceRange, typeRef)
                        | Error _ ->
                          (symbol.sourceRange,
                           WrittenTypes.Unparseable { source = typeNode })

                      | [ typeNode ] ->
                        let typeRef = TypeReference.parse typeNode

                        match typeRef with
                        | Ok typeRef -> (Stdlib.Option.Option.None, typeRef)
                        | Error _ ->
                          (Stdlib.Option.Option.None,
                           WrittenTypes.Unparseable { source = typeNode })
                      | _ ->
                        (Stdlib.Option.Option.None,
                         WrittenTypes.Unparseable { source = chunk })))
                  |> Stdlib.Option.withDefault []

                let asterisk =
                  (findNodeByFieldName firstChild "symbol_asterisk")
                  |> Stdlib.Option.toResult
                    "No symbol_asterisk node found in tuple_type_reference"

                let rightParen =
                  (findNodeByFieldName firstChild "symbol_right_paren")
                  |> Stdlib.Option.toResult
                    "No symbol_right_paren node found in tuple_type_reference"

                match leftParen, first, asterisk, second, rightParen with
                | Ok leftParen, Ok first, Ok asterisk, Ok second, Ok rightParen ->
                  (WrittenTypes.TypeReference.Builtin.TTuple(
                    node.sourceRange,
                    first,
                    asterisk.sourceRange,
                    second,
                    rest,
                    leftParen.sourceRange,
                    rightParen.sourceRange
                  ))
                  |> Stdlib.Result.Result.Ok

                | _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              | "list_type_reference" ->
                let listKeyword =
                  (findNodeByFieldName firstChild "keyword_type_constructor")
                  |> Stdlib.Option.toResult
                    "No keyword_type_constructor node found in list_type"

                let openBracketNode =
                  (findNodeByFieldName firstChild "symbol_open_angle")
                  |> Stdlib.Option.toResult
                    "No symbol_open_angle node found in list_type"

                let typeParamNode =
                  match findNodeByFieldName firstChild "typ_param" with
                  | Some typeParamNode -> parse typeParamNode
                  | None ->
                    Stdlib.Result.Result.Error
                      "No type_param node found in list_type"

                let closeBracketNode =
                  (findNodeByFieldName firstChild "symbol_close_angle")
                  |> Stdlib.Option.toResult
                    "No symbol_close_angle node found in list_type"

                match
                  listKeyword, openBracketNode, typeParamNode, closeBracketNode
                with
                | Ok listKeyword,
                  Ok openBracketNode,
                  Ok typeParam,
                  Ok closeBracketNode ->
                  (WrittenTypes.TypeReference.Builtin.TList
                    firstChild.sourceRange
                    listKeyword.sourceRange
                    openBracketNode.sourceRange
                    typeParam
                    closeBracketNode.sourceRange)
                  |> Stdlib.Result.Result.Ok
                | _ ->
                  Stdlib.Result.Result.Error(
                    WrittenTypes.Unparseable { source = node }
                  )
          else
            Stdlib.Result.Result.Error(WrittenTypes.Unparseable { source = node })



        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeReference.TypeReference, WrittenTypes.Unparseable> =
          if node.typ == "type_reference" then
            match node.children with
            | [ single ] ->
              if single.typ == "builtin_type" then
                match parseBuiltIn single with
                | Ok builtin ->
                  (WrittenTypes.TypeReference.TypeReference.Builtin builtin)
                  |> Stdlib.Result.Result.Ok
                | Error _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              elif single.typ == "qualified_type_name" then
                match Identifiers.parseQualifiedType single with
                | Ok qualifiedType ->
                  (WrittenTypes.TypeReference.TypeReference.QualifiedName
                    qualifiedType)
                  |> Stdlib.Result.Result.Ok

                | Error _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              else
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

            | _ -> Stdlib.Result.Result.Error "Not a single child"

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


      module TypeDeclaration =
        let parseDefinition
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeDeclaration.Definition, WrittenTypes.Unparseable> =
          if node.typ == "type_decl_def" then
            match node.children with
            | [ child ] when child.typ == "type_decl_def_alias" ->
              match child.children with
              | [ single ] when single.typ == "type_reference" ->
                let typRef = TypeReference.parse single

                match typRef with
                | Ok typRef ->
                  (WrittenTypes.TypeDeclaration.Definition.Alias typRef)
                  |> Stdlib.Result.Result.Ok

                | Error _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              | _ ->
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

            | [ child ] when child.typ == "type_decl_def_record" ->
              let openBraceNode =
                (findNodeByFieldName child "symbol_open_brace")
                |> Stdlib.Option.toResult
                  "No symbol_open_brace node found in type_decl_def_record"

              let recordFields =
                match (findNodeByFieldName child "content") with
                | Some contentNode ->
                  contentNode.children
                  |> Stdlib.List.chunkBySize 2L
                  |> Builtin.unwrap
                  |> Stdlib.List.map (fun chunk ->
                    match chunk with
                    | [ fieldNode ] ->
                      let fieldNameNode =
                        (findNodeByFieldName fieldNode "field")
                        |> Stdlib.Option.toResult
                          "No field_name node found in type_decl_def_record"

                      let symbolColonNode =
                        (findNodeByFieldName fieldNode "symbol_colon")
                        |> Stdlib.Option.toResult
                          "No symbol_colon node found in type_decl_def_record"

                      let fieldTypeNode =
                        (findNodeByFieldName fieldNode "type")
                        |> Stdlib.Option.toResult
                          "No field_type node found in type_decl_def_record"

                      match fieldNameNode, symbolColonNode, fieldTypeNode with
                      | Ok fieldNameNode, Ok symbolColonNode, Ok fieldTypeNode ->
                        let fieldType = TypeReference.parse fieldTypeNode

                        match fieldType with
                        | Ok fieldType ->
                          (WrittenTypes.TypeDeclaration.RecordField
                            { range = fieldNode.sourceRange
                              name = (fieldNameNode.sourceRange, fieldNameNode.text)
                              typ = fieldType
                              description = ""
                              symbolColon = symbolColonNode.sourceRange })
                          |> Stdlib.Result.Result.Ok

                        | Error _ ->
                          (WrittenTypes.Unparseable { source = fieldTypeNode })
                          |> Stdlib.Result.Result.Error
                      | _ ->
                        (WrittenTypes.Unparseable { source = fieldNode })
                        |> Stdlib.Result.Result.Error

                    | [ fieldNode; _separator ] ->
                      let fieldNameNode =
                        (findNodeByFieldName fieldNode "field")
                        |> Stdlib.Option.toResult
                          "No field_name node found in type_decl_def_record"

                      let symbolColonNode =
                        (findNodeByFieldName fieldNode "symbol_colon")
                        |> Stdlib.Option.toResult
                          "No symbol_colon node found in type_decl_def_record"

                      let fieldTypeNode =
                        (findNodeByFieldName fieldNode "type")
                        |> Stdlib.Option.toResult
                          "No field_type node found in type_decl_def_record"

                      match fieldNameNode, symbolColonNode, fieldTypeNode with
                      | Ok fieldNameNode, Ok symbolColonNode, Ok fieldTypeNode ->
                        let fieldType = TypeReference.parse fieldTypeNode

                        match fieldType with
                        | Ok fieldType ->
                          (WrittenTypes.TypeDeclaration.RecordField
                            { range = fieldNode.sourceRange
                              name = (fieldNameNode.sourceRange, fieldNameNode.text)
                              typ = fieldType
                              description = ""
                              symbolColon = symbolColonNode.sourceRange })
                          |> Stdlib.Result.Result.Ok

                        | Error _ ->
                          (WrittenTypes.Unparseable { source = fieldTypeNode })
                          |> Stdlib.Result.Result.Error
                      | _ ->
                        (WrittenTypes.Unparseable { source = fieldNode })
                        |> Stdlib.Result.Result.Error

                    | _ ->
                      (WrittenTypes.Unparseable { source = fieldNode })
                      |> Stdlib.Result.Result.Error)

                | None -> [] |> Stdlib.Result.Result.Ok

              let recordFields = recordFields |> Stdlib.Result.values

              let closeBraceNode =
                (findNodeByFieldName child "symbol_close_brace")
                |> Stdlib.Option.toResult
                  "No symbol_close_brace node found in type_decl_def_record"

              match openBraceNode, recordFields, closeBraceNode with
              | Ok openBraceNode, Ok recordFields, Ok closeBraceNode ->
                (WrittenTypes.TypeDeclaration.Definition.Record recordFields)
                |> Stdlib.Result.Result.Ok


            | [ child ] when child.typ == "type_decl_def_enum" ->
              let enumCases =
                match findNodeByFieldName child "content" with
                | Some contentNode ->
                  contentNode.children
                  |> Stdlib.List.map (fun caseNode ->
                    let caseNameNode = findNodeByFieldName caseNode "case_name"

                    let keywordOf =
                      Stdlib.Option.map
                        (findNodeByFieldName caseNode "keyword_of")
                        (fun range -> range.sourceRange)

                    let fields =
                      caseNode.children
                      |> Stdlib.List.filter (fun field ->
                        field.typ == "type_decl_enum_field")
                      |> Stdlib.List.map (fun field ->
                        match findNodeByFieldName field "type" with
                        | Some fieldTypeNode ->
                          let label =
                            (findNodeByFieldName field "identifier")
                            |> Stdlib.Option.map (fun ln ->
                              (ln.sourceRange, ln.text))

                          let colonSymbol =
                            (findNodeByFieldName field "symbol_colon")
                            |> Stdlib.Option.map (fun ln -> ln.sourceRange)

                          let fieldType = TypeReference.parse fieldTypeNode

                          match fieldType with
                          | Ok fieldType ->
                            WrittenTypes.TypeDeclaration.EnumField
                              { range = field.sourceRange
                                typ = fieldType
                                label = label
                                description = ""
                                symbolColon = colonSymbol }
                          | Error _ ->
                            (WrittenTypes.Unparseable { source = field })
                        | None -> (WrittenTypes.Unparseable { source = field }))

                    match caseNameNode with
                    | Some caseNameNode ->
                      (WrittenTypes.TypeDeclaration.EnumCase
                        { range = caseNode.sourceRange
                          name = (caseNameNode.sourceRange, caseNameNode.text)
                          fields = fields
                          description = ""
                          keywordOf = keywordOf })
                      |> Stdlib.Result.Result.Ok
                    | None ->
                      (WrittenTypes.Unparseable { source = caseNode })
                      |> Stdlib.Result.Result.Error)
                  |> Stdlib.Result.values
                | None -> []

              match enumCases with
              | Ok enumCases ->
                (WrittenTypes.TypeDeclaration.Definition.Enum enumCases)
                |> Stdlib.Result.Result.Ok
              | Error _ ->
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.TypeDeclaration.TypeDeclaration, WrittenTypes.Unparseable> =
          if node.typ == "type_decl" then

            let nameNode =
              match findNodeByFieldName node "name" with
              | Some nameNode ->
                (Identifiers.parseType nameNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No name node found in type_decl"

            let defNode =
              match findNodeByFieldName node "typ" with
              | Some defNode -> (parseDefinition defNode)
              | None ->
                Stdlib.Result.Result.Error "No definition node found in type_decl"

            let keywordTypeNode =
              match findNodeByFieldName node "keyword_type" with
              | Some keywordTypeNode ->
                (getRange keywordTypeNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error "No keyword_type node found in type_decl"

            let symbolEqualsNode =
              match findNodeByFieldName node "symbol_equals" with
              | Some symbolEqualsNode ->
                (getRange symbolEqualsNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error "No symbol_equals node found in type_decl"

            match nameNode, defNode, keywordTypeNode, symbolEqualsNode with
            | Ok name, Ok def, Ok keywordTypeNode, Ok symbolEqualsNode ->
              (WrittenTypes.TypeDeclaration.TypeDeclaration
                { range = node.sourceRange
                  name = name
                  definition = def
                  keywordType = keywordTypeNode
                  symbolEquals = symbolEqualsNode })
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


      module Expr =
        let parseBoolLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "bool_literal" then
            let b =
              // TODO: error-handling
              match getText node with
              | "true" -> true |> Stdlib.Result.Result.Ok
              | "false" -> false |> Stdlib.Result.Result.Ok
              | _ ->
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

            match b with
            | Ok b ->
              (WrittenTypes.Expr.EBool(node.sourceRange, b))
              |> Stdlib.Result.Result.Ok
            | Error _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseIntLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let supportedInts =
            [ "int8_literal"
              "uint8_literal"
              "int16_literal"
              "uint16_literal"
              "int32_literal"
              "uint32_literal"
              "int64_literal"
              "uint64_literal"
              "int128_literal"
              "uint128_literal" ]

          if Stdlib.List.member_v0 supportedInts node.typ then
            let intPart =
              (findNodeByFieldName node "digits")
              |> Stdlib.Option.toResult "No digits node found in int_literal"

            let suffixPart =
              (findNodeByFieldName node "suffix")
              |> Stdlib.Option.toResult "No suffix node found in int_literal"

            match intPart, suffixPart with
            | Ok intPart, Ok suffixPart ->
              let intText = getText intPart

              let parsedResult =
                match node.typ with
                | "int8_literal" ->
                  (Stdlib.Int8.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt8(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint8_literal" ->
                  (Stdlib.UInt8.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt8(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int16_literal" ->
                  (Stdlib.Int16.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt16(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint16_literal" ->
                  (Stdlib.UInt16.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt16(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int32_literal" ->
                  (Stdlib.Int32.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt32(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint32_literal" ->
                  (Stdlib.UInt32.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt32(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int64_literal" ->
                  (Stdlib.Int64.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt64(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint64_literal" ->
                  (Stdlib.UInt64.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt64(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "int128_literal" ->
                  (Stdlib.Int128.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EInt128(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | "uint128_literal" ->
                  (Stdlib.UInt128.parse intText)
                  |> Stdlib.Result.map (fun i ->
                    WrittenTypes.Expr.EUInt128(
                      node.sourceRange,
                      (intPart.sourceRange, i),
                      suffixPart.sourceRange
                    ))
                | _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

              match parsedResult with
              | Ok expr -> Stdlib.Result.Result.Ok expr
              | Error _ ->
                Stdlib.Result.Result.Error(
                  WrittenTypes.Unparseable { source = node }
                )
              | _ ->
                (WrittenTypes.Unparseable { source = node })
                |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseFloatLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "float_literal" then
            let floatStr = getText node

            match Stdlib.Float.parse floatStr with
            | Ok floatValue ->
              let (sign, whole, remainder) =
                let (sign, unsignedFloat) =
                  if Stdlib.String.startsWith floatStr "-" then
                    (Sign.Negative, Stdlib.String.dropFirst floatStr 1L)
                  else
                    (Sign.Positive, floatStr)

                let parts = Stdlib.String.split unsignedFloat "."

                let whole =
                  parts |> Stdlib.List.head |> Stdlib.Option.withDefault "0"

                let remainder =
                  parts
                  |> Stdlib.List.tail
                  |> Stdlib.Option.withDefault [ "0" ]
                  |> Stdlib.List.head
                  |> Stdlib.Option.withDefault "0"

                (sign, whole, remainder)

              (WrittenTypes.Expr.EFloat(node.sourceRange, sign, whole, remainder))
              |> Stdlib.Result.Result.Ok

            | Error _ ->
              Stdlib.Result.Result.Error(WrittenTypes.Unparseable { source = node })

          else
            Stdlib.Result.Result.Error(WrittenTypes.Unparseable { source = node })


        let parseStringLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "string_literal" then
            let openQuoteNode =
              (findNodeByFieldName node "symbol_open_quote")
              |> Stdlib.Option.toResult
                "No symbol_open_quote node found in string_literal"

            let contents =
              match findNodeByFieldName node "content" with
              | Some contentPart ->
                Stdlib.Option.Option.Some(
                  (contentPart.sourceRange, contentPart.text)
                )
              | None -> Stdlib.Option.Option.None

            let closeQuoteNode =
              (findNodeByFieldName node "symbol_close_quote")
              |> Stdlib.Option.toResult
                "No symbol_close_quote node found in string_literal"

            match openQuoteNode, closeQuoteNode with
            | Ok openQuoteNode, Ok closeQuoteNode ->
              (WrittenTypes.Expr.EString(
                node.sourceRange,
                contents,
                openQuoteNode.sourceRange,
                closeQuoteNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseCharLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "char_literal" then
            let openQuoteNode =
              (findNodeByFieldName node "symbol_open_single_quote")
              |> Stdlib.Option.toResult
                "No symbol_open_single_quote node found in char_literal"

            let charNode =
              match findNodeByFieldName node "content" with
              | Some charPart ->
                Stdlib.Option.Option.Some((charPart.sourceRange, charPart.text))
              | None -> Stdlib.Option.Option.None

            let closeQuoteNode =
              (findNodeByFieldName node "symbol_close_single_quote")
              |> Stdlib.Option.toResult
                "No symbol_close_single_quote node found in char_literal"

            match openQuoteNode, closeQuoteNode with
            | Ok openQuoteNode, Ok closeQuoteNode ->
              (WrittenTypes.Expr.EChar(
                node.sourceRange,
                charNode,
                openQuoteNode.sourceRange,
                closeQuoteNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error


        let parseListLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "list_literal" then
            let openBracketNode =
              (findNodeByFieldName node "symbol_open_bracket")
              |> Stdlib.Option.toResult
                "No symbol_open_bracket node found in list_literal"

            let contents =
              node
              |> findNodeByFieldName "content"
              |> Stdlib.Option.map (fun contentsNode ->
                contentsNode.children
                |> Stdlib.List.chunkBySize 2L
                |> Builtin.unwrap
                |> Stdlib.List.map (fun chunk ->
                  match chunk with
                  | [ exprNode; symbol ] ->
                    let expr = Expr.parse exprNode

                    match expr with
                    | Ok e -> (e, Stdlib.Option.Option.Some symbol.sourceRange)
                    | Error _ ->
                      (WrittenTypes.Unparseable { source = exprNode },
                       Stdlib.Option.Option.None)

                  | [ exprNode ] ->
                    let expr = Expr.parse exprNode

                    match expr with
                    | Ok e -> (e, Stdlib.Option.Option.None)
                    | Error _ ->
                      (WrittenTypes.Unparseable { source = exprNode },
                       Stdlib.Option.Option.None)
                  | _ ->
                    (WrittenTypes.Unparseable { source = contentsNode },
                     Stdlib.Option.Option.None)))

              |> Stdlib.Option.withDefault []

            let closeBracketNode =
              (findNodeByFieldName node "symbol_close_bracket")
              |> Stdlib.Option.toResult
                "No symbol_close_bracket node found in list_literal"

            match openBracketNode, closeBracketNode with
            | Ok openBracketNode, Ok closeBracketNode ->
              (WrittenTypes.Expr.EList(
                node.sourceRange,
                contents,
                openBracketNode.sourceRange,
                closeBracketNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok


        let parseDictLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "dict_literal" then
            let keywordDictNode =
              (findNodeByFieldName node "keyword_dict")
              |> Stdlib.Option.toResult "No keyword_dict node found in dict_literal"

            let openBraceNode =
              (findNodeByFieldName node "symbol_open_brace")
              |> Stdlib.Option.toResult
                "No symbol_open_brace node found in dict_literal"

            let contents =
              node
              |> findNodeByFieldName "content"
              |> Stdlib.Option.map (fun contentsNode ->
                contentsNode.children
                |> Stdlib.List.chunkBySize 2L
                |> Builtin.unwrap
                |> Stdlib.List.map (fun chunk ->
                  match chunk with
                  | [ dictPairNode; _separator ] ->
                    let keyNode =
                      (findNodeByFieldName dictPairNode "key")
                      |> Stdlib.Option.toResult "No key node found in dict_pair"

                    let symbolEqualsNode =
                      (findNodeByFieldName dictPairNode "symbol_equals")
                      |> Stdlib.Option.toResult
                        "No symbol_equals node found in dict_pair"

                    let valueNode =
                      (findNodeByFieldName dictPairNode "value")
                      |> Stdlib.Option.toResult "No value node found in dict_pair"

                    match (keyNode, symbolEqualsNode, valueNode) with
                    | (Ok keyNode, Ok symbolEqualsNode, Ok valueNode) ->
                      let key = keyNode.text
                      let value = Expr.parse valueNode

                      match value with
                      | Ok value -> (symbolEqualsNode, key, value)
                      | _ ->
                        Stdlib.Result.Result.Error(
                          WrittenTypes.Unparseable { source = dictPairNode }
                        )
                    | _ ->
                      Stdlib.Result.Result.Error(
                        WrittenTypes.Unparseable { source = chunk }
                      )

                  | [ dictPairNode ] ->
                    let keyNode =
                      (findNodeByFieldName dictPairNode "key")
                      |> Stdlib.Option.toResult "No key node found in dict_pair"

                    let symbolEqualsNode =
                      (findNodeByFieldName dictPairNode "symbol_equals")
                      |> Stdlib.Option.toResult
                        "No symbol_equals node found in dict_pair"

                    let valueNode =
                      (findNodeByFieldName dictPairNode "value")
                      |> Stdlib.Option.toResult "No value node found in dict_pair"

                    match (keyNode, symbolEqualsNode, valueNode) with
                    | (Ok keyNode, Ok symbolEqualsNode, Ok valueNode) ->
                      let key = keyNode.text
                      let value = Expr.parse valueNode

                      match value with
                      | Ok value -> (symbolEqualsNode, key, value)
                      | _ ->
                        Stdlib.Result.Result.Error(
                          WrittenTypes.Unparseable { source = dictPairNode }
                        )
                    | _ ->
                      Stdlib.Result.Result.Error(
                        WrittenTypes.Unparseable { source = chunk }
                      )
                  | _ ->
                    Stdlib.Result.Result.Error(
                      WrittenTypes.Unparseable { source = chunk }
                    )))
              |> Stdlib.Option.withDefault []

            let closeBraceNode =
              (findNodeByFieldName node "symbol_close_brace")
              |> Stdlib.Option.toResult
                "No symbol_close_brace node found in dict_literal"

            match keywordDictNode, openBraceNode, closeBraceNode with
            | Ok keywordDictNode, Ok openBraceNode, Ok closeBraceNode ->
              (WrittenTypes.Expr.EDict(
                node.sourceRange,
                contents,
                keywordDictNode.sourceRange,
                openBraceNode.sourceRange,
                closeBraceNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseTupleLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "tuple_literal" then
            let openParenNode =
              (findNodeByFieldName node "symbol_left_paren")
              |> Stdlib.Option.toResult
                "No symbol_open_paren node found in tuple_literal"

            let first =
              match findNodeByFieldName node "first" with
              | Some firstNode -> Expr.parse firstNode
              | None ->
                Stdlib.Result.Result.Error "No first node found in tuple_literal"

            let second =
              match findNodeByFieldName node "second" with
              | Some secondNode -> Expr.parse secondNode
              | None ->
                Stdlib.Result.Result.Error "No second node found in tuple_literal"

            let rest =
              (findNodeByFieldName node "rest")
              |> Stdlib.Option.map (fun restNode ->
                restNode.children
                |> Stdlib.List.chunkBySize 2L
                |> Builtin.unwrap
                |> Stdlib.List.map (fun chunk ->
                  match chunk with
                  | [ symbol; exprNode ] ->
                    let expr = Expr.parse exprNode

                    match expr with
                    | Ok expr -> (symbol.sourceRange, expr)
                    | Error _ ->
                      (symbol.sourceRange,
                       WrittenTypes.Unparseable { source = exprNode })

                  | [ exprNode ] ->
                    let expr = Expr.parse exprNode

                    match expr with
                    | Ok expr -> (Stdlib.Option.Option.None, expr)
                    | Error _ ->
                      (Stdlib.Option.Option.None,
                       WrittenTypes.Unparseable { source = exprNode })
                  | _ ->
                    (Stdlib.Option.Option.None,
                     WrittenTypes.Unparseable { source = chunk })))
              |> Stdlib.Option.withDefault []

            let commaSymbol =
              (findNodeByFieldName node "symbol_comma")
              |> Stdlib.Option.toResult "No symbol_comma node found in tuple_literal"

            let closeParenNode =
              (findNodeByFieldName node "symbol_right_paren")
              |> Stdlib.Option.toResult
                "No symbol_close_paren node found in tuple_literal"

            match openParenNode, first, commaSymbol, second, closeParenNode with
            | Ok openParenNode,
              Ok first,
              Ok commaSymbol,
              Ok second,
              Ok closeParenNode ->
              (WrittenTypes.Expr.ETuple(
                node.sourceRange,
                first,
                commaSymbol.sourceRange,
                second,
                rest,
                openParenNode.sourceRange,
                closeParenNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error
          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseRecordLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "record_literal" then
            let typeNameNode =
              (findNodeByFieldName node "type_name")
              |> Stdlib.Option.toResult "No type_name node found in record_literal"

            let openBraceNode =
              (findNodeByFieldName node "symbol_open_brace")
              |> Stdlib.Option.toResult
                "No symbol_open_brace node found in record_literal"

            let contents =
              node
              |> findNodeByFieldName "content"
              |> Stdlib.Option.map (fun contentsNode ->
                contentsNode.children
                |> Stdlib.List.chunkBySize 2L
                |> Builtin.unwrap
                |> Stdlib.List.map (fun chunk ->
                  match chunk with
                  | [ recordPairNode; _separator ] ->
                    let fieldNode =
                      (findNodeByFieldName recordPairNode "field")
                      |> Stdlib.Option.toResult
                        "No field node found in record_pair"

                    let symbolEqualsNode =
                      (findNodeByFieldName recordPairNode "symbol_equals")
                      |> Stdlib.Option.toResult
                        "No symbol_equals node found in record_pair"

                    let valueNode =
                      (findNodeByFieldName recordPairNode "value")
                      |> Stdlib.Option.toResult
                        "No value node found in record_pair"

                    match fieldNode, symbolEqualsNode, valueNode with
                    | Ok fieldNode, Ok symbolEqualsNode, Ok valueNode ->
                      let field = (fieldNode.sourceRange, fieldNode.text)
                      let value = Expr.parse valueNode

                      match value with
                      | Ok value -> (symbolEqualsNode, field, value)
                      | _ ->
                        Stdlib.Result.Result.Error(
                          WrittenTypes.Unparseable { source = recordPairNode }
                        )
                    | _ ->
                      Stdlib.Result.Result.Error(
                        WrittenTypes.Unparseable { source = chunk }
                      )

                  | [ recordPairNode ] ->
                    let fieldNode =
                      (findNodeByFieldName recordPairNode "field")
                      |> Stdlib.Option.toResult
                        "No field node found in record_pair"

                    let symbolEqualsNode =
                      (findNodeByFieldName recordPairNode "symbol_equals")
                      |> Stdlib.Option.toResult
                        "No symbol_equals node found in record_pair"

                    let valueNode =
                      (findNodeByFieldName recordPairNode "value")
                      |> Stdlib.Option.toResult
                        "No value node found in record_pair"

                    match fieldNode, symbolEqualsNode, valueNode with
                    | Ok fieldNode, Ok symbolEqualsNode, Ok valueNode ->
                      let field = (fieldNode.sourceRange, fieldNode.text)
                      let value = Expr.parse valueNode

                      match value with
                      | Ok value -> (symbolEqualsNode, field, value)
                      | _ ->
                        Stdlib.Result.Result.Error(
                          WrittenTypes.Unparseable { source = recordPairNode }
                        )
                    | _ ->
                      Stdlib.Result.Result.Error(
                        WrittenTypes.Unparseable { source = chunk }
                      )
                  | _ ->
                    Stdlib.Result.Result.Error(
                      WrittenTypes.Unparseable { source = chunk }
                    )))
              |> Stdlib.Option.withDefault []

            let closeBraceNode =
              (findNodeByFieldName node "symbol_close_brace")
              |> Stdlib.Option.toResult
                "No symbol_close_brace node found in record_literal"

            match typeNameNode, openBraceNode, closeBraceNode with
            | Ok typeNameNode, Ok openBraceNode, Ok closeBraceNode ->
              let typeNameNode =
                Darklang.LanguageTools.WrittenTypes.Name.Unresolved(
                  typeNameNode.sourceRange,
                  [ typeNameNode.text ]
                )

              (WrittenTypes.Expr.ERecord(
                node.sourceRange,
                typeNameNode,
                contents,
                openBraceNode.sourceRange,
                closeBraceNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseEnumLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "enum_literal" then
            let typeNameNode =
              (findNodeByFieldName node "type_name")
              |> Stdlib.Option.toResult "No type_name node found in enum_literal"

            let symbolDotNode =
              (findNodeByFieldName node "symbol_dot")
              |> Stdlib.Option.toResult "No symbol_dot node found in enum_literal"

            let caseNameNode =
              (findNodeByFieldName node "case_name")
              |> Stdlib.Option.toResult "No case_name node found in enum_literal"

            let enumFieldsNode =
              (findNodeByFieldName node "enum_fields")
              |> Stdlib.Option.map (fun enumFieldsNode ->
                enumFieldsNode.children
                |> Stdlib.List.chunkBySize 2L
                |> Builtin.unwrap
                |> Stdlib.List.map (fun chunk ->
                  match chunk with
                  | [ fieldNode ] ->
                    match Expr.parse fieldNode with
                    | Ok field -> field
                    | Error _ -> (WrittenTypes.Unparseable { source = fieldNode })

                  | [ fieldNode; _separator ] ->
                    match Expr.parse fieldNode with
                    | Ok field -> field
                    | Error _ -> (WrittenTypes.Unparseable { source = fieldNode })))

              |> Stdlib.Option.withDefault []


            match typeNameNode, symbolDotNode, caseNameNode with
            | Ok typeNameNode, Ok symbolDotNode, Ok caseNameNode ->

              (WrittenTypes.Expr.EEnum(
                node.sourceRange,
                (typeNameNode.sourceRange, [ typeNameNode.text ]),
                (caseNameNode.sourceRange, caseNameNode.text),
                enumFieldsNode,
                symbolDotNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error


        let parseLetExpr
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "let_expression" then
            let keywordLetNode =
              (findNodeByFieldName node "keyword_let")
              |> Stdlib.Option.toResult "No keyword_let node found in let_expression"

            let identifierNode =
              (findNodeByFieldName node "identifier")
              |> Stdlib.Option.toResult "No identifier node found in let_expression"

            let symbolEqualsNode =
              (findNodeByFieldName node "symbol_equals")
              |> Stdlib.Option.toResult
                "No symbol_equals node found in let_expression"

            let expr =
              match findNodeByFieldName node "expr" with
              | Some exprNode -> Expr.parse exprNode
              | None ->
                Stdlib.Result.Result.Error "No expr node found in let_expression"

            let body =
              match findNodeByFieldName node "body" with
              | Some bodyNode -> Expr.parse bodyNode
              | None ->
                Stdlib.Result.Result.Error "No body node found in let_expression"

            match keywordLetNode, identifierNode, symbolEqualsNode, expr, body with
            | Ok keywordLetNode,
              Ok identifierNode,
              Ok symbolEqualsNode,
              Ok expr,
              Ok body ->
              (WrittenTypes.Expr.ELet(
                node.sourceRange,
                WrittenTypes.LetPattern.LPVariable(
                  identifierNode.sourceRange,
                  identifierNode.text
                ),
                expr,
                body,
                keywordLetNode.sourceRange,
                symbolEqualsNode.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseInfixOperation
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "infix_operation" then
            let leftArg =
              match findNodeByFieldName node "left" with
              | Some leftArgNode -> Expr.parse leftArgNode
              | None ->
                Stdlib.Result.Result.Error "No left node found in infix_operation"

            let operatorNode =
              (findNodeByFieldName node "operator")
              |> Stdlib.Option.toResult "No operator node found in infix_operation"

            let operator =
              // TODO revisit error-handling here
              match operatorNode with
              | Ok operatorNode ->
                match getText operatorNode with
                | "+" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ArithmeticPlus
                | "-" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ArithmeticMinus
                | "*" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ArithmeticMultiply
                | "/" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ArithmeticDivide
                | "%" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ArithmeticModulo
                | "^" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ArithmeticPower
                | ">" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ComparisonGreaterThan
                | ">=" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ComparisonGreaterThanOrEqual
                | "<" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ComparisonLessThan
                | "<=" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ComparisonLessThanOrEqual
                | "==" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ComparisonEquals
                | "!=" ->
                  WrittenTypes.Infix.InfixFnCall
                    WrittenTypes.InfixFnName.ComparisonNotEquals
                | "&&" ->
                  WrittenTypes.Infix.BinOp WrittenTypes.BinaryOperation.BinOpAnd
                | "||" ->
                  WrittenTypes.Infix.BinOp WrittenTypes.BinaryOperation.BinOpOr
                | _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error

            let rightArg =
              match findNodeByFieldName node "right" with
              | Some rightArgNode -> Expr.parse rightArgNode
              | None ->
                Stdlib.Result.Result.Error "No right node found in infix_operation"

            match leftArg, operatorNode, rightArg with
            | Ok leftArg, Ok operatorNode, Ok rightArg ->
              (WrittenTypes.Expr.EInfix(
                node.sourceRange,
                ((operatorNode.sourceRange, operator)),
                leftArg,
                rightArg
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error


        let parseIfExpression
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "if_expression" then
            let keywordIfNode =
              (findNodeByFieldName node "keyword_if")
              |> Stdlib.Option.toResult "No keyword_if node found in if_expression"

            let conditionNode =
              match findNodeByFieldName node "condition" with
              | Some conditionNode -> Expr.parse conditionNode
              | None ->
                Stdlib.Result.Result.Error "No condition node found in if_expression"

            let keywordThenNode =
              (findNodeByFieldName node "keyword_then")
              |> Stdlib.Option.toResult "No keyword_then node found in if_expression"

            let thenNode =
              match findNodeByFieldName node "then_expression" with
              | Some thenNode -> Expr.parse thenNode
              | None ->
                Stdlib.Result.Result.Error "No then node found in if_expression"

            let keywordElseNode = findNodeByFieldName node "keyword_else"

            let elseNode =
              match findNodeByFieldName node "else_expression" with
              | None -> Stdlib.Option.Option.None
              | Some elseBlock -> (Expr.parse elseBlock) |> Stdlib.Result.toOption

            match keywordIfNode, conditionNode, keywordThenNode, thenNode with
            | Ok keywordIfNode, Ok conditionNode, Ok keywordThenNode, Ok thenNode ->
              let keywordElseNodeRange =
                keywordElseNode |> Stdlib.Option.map (fun node -> node.sourceRange)

              (WrittenTypes.Expr.EIf(
                node.sourceRange,
                conditionNode,
                thenNode,
                elseNode,
                keywordIfNode.sourceRange,
                keywordThenNode.sourceRange,
                keywordElseNodeRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        let parseFunctionCall
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "function_call" then

            let fnNameNode =
              match findNodeByFieldName node "fn" with
              | Some fnNameNode -> Identifiers.parseQualifiedFunction fnNameNode
              | None ->
                Stdlib.Result.Result.Error "No fn node found in function_call"

            let args =
              node.children
              |> Stdlib.List.filter (fun c ->
                match c.fieldName with
                | Some fName -> fName == "args"
                | None -> false)
              |> Stdlib.List.map Expr.parse
              |> Stdlib.List.map (fun expr ->
                match expr with
                | Ok exp -> exp
                | Error _ ->
                  (WrittenTypes.Unparseable { source = node })
                  |> Stdlib.Result.Result.Error)

            let symbolLeftParen =
              (findNodeByFieldName node "symbol_left_paren")
              |> Stdlib.Option.toResult
                "No symbol_left_paren node found in function_call"

            let symbolRightParen =
              (findNodeByFieldName node "symbol_right_paren")
              |> Stdlib.Option.toResult
                "No symbol_right_paren node found in function_call"

            match fnNameNode, args, symbolLeftParen, symbolRightParen with
            | Ok fnName, args, Ok symbolLeftParen, Ok symbolRightParen ->
              (WrittenTypes.Expr.EFnCall(
                node.sourceRange,
                fnName,
                args,
                symbolLeftParen.sourceRange,
                symbolRightParen.sourceRange
              ))
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        /// this parses one of the Expr cases
        let parseCase
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =

          match node.typ with
          // simple
          | "paren_expression" ->
            match findNodeByFieldName node "expr" with
            | Some exprNode -> Expr.parse exprNode
            | None -> WrittenTypes.Unparseable { source = node }

          | "unit" ->
            (WrittenTypes.Expr.EUnit node.sourceRange) |> Stdlib.Result.Result.Ok
          | "bool_literal" -> parseBoolLiteral node
          | "int8_literal" -> parseIntLiteral node
          | "uint8_literal" -> parseIntLiteral node
          | "int16_literal" -> parseIntLiteral node
          | "uint16_literal" -> parseIntLiteral node
          | "int32_literal" -> parseIntLiteral node
          | "uint32_literal" -> parseIntLiteral node
          | "int64_literal" -> parseIntLiteral node
          | "uint64_literal" -> parseIntLiteral node
          | "int128_literal" -> parseIntLiteral node
          | "uint128_literal" -> parseIntLiteral node
          | "float_literal" -> parseFloatLiteral node
          | "string_literal" -> parseStringLiteral node
          | "char_literal" -> parseCharLiteral node

          | "list_literal" -> parseListLiteral node
          | "dict_literal" -> parseDictLiteral node
          | "tuple_literal" -> parseTupleLiteral node

          | "record_literal" -> parseRecordLiteral node

          | "enum_literal" -> parseEnumLiteral node

          // assigning and accessing variables
          | "let_expression" -> parseLetExpr node
          | "variable_identifier" ->
            (WrittenTypes.Expr.EVariable(node.sourceRange, getText node))
            |> Stdlib.Result.Result.Ok

          | "if_expression" -> parseIfExpression node

          // fn calls
          | "infix_operation" -> parseInfixOperation node
          | "function_call" -> parseFunctionCall node

          | _ ->
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        /// this parses the 'container' of an expression
        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "expression" then
            match node.children with
            | [ single ] -> parseCase single
            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error
          elif node.typ == "paren_expression" then
            match findNodeByFieldName node "expr" with
            | Some exprNode -> parse exprNode
            | None ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error
          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


      module FunctionDeclaration =
        /// Parses a package function declaration parameter
        ///
        /// i.e. in `let foo (x: Int): ...`, this parses `(x: Int)`
        let parseFnDeclParam
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.FnDeclaration.Parameter, WrittenTypes.Unparseable> =
          if node.typ == "unit" then
            (WrittenTypes.FnDeclaration.UnitParameter { range = node.sourceRange })
            |> WrittenTypes.FnDeclaration.Parameter.Unit
            |> Stdlib.Result.Result.Ok

          elif node.typ == "fn_decl_param" then
            let nameNode =
              match findNodeByFieldName node "identifier" with
              | Some nameNode ->
                (Identifiers.parseVariable nameNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No identifier node found in fn_decl_param"

            let typNode =
              match findNodeByFieldName node "typ" with
              | Some typNode -> TypeReference.parse typNode
              | None ->
                Stdlib.Result.Result.Error "No typ node found in fn_decl_param"

            let symbolLeftParenNode =
              match findNodeByFieldName node "symbol_left_paren" with
              | Some symbolLeftParenNode ->
                (getRange symbolLeftParenNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No symbol_left_paren node found in fn_decl_param"

            let symbolColonNode =
              match findNodeByFieldName node "symbol_colon" with
              | Some symbolColonNode ->
                (getRange symbolColonNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No symbol_colon node found in fn_decl_param"

            let symbolRightParenNode =
              match findNodeByFieldName node "symbol_right_paren" with
              | Some symbolRightParenNode ->
                (getRange symbolRightParenNode) |> Stdlib.Result.Result.Ok
              | None ->
                Stdlib.Result.Result.Error
                  "No symbol_right_paren node found in fn_decl_param"

            match
              nameNode,
              typNode,
              symbolLeftParenNode,
              symbolColonNode,
              symbolRightParenNode
            with
            | Ok name,
              Ok typ,
              Ok symbolLeftParen,
              Ok symbolColon,
              Ok symbolRightParen ->
              (WrittenTypes.FnDeclaration.NormalParameter
                { range = node.sourceRange
                  name = name
                  typ = typ
                  symbolLeftParen = symbolLeftParen
                  symbolColon = symbolColon
                  symbolRightParen = symbolRightParen })
              |> WrittenTypes.FnDeclaration.Parameter.Normal
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error

          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error

        /// Parses a package function definition's parameters
        let parseParams
          (node: ParsedNode)
          : Stdlib.Result.Result<List<WrittenTypes.FnDeclaration.Parameter>, WrittenTypes.Unparseable> =
          if node.typ == "fn_decl_params" then
            let defs =
              Stdlib.List.fold
                node.children
                (Stdlib.Result.Result.Ok [])
                (fun defs param ->
                  match defs, parseFnDeclParam param with
                  | Ok defs, Ok fnDeclParam ->
                    (Stdlib.List.push defs fnDeclParam) |> Stdlib.Result.Result.Ok

                  | _ ->
                    (WrittenTypes.Unparseable { source = node })
                    |> Stdlib.Result.Result.Error)

            match defs with
            | Error _e -> defs
            | Ok defs -> (Stdlib.List.reverse defs) |> Stdlib.Result.Result.Ok
          else
            (WrittenTypes.Unparseable { source = node })
            |> Stdlib.Result.Result.Error


        /// Parses a package function declaration
        ///
        /// i.e. `let add (x: Int64) (y: Int64): Int64 = x + y`,
        ///
        /// - `add` is the function name
        /// - `x: Int` and `y: Int` are the parameters
        /// - `Int` is the return type
        /// - `x + y` is the body
        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.FnDeclaration.FnDeclaration, WrittenTypes.Unparseable> =
          if node.typ == "fn_decl" then
            let nameNode =
              match findNodeByFieldName node "name" with
              | Some nameNode ->
                (Identifiers.parseFn nameNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No name node found in fn_decl"

            let paramsNode =
              match findNodeByFieldName node "params" with
              | Some paramsNode -> parseParams paramsNode
              | None -> Stdlib.Result.Result.Error "No params node found in fn_decl"

            let returnTypeNode =
              match findNodeByFieldName node "return_type" with
              | Some returnTypeNode -> TypeReference.parse returnTypeNode
              | None -> Stdlib.Result.Result.Error "No return_type node"

            let bodyNode =
              match findNodeByFieldName node "body" with
              | Some bodyNode -> Expr.parse bodyNode
              | None -> Stdlib.Result.Result.Error "No body node found in fn_decl"

            let keywordLetNode =
              match findNodeByFieldName node "keyword_let" with
              | Some keywordLetNode ->
                (getRange keywordLetNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No keyword_let node found"

            let symbolColonNode =
              match findNodeByFieldName node "symbol_colon" with
              | Some symbolColonNode ->
                (getRange symbolColonNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No symbol_colon node found"

            let symbolEqualsNode =
              match findNodeByFieldName node "symbol_equals" with
              | Some symbolEqualsNode ->
                (getRange symbolEqualsNode) |> Stdlib.Result.Result.Ok
              | None -> Stdlib.Result.Result.Error "No symbol_equals node found"

            match
              nameNode,
              paramsNode,
              returnTypeNode,
              bodyNode,
              keywordLetNode,
              symbolColonNode,
              symbolEqualsNode
            with
            | Ok name,
              Ok params,
              Ok returnType,
              Ok body,
              Ok keywordLetNode,
              Ok symbolColonNode,
              Ok symbolEqualsNode ->
              (WrittenTypes.FnDeclaration.FnDeclaration
                { range = node.sourceRange
                  name = name
                  parameters = params
                  returnType = returnType
                  body = body
                  keywordLet = keywordLetNode
                  symbolColon = symbolColonNode
                  symbolEquals = symbolEqualsNode })
              |> Stdlib.Result.Result.Ok

            | _ ->
              (WrittenTypes.Unparseable { source = node })
              |> Stdlib.Result.Result.Error


      /// Map a ParsedNode to a WrittenTypes.ParsedFile
      ///
      /// This is the entrypoint for mapping a ParsedNode to WrittenTypes
      let parseCliScript
        (node: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.ParsedFile, String> =
        if node.typ == "source_file" then
          let init =
            WrittenTypes.CliScript
              { range = node.sourceRange
                typesAndFns = []
                unparseableStuff = []
                exprsToEval = [] }

          let result =
            node.children
            |> Stdlib.List.fold (Stdlib.Result.Result.Ok init) (fun result decl ->
              match result with
              | Error e -> Stdlib.Result.Result.Error e

              | Ok result ->
                match decl.typ with

                | "type_decl" ->
                  match TypeDeclaration.parse decl with
                  | Error e ->
                    { result with
                        unparseableStuff =
                          Stdlib.List.pushBack result.unparseableStuff e }
                    |> Stdlib.Result.Result.Ok

                  | Ok parsedTypeDef ->
                    let newType = WrittenTypes.CliScriptTypeOrFn.Type parsedTypeDef

                    { result with
                        typesAndFns =
                          Stdlib.List.pushBack result.typesAndFns newType }
                    |> Stdlib.Result.Result.Ok

                | "fn_decl" ->
                  match FunctionDeclaration.parse decl with
                  | Error e ->
                    { result with
                        unparseableStuff =
                          Stdlib.List.pushBack result.unparseableStuff e }
                    |> Stdlib.Result.Result.Ok

                  | Ok parsedFnDecl ->
                    let newFn = WrittenTypes.CliScriptTypeOrFn.Function parsedFnDecl

                    { result with
                        typesAndFns = Stdlib.List.pushBack result.typesAndFns newFn }
                    |> Stdlib.Result.Result.Ok

                | "expression" ->
                  match Expr.parse decl with
                  | Error e ->
                    { result with
                        unparseableStuff =
                          Stdlib.List.pushBack result.unparseableStuff e }
                    |> Stdlib.Result.Result.Ok
                  | Ok parsedExpr ->
                    { result with
                        exprsToEval =
                          Stdlib.List.pushBack result.exprsToEval parsedExpr }
                    |> Stdlib.Result.Result.Ok

                | _ ->
                  { result with
                      unparseableStuff =
                        Stdlib.List.pushBack
                          result.unparseableStuff
                          (WrittenTypes.Unparseable { source = decl }) }
                  |> Stdlib.Result.Result.Ok)

          match result with
          | Error e -> Stdlib.Result.Result.Error e
          | Ok result ->
            (WrittenTypes.ParsedFile.CliScript result) |> Stdlib.Result.Result.Ok

        else
          Stdlib.Result.Result.Error $"Not a source_file: {node.typ}"