module Darklang =
  module LanguageTools =
    module Parser =
      // TODO: these should be UInts of some size
      // (UInt8 might even be enough - how many lines are over 255chars?)
      type Point = { row: Int64; column: Int64 }

      type Range = { start: Point; end_: Point }

      type ParsedNode =
        {
          // e.g., a node of `typ` `let_epression` has a child node with a `body` field name
          fieldName: Stdlib.Option.Option<String>

          /// e.g. `source_file`, `fn_def`, `expression`, `let_expression`
          typ: String

          /// The text of this node as it was in the unparsed source code
          text: String

          /// Where in the source code is this node written/contained
          /// i.e. Line 1, Column 2 to Line 1, Column 5
          sourceRange: Range

          children: List<ParsedNode>
        }


      let parse (text: String) : ParsedNode =
        Builtin.Parser.parseToSimplifiedTree text


      // TODO: maybe re-frame this into expected/actual or something
      type ParseError =
        { sourceRange: Range
          sourceText: String
          message: String }

      // --------------------
      // Helper functions
      // --------------------

      let getText (node: ParsedNode) : String = node.text

      let findNodeByFieldName
        (node: ParsedNode)
        (fieldName: String)
        : Stdlib.Option.Option<ParsedNode> =
        let filteredChildren =
          node.children
          |> Stdlib.List.filter (fun c ->
            match c.fieldName with
            | Some fName -> fName == fieldName
            | None -> false)

        match filteredChildren with
        | [ c ] -> Stdlib.Option.Option.Some c

        | [] -> Stdlib.Option.Option.None
        | _ -> Stdlib.Option.Option.None // TODO: this should error, there are multiple matches



      // --------------------
      // Parsing to WrittenTypes
      // --------------------

      let parseTypeReference
        (node: ParsedNode)
        : Stdlib.Option.Option<WrittenTypes.TypeReference> =
        if node.typ == "type" then
          match (getText node) with
          | "Unit" ->
            (WrittenTypes.TypeReference.TInt64(node.sourceRange))
            |> Stdlib.Option.Option.Some

          | "Int" ->
            (WrittenTypes.TypeReference.TInt64(node.sourceRange))
            |> Stdlib.Option.Option.Some

          | "Bool" ->
            (WrittenTypes.TypeReference.TBool(node.sourceRange))
            |> Stdlib.Option.Option.Some

          | "Float" ->
            (WrittenTypes.TypeReference.TFloat(node.sourceRange))
            |> Stdlib.Option.Option.Some

          | "String" ->
            (WrittenTypes.TypeReference.TString(node.sourceRange))
            |> Stdlib.Option.Option.Some

          | "Char" ->
            (WrittenTypes.TypeReference.TChar(node.sourceRange))
            |> Stdlib.Option.Option.Some

          | _ -> Stdlib.Option.Option.None

        else if node.typ == "qualified_name" then
          let parts =
            node.children
            |> Stdlib.List.filter (fun c -> c.typ == "identifier")
            |> Stdlib.List.map (fun c -> c.text)


          (WrittenTypes.TypeReference.TCustomType(
            WrittenTypes.Name.Unresolved(node.sourceRange, parts),
            []
          ))
          |> Stdlib.Option.Option.Some
        else
          Stdlib.Option.Option.None // TODO: error?


      /// this parses one of the Expr cases
      let parseExprCase
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.Expr, String> =
        match parsed.typ with
        | "identifier" ->
          (WrittenTypes.Expr.EVariable(parsed.sourceRange, getText parsed))
          |> Stdlib.Result.Result.Ok

        | "infix_operation" ->
          let leftArg =
            (findNodeByFieldName parsed "left")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          let operatorText =
            (findNodeByFieldName parsed "operator") |> Builtin.unwrap |> getText

          let rightArg =
            (findNodeByFieldName parsed "right")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          // TODO: revisit error-handling
          let operator =
            match operatorText with
            | "+" ->
              WrittenTypes.Infix.InfixFnCall(WrittenTypes.InfixFnName.ArithmeticPlus)
            | "-" ->
              WrittenTypes.Infix.InfixFnCall(
                WrittenTypes.InfixFnName.ArithmeticMinus
              )
            | _ -> Stdlib.Result.Result.Error "TODO : operator not implemented"

          (WrittenTypes.Expr.EInfix(parsed.sourceRange, operator, leftArg, rightArg))
          |> Stdlib.Result.Result.Ok


        | "let_expression" ->
          let identifierNode =
            (findNodeByFieldName parsed "identifier") |> Builtin.unwrap

          let expr =
            (findNodeByFieldName parsed "expr")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          let body =
            (findNodeByFieldName parsed "body")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          (WrittenTypes.Expr.ELet(
            parsed.sourceRange,
            WrittenTypes.LetPattern.LPVariable(
              identifierNode.sourceRange,
              identifierNode.text
            ),
            expr,
            body
          ))
          |> Stdlib.Result.Result.Ok


        // TODO: This is not tested yet
        | "function_call" ->
          Stdlib.Result.Result.Error "TODO : function_call not implemented"


        | uncaughtType ->
          Stdlib.Result.Result.Error
            $"TODO : parseExprCase {uncaughtType} not implemented"


      /// this parses the 'container' of an expression
      let parseExpr
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.Expr, String> =
        if parsed.typ == "expression" then
          match parsed.children with
          | [ single ] -> parseExprCase single
          | _ -> Stdlib.Result.Result.Error "Not a single expression"
        else
          Stdlib.Result.Result.Error $"Not an expression: {parsed.typ}"



      /// Parses a package function definiti;on parameter
      ///
      /// i.e. in `fn foo(x: Int)`, this parses `x: Int`
      let parseFnDefParam
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.PackageFn.Parameter, String> =
        if parsed.typ == "fn_param_def" then
          let name =
            (findNodeByFieldName parsed "identifier") |> Builtin.unwrap |> getText

          let typ =
            (findNodeByFieldName parsed "typ")
            |> Builtin.unwrap
            |> parseTypeReference
            |> Builtin.unwrap

          (WrittenTypes.PackageFn.Parameter
            { sourceRange = parsed.sourceRange
              name = name
              typ = typ
            //description = ""
            })
          |> Stdlib.Result.Result.Ok

        else
          Stdlib.Result.Result.Error "Not a fn_param_def"


      /// Parses a package function definition's parameters
      ///
      /// i.e. in `fn add(x: Int, y: Int)`, this parses `x: Int, y: Int`
      let parseFnDefParams
        (parsed: ParsedNode)
        : Stdlib.Result.Result<List<WrittenTypes.PackageFn.Parameter>, String> =
        if parsed.typ == "fn_params_def" then
          let defs =
            Stdlib.List.fold
              parsed.children
              (Stdlib.Result.Result.Ok [])
              (fun defs param ->
                match defs with
                | Error e -> Stdlib.Result.Result.Error e

                | Ok defs ->
                  match parseFnDefParam param with
                  | Error e -> Stdlib.Result.Result.Error e

                  | Ok parsed ->
                    Stdlib.Result.Result.Ok(Stdlib.List.push defs parsed))

          match defs with
          | Error _e -> defs
          | Ok defs -> Stdlib.Result.Result.Ok(Stdlib.List.reverse defs)
        else
          Stdlib.Result.Result.Error "Not a fn_params_def"


      /// Parses a package function definition
      ///
      /// i.e. `let add (x: Int) (y: Int) = x + y`,
      ///
      /// - `add` is the function name
      /// - `x: Int` and `y: Int` are the parameters
      /// - `x + y` is the body
      /// - `Int` is the return type
      let parsePackageFnDef
        (parsed: ParsedNode)
        : Stdlib.Result.Result<List<WrittenTypes.PackageFn.PackageFn>, String> =
        if parsed.typ == "fn_def" then
          let nameNode = parsed |> findNodeByFieldName "name" |> Builtin.unwrap

          let parameters =
            (findNodeByFieldName parsed "params")
            |> Builtin.unwrap
            |> parseFnDefParams
            |> Builtin.unwrap

          let returnType =
            (findNodeByFieldName parsed "return_type")
            |> Builtin.unwrap
            |> parseTypeReference
            |> Builtin.unwrap

          let body =
            (findNodeByFieldName parsed "body")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          (WrittenTypes.PackageFn.PackageFn
            { sourceRange = parsed.sourceRange
              name =
                WrittenTypes.Name.Unresolved(nameNode.sourceRange, [ nameNode.text ])
              //typeParams = []
              parameters = parameters
              returnType = returnType
              body = body
            //description = ""
            })
          |> Stdlib.Result.Result.Ok
        else
          Stdlib.Result.Result.Error parsed

      let parsePackageTypeDef
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.PackageType, String> =
        if parsed.typ == "type_def" then
          let nameNode = parsed |> findNodeByFieldName "name" |> Builtin.unwrap

          let typ =
            (findNodeByFieldName parsed "typ")
            |> Builtin.unwrap
            |> parseTypeReference
            |> Builtin.unwrap


          (WrittenTypes.PackageType
            { sourceRange = parsed.sourceRange
              name =
                WrittenTypes.Name.Unresolved(nameNode.sourceRange, [ nameNode.text ])
              declaration =
                WrittenTypes.TypeDeclaration.TypeDeclaration
                  {
                    // typeParams = []
                    definition =
                      PACKAGE
                        .Darklang
                        .LanguageTools
                        .WrittenTypes
                        .TypeDeclaration
                        .Definition
                        .Alias(typ) }
            //description = ""
            })

          |> Stdlib.Result.Result.Ok
        else
          Stdlib.Result.Result.Error parsed


      /// Currently, all "source files"
      /// are just a list of package function definitions and type definitions
      ///
      /// TODO^
      let parseNodeToWrittenTypesSourceFile
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.ParsedFile, String> =
        if parsed.typ == "source_file" then
          match parsed.children with
          | [] -> Stdlib.Result.Result.Ok(fnDefs, typeDefs)
          | child :: rest ->
            match child.typ with
            | "fn_def" ->
              let packageFnDefs =
                Stdlib.List.fold
                  parsed.children
                  (Stdlib.Result.Result.Ok [])
                  (fun defs packageFnDef ->
                    match defs with
                    | Error e -> Stdlib.Result.Result.Error e

                    | Ok defs ->
                      match parsePackageFnDef packageFnDef with
                      | Error e -> Stdlib.Result.Result.Error e
                      | Ok parsed ->
                        Stdlib.Result.Result.Ok(Stdlib.List.push defs parsed))

              match packageFnDefs with
              | Error e -> Stdlib.Result.Result.Error e
              | Ok packageFnDefs ->
                (WrittenTypes.ParsedFile.PackageItems(
                  parsed.sourceRange,
                  Stdlib.List.reverse packageFnDefs
                ))
                |> Stdlib.Result.Result.Ok

            | "type_def" ->
              let typeDefs =
                Stdlib.List.fold
                  parsed.children
                  (Stdlib.Result.Result.Ok [])
                  (fun defs typeDef ->
                    match defs with
                    | Error e -> Stdlib.Result.Result.Error e

                    | Ok defs ->
                      match parsePackageTypeDef typeDef with
                      | Error e -> Stdlib.Result.Result.Error e
                      | Ok parsed ->
                        Stdlib.Result.Result.Ok(Stdlib.List.push defs parsed))

              match typeDefs with
              | Error e -> Stdlib.Result.Result.Error e
              | Ok typeDefs ->
                (WrittenTypes.ParsedFile.PackageItems(
                  parsed.sourceRange,
                  Stdlib.List.reverse typeDefs
                ))
                |> Stdlib.Result.Result.Ok

            | _ -> Stdlib.Result.Result.Error $"TODO : {child.typ} not implemented"