module Darklang =
  module LanguageTools =
    module Parser =
      type Point = { row: Int64; column: Int64 }

      type Range = { start: Point; end_: Point }

      type ParsedNode =
        {
          // e.g., a node of `typ` `let_epression` has a child node with a `body` field name
          fieldName: Stdlib.Option.Option<String>

          /// e.g. `source_file`, `fn_def`, `expression`, `let_expression`
          typ: String

          /// The text of this node as it was in the unparsed source code
          text: String

          /// Where in the source code is this node written/contained
          /// i.e. Line 1, Column 2 to Line 1, Column 5
          sourceRange: Range

          children: List<ParsedNode>
        }


      let parse (text: String) : ParsedNode =
        Builtins.LanguageTools.Parser.parse text

      // --------------------
      // Helper functions
      // --------------------

      let getText (node: ParsedNode) : String = node.text

      let findNodeByFieldName
        (node: ParsedNode)
        (fieldName: String)
        : Stdlib.Option.Option<ParsedNode> =
        let children = node.children

        let filteredChildren =
          children
          |> Stdlib.List.filter (fun c ->
            match c.fieldName with
            | Some fName -> fName == fieldName
            | None -> false)

        match filteredChildren with
        | [ c ] -> Stdlib.Option.Option.Some c
        | [] -> Stdlib.Option.Option.None
        | _ -> Stdlib.Option.Option.None // TODO: this should error, there are multiple matches

      let stringToPackage (str: String) : ProgramTypes.FQName.Package =
        let name = ProgramTypes.FnName.Name.FnName str

        ProgramTypes.FQName.Package
          { owner = "TODO"
            modules = [ "TODO" ]
            name = name
            version = 0L }


      // --------------------
      // Parsing to WrittenTypes
      // --------------------

      // TODO: support more types
      type WTTypeReference =
        | TInt64
        | TBool
        | TString

      let parseTypeReference
        (node: ParsedNode)
        : Stdlib.Option.Option<WTTypeReference> =
        // TODO: support more types
        let typ = node.typ

        if typ == "type" then
          match (getText node) with
          | "Int" -> Stdlib.Option.Option.Some WrittenTypes.TypeReference.TInt64
          | "Int64" -> Stdlib.Option.Option.Some WrittenTypes.TypeReference.TInt64
          | "Bool" -> Stdlib.Option.Option.Some WrittenTypes.TypeReference.TBool
          | "String" -> Stdlib.Option.Option.Some WrittenTypes.TypeReference.TString
          | _ -> Stdlib.Option.Option.None
        else
          Stdlib.Option.Option.None // this should return and error?


      let parseExprCase
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.Expr, String> =
        match parsed.typ with
        | "identifier" ->
          Stdlib.Result.Result.Ok(WrittenTypes.Expr.EVariable(0L, getText parsed))
        | "infix_operation" ->
          let left =
            (findNodeByFieldName parsed "left")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          let right =
            (findNodeByFieldName parsed "right")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          let operatorNode =
            (findNodeByFieldName parsed "operator") |> Builtin.unwrap

          let operatorText = getText operatorNode

          let operator =
            match operatorText with
            | "+" ->
              WrittenTypes.Infix.InfixFnCall(WrittenTypes.InfixFnName.ArithmeticPlus)
            | "-" ->
              WrittenTypes.Infix.InfixFnCall(
                WrittenTypes.InfixFnName.ArithmeticMinus
              )
            | _ -> Stdlib.Result.Result.Error "TODO : operator not implemented"

          Stdlib.Result.Result.Ok(
            WrittenTypes.Expr.EInfix(0L, operator, left, right)
          )

        | "let_expression" ->
          let identifier =
            (findNodeByFieldName parsed "identifier") |> Builtin.unwrap |> getText

          let expr =
            (findNodeByFieldName parsed "expr")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          let body =
            (findNodeByFieldName parsed "body")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          Stdlib.Result.Result.Ok(
            WrittenTypes.Expr.ELet(
              0L,
              WrittenTypes.LetPattern.LPVariable(0L, identifier),
              expr,
              body
            )
          )

        // TODO: This is not tested yet
        | "function_call" ->
          let fnName = (findNodeByFieldName parsed "fn") |> Builtin.unwrap |> getText

          let args =
            (findNodeByFieldName parsed "args")
            |> Builtin.unwrap
            |> Stdlib.List.map (fun arg -> (parseExpr arg) |> Builtin.unwrap)

          let fnCallExpr =
            WrittenTypes.Expr.EApply(
              0L,
              WrittenTypes.Expr.EFnName(
                0L,
                WrittenTypes.Name.Unresolved [ "Darklang"; "Stdlib"; "Int"; fnName ]
              ),
              [],
              args
            )

          Stdlib.Result.Result.Ok(fnCallExpr)
        | _ -> Stdlib.Result.Result.Error "TODO : parseExprCase not implemented"


      let parseExpr
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.Expr, String> =
        if parsed.typ == "expression" then
          match parsed.children with
          | [ single ] -> parseExprCase single
          | _ -> Stdlib.Result.Result.Error "Not a single expression"
        else
          Stdlib.Result.Result.Error "Not an expression"


      let parseNodeToWT
        (parsed: ParsedNode)
        : Stdlib.Result.Result<List<WrittenTypes.PackageFn.PackageFn>, String> =
        if parsed.typ == "source_file" then
          match parsed.children with
          | [ fnDef ] -> parsePackageFn fnDef
          | _ -> Stdlib.Result.Result.Error "Not a single fn_def"
        else
          Stdlib.Result.Result.Error "Not a source_file"


      let parsePackageFn
        (parsed: ParsedNode)
        : Stdlib.Result.Result<List<WrittenTypes.PackageFn.PackageFn>, String> =
        if parsed.typ == "fn_def" then
          let parameters =
            match (findNodeByFieldName parsed "params") with
            | Some p -> (parseFnParams p) |> Builtin.unwrap
            | None -> Stdlib.Result.Result.Error "No params"

          let body =
            (findNodeByFieldName parsed "body")
            |> Builtin.unwrap
            |> parseExpr
            |> Builtin.unwrap

          let returnType =
            (findNodeByFieldName parsed "return_type")
            |> Builtin.unwrap
            |> parseTypeReference
            |> Builtin.unwrap

          let name =
            ((findNodeByFieldName parsed "name") |> Builtin.unwrap |> getText)
            |> stringToPackage

          Stdlib.Result.Result.Ok
            [ WrittenTypes.PackageFn.PackageFn
                { name = name
                  body = body
                  typeParams = []
                  parameters = parameters
                  returnType = returnType
                  description = "" } ]
        else
          Stdlib.Result.Result.Error parsed


      let parseFnParams
        (parsed: ParsedNode)
        : Stdlib.Result.Result<List<WrittenTypes.PackageFn.Parameter>, String> =
        if parsed.typ == "fn_params_def" then
          let parameters =
            parsed.children
            |> Stdlib.List.map (fun p -> (parseFnParam p) |> Builtin.unwrap)

          Stdlib.Result.Result.Ok parameters
        else
          Stdlib.Result.Result.Error "Not a fn_params_def"


      let parseFnParam
        (parsed: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.PackageFn.Parameter, String> =
        if parsed.typ == "fn_param_def" then
          Stdlib.Result.Result.Ok(
            WrittenTypes.PackageFn.Parameter
              { name =
                  (findNodeByFieldName parsed "identifier")
                  |> Builtin.unwrap
                  |> getText
                typ =
                  (findNodeByFieldName parsed "typ")
                  |> Builtin.unwrap
                  |> parseTypeReference
                  |> Builtin.unwrap
                description = "" }
          )
        else
          Stdlib.Result.Result.Error "Not a fn_param_def"