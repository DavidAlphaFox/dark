module Darklang =
  module LanguageTools =
    module RuntimeErrors =
      module ErrorSegment =
        /// ---------------
        /// Error pretty printing
        /// CLEANUP: should be moved into Dark code ASAP, and we should return error types instead
        /// ---------------
        /// Segments allow us to build error messages where the UI and CLI can both
        /// decorate/link to the sources in a native way
        type ErrorSegment =
          // -- Basic types
          | String of String
          | Int of Int
          | Ordinal of Int // 1st, 2nd, etc
          | IndefiniteArticle // "a" or "an" (chosen based on the next segment)

          // -- Functions
          | FunctionName of PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.FnName
          /// Description from StdLib description fields.
          /// Has markers like <param name>, that should be parsed and displayed (TODO: why parse?)
          | Description of String
          | ParamName of String
          | InlineParamName of String

          // -- Types
          | TypeName of PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName
          | ShortTypeName of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName
          | TypeReference of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference
          | TypeOfValue of PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval
          | FieldName of String // records and enums
          | InlineFieldName of String // records and enums

          // -- Variables
          | DBName of String
          | VarName of String
          | InlineVarName of String

          // -- Dvals
          | InlineValue of PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval // possibly shortened to be shown inline
          | FullValue of PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval

        let toString (list: List<ErrorSegment>) : String =
          list
          |> PACKAGE.Darklang.Stdlib.List.reverse
          |> List.fold
            (fun prevSegments segment ->
              let newSegment =
                match segment with
                | String s -> s
                | Int i -> Int.toString i
                // | Ordinal i -> String.toOrdinal i
                // | IndefiniteArticle ->
                //   match List.tryHead prevSegments with
                //   | None -> ""
                //   | Some prev -> String.articleFor prev ++ " "
                // | FunctionName fn -> FnName.toString fn
                | Description d -> d
                | ParamName p -> "`" ++ p ++ "`"
                // Inline versions don't have quotes
                | InlineParamName p -> p
                // | TypeName t -> TypeName.toString t
                // | ShortTypeName t -> TypeName.toShortName t
                // | TypeReference t -> DvalReprDeveloper.typeName t
                // | TypeOfValue dv -> dv |> DvalReprDeveloper.toTypeName
                | FieldName f -> "`" ++ f ++ "`"
                | InlineFieldName f -> f
                | DBName db -> db
                | VarName v -> "`" ++ v ++ "`"
                | InlineVarName v -> v
                // | InlineValue dv ->
                //   (DvalReprDeveloper.toRepr dv)
                //   |> String.truncateWithElipsis 10
                //   |> String.splitOnNewline
                //   |> String.join ""
                // | FullValue dv -> DvalReprDeveloper.toRepr dv
                | segment ->
                  $"TODO ({(Json.serialize<ErrorSegment> segment) |> unwrap})"

              PACKAGE.Darklang.Stdlib.List.push prevSegments newSegment)
            []
          |> String.join ""






      /// The result of Exception.raiseInternal
      type ExceptionThrown =
        { stackTrace: String
          message: String
          metadata: List<String * String> }


      type ErrorOutput =
        { summary: List<ErrorSegment.ErrorSegment>
          // Summary can be used on its own or concatenated with extraExplanation
          extraExplanation: List<ErrorSegment.ErrorSegment>
          actual: List<ErrorSegment.ErrorSegment>
          expected: List<ErrorSegment.ErrorSegment> }

      type Error =
        | CliError of PACKAGE.Darklang.LanguageTools.RuntimeErrors.Cli.Error
        | TypeCheckerError of
          PACKAGE.Darklang.LanguageTools.RuntimeErrors.TypeChecker.Error
        | NameResolutionError of
          PACKAGE.Darklang.LanguageTools.RuntimeErrors.NameResolution.Error
        | OldStringErrorTODO of String
        | ExceptionThrown of ExceptionThrown

      module Error =
        // TODO: move most of the logic here to the individual modules,
        // and then follow up here
        //
        let toSegments (e: Error) : ErrorOutput =
          //   match e with

          //   | NameResolutionError({ errorType = NameResolution.NotFound } as e) ->
          //     let nameType =
          //       match e.nameType with
          //       | NameResolution.Function -> "function"
          //       | NameResolution.Type -> "type"
          //       | NameResolution.Constant -> "constant"

          //     let summary =
          //       [ String $"There is no {nameType} named "
          //         InlineVarName(String.join "." e.names) ]

          //     let extraExplanation = []
          //     let actual = []
          //     let expected = []

          //     { summary = summary
          //       extraExplanation = extraExplanation
          //       actual = actual
          //       expected = expected }

          //   | NameResolutionError({ errorType = NameResolution.MissingModuleName } as e) ->
          //     let suffix =
          //       if e.names = [] then
          //         []
          //       else
          //         [ String ": "; VarName(String.join "." e.names) ]
          //     let summary = [ String "Missing module name" ] @ suffix

          //     let extraExplanation = []
          //     let actual = []
          //     let expected = []

          //     { summary = summary
          //       extraExplanation = extraExplanation
          //       actual = actual
          //       expected = expected }

          //   | NameResolutionError({ errorType = NameResolution.InvalidPackageName } as e) ->
          //     let summary =
          //       [ String "Invalid package name "; InlineVarName(String.join "." e.names) ]

          //     let extraExplanation = []
          //     let actual = []
          //     let expected = []

          //     { summary = summary
          //       extraExplanation = extraExplanation
          //       actual = actual
          //       expected = expected }
          // TODO: replace with a real error from above
          ErrorOutput
            { summary = []
              extraExplanation = []
              actual = []
              expected = [] }

        let toString (e: Error) : String =
          let s = toSegments e
          let explanation = ErrorSegment.toString (s.summary @ s.extraExplanation)
          let actual = ErrorSegment.toString s.actual
          let actual = if actual = "" then "" else "\nActual: " ++ actual
          let expected = ErrorSegment.toString s.expected
          let expected = if expected = "" then "" else "\nExpected: " ++ expected

          if actual = "" && expected = "" then
            explanation
          else
            $"{explanation}\n{expected}{actual}"