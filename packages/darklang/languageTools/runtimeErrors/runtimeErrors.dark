module Darklang =
  module LanguageTools =
    module RuntimeErrors =
      module ErrorSegment =
        /// ---------------
        /// Error pretty printing
        /// CLEANUP: should be moved into Dark code ASAP, and we should return error types instead
        /// ---------------
        /// Segments allow us to build error messages where the UI and CLI can both
        /// decorate/link to the sources in a native way
        type ErrorSegment =
          // -- Basic types
          | String of String
          | Int of Int
          | Ordinal of Int // 1st, 2nd, etc
          | IndefiniteArticle // "a" or "an" (chosen based on the next segment)

          // -- Functions
          | FunctionName of PACKAGE.Darklang.LanguageTools.RuntimeTypes.FnName.FnName
          /// Description from StdLib description fields.
          /// Has markers like <param name>, that should be parsed and displayed (TODO: why parse?)
          | Description of String
          | ParamName of String
          | InlineParamName of String

          // -- Types
          | TypeName of PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName
          | ShortTypeName of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName // Just the last bit of the TypeName, eg Result vs PACKAGE.Darklang.Stdlib.Result.Result
          | TypeReference of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference // another .TR?
          | TypeOfValue of PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval
          | FieldName of String // records and enums
          | InlineFieldName of String // records and enums


          // -- Variables
          | DBName of String
          | VarName of String
          | InlineVarName of String

          // -- Dvals
          | InlineValue of PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval // possibly shortened to be shown inline
          | FullValue of PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval.Dval

        let toString (list: List<ErrorSegment>) : String =
          list
          |> List.rev
          |> List.fold
            (fun prevSegments segment ->
              let newSegment =
                match segment with
                | String s -> s
                | Int i -> string i
                | Ordinal i -> String.toOrdinal i
                | IndefiniteArticle ->
                  match List.tryHead prevSegments with
                  | None -> ""
                  | Some prev -> String.articleFor prev + " "
                | FunctionName fn -> FnName.toString fn
                | Description d -> d
                | ParamName p -> "`" + p + "`"
                // Inline versions don't have quotes
                | InlineParamName p -> p
                | TypeName t -> TypeName.toString t
                | ShortTypeName t -> TypeName.toShortName t
                | TypeReference t -> DvalReprDeveloper.typeName t
                | TypeOfValue dv -> dv |> DvalReprDeveloper.toTypeName
                | FieldName f -> "`" + f + "`"
                | InlineFieldName f -> f
                | DBName db -> db
                | VarName v -> "`" + v + "`"
                | InlineVarName v -> v
                | InlineValue dv ->
                  (DvalReprDeveloper.toRepr dv)
                  |> String.truncateWithElipsis 10
                  |> String.splitOnNewline
                  |> String.concat ""
                | FullValue dv -> DvalReprDeveloper.toRepr dv

              newSegment :: prevSegments)
            []
          |> String.concat ""






      /// The result of Exception.raiseInternal
      type ExceptionThrown =
        // ish
        { stackTrace: string
          message: string
          metadata: List<string * string> }


      type ErrorOutput =
        { summary: List<ErrorSegment>
          // Summary can be used on its own or concatenated with extraExplanation
          extraExplanation: List<ErrorSegment>
          actual: List<ErrorSegment>
          expected: List<ErrorSegment> }

      type Error =
        | CliError of PACKAGE.Darklang.LanguageTools.RuntimeErrors.Cli.Error
        | TypeError of PACKAGE.Darklang.LanguageTools.RuntimeErrors.Error
        | NameResolutionError of
          PACKAGE.Darklang.LanguageTools.RuntimeErrors.NameResolution.Error // TODO: PACAKGE....
        | UnorganizedStringTODO of String
      //| ExceptionThrown of ExceptionThrown

      module Error =
        // TODO: move most of the logic here to the individual modules,
        // and then follow up here
        //
        let toSegments (e: Error) : ErrorOutput =
          //   match e with

          //   | NameResolutionError({ errorType = NameResolution.NotFound } as e) ->
          //     let nameType =
          //       match e.nameType with
          //       | NameResolution.Function -> "function"
          //       | NameResolution.Type -> "type"
          //       | NameResolution.Constant -> "constant"

          //     let summary =
          //       [ String $"There is no {nameType} named "
          //         InlineVarName(String.concat "." e.names) ]

          //     let extraExplanation = []
          //     let actual = []
          //     let expected = []

          //     { summary = summary
          //       extraExplanation = extraExplanation
          //       actual = actual
          //       expected = expected }

          //   | NameResolutionError({ errorType = NameResolution.MissingModuleName } as e) ->
          //     let suffix =
          //       if e.names = [] then
          //         []
          //       else
          //         [ String ": "; VarName(String.concat "." e.names) ]
          //     let summary = [ String "Missing module name" ] @ suffix

          //     let extraExplanation = []
          //     let actual = []
          //     let expected = []

          //     { summary = summary
          //       extraExplanation = extraExplanation
          //       actual = actual
          //       expected = expected }

          //   | NameResolutionError({ errorType = NameResolution.InvalidPackageName } as e) ->
          //     let summary =
          //       [ String "Invalid package name "; InlineVarName(String.concat "." e.names) ]

          //     let extraExplanation = []
          //     let actual = []
          //     let expected = []

          //     { summary = summary
          //       extraExplanation = extraExplanation
          //       actual = actual
          //       expected = expected }
          []

        let toString (e: Error) : String =
          let s = toSegments e
          let explanation = ErrorSegment.toString (s.summary @ s.extraExplanation)
          let actual = ErrorSegment.toString s.actual
          let actual = if actual = "" then "" else "\nActual: " + actual
          let expected = ErrorSegment.toString s.expected
          let expected = if expected = "" then "" else "\nExpected: " + expected

          if actual = "" && expected = "" then
            explanation
          else
            $"{explanation}\n{expected}{actual}"