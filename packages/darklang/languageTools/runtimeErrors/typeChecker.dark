module Darklang =
  module LanguageTools =
    module RuntimeErrors =
      module TypeChecker =
        type Location = Option<Darklang.LanguageTools.TLID * ID>

        type Context =
          | FunctionCallParameter of
            fnName: Darklang.LanguageTools.RuntimeTypes.FnName.FnName *
            parameter: Darklang.LanguageTools.RuntimeTypes.BuiltInParam *  // TODO should probbaly just be Param?
            paramIndex: Int *
            location: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Location

          | FunctionCallResult of
            fnName: FnName.FnName *
            returnType: Darklang.LanguageTools.RuntimeTypes.TypeReference *
            location: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Location

          | RecordField of
            recordTypeName: TypeName.TypeName *
            fieldName: String *
            fieldType: Darklang.LanguageTools.RuntimeTypes.TypeReference *
            location: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Location

          | DictKey of
            key: String *
            typ:
              (Darklang.LanguageTools.RuntimeTypes.TypeReference *
              Darklang.LanguageTools.RuntimeErrors.TypeChecker.Location)

          | EnumField of
            enumTypeName: TypeName.TypeName *
            caseName: String *
            fieldIndex: Int *  // nth argument to the enum constructor
            fieldCount: Int *
            fieldType: Darklang.LanguageTools.RuntimeTypes.TypeReference *
            location: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Location

          | DBQueryVariable of
            varName: String *
            expected: Darklang.LanguageTools.RuntimeTypes.TypeReference *
            location: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Location

          | DBSchemaType of
            name: String *
            expectedType: Darklang.LanguageTools.RuntimeTypes.TypeReference *
            location: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Location

          | ListIndex of
            index: Int *
            listTyp: Darklang.LanguageTools.RuntimeTypes.TypeReference *
            parent: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Context

          | TupleIndex of
            index: Int *
            elementType: Darklang.LanguageTools.RuntimeTypes.TypeReference *
            parent: Darklang.LanguageTools.RuntimeErrors.TypeChecker.Context


        type Error =
          //| VTTODOMismatchedType of String
          //| VTTODOMergedValueTypeWrapper of Darklang.LanguageTools.RuntimeTypes.Dval.SomeErrorType

          | ValueNotExpectedType of
            actualValue: PACKAGE.Darklang.LanguageTools.RuntimeTypes.Dval *
            expectedType: PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference *
            PACKAGE.Darklang.LanguageTools.RuntimeErrors.TypeChecker.Context

          | TypeDoesntExist of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName *
            Darklang.LanguageTools.RuntimeErrors.TypeChecker.Context

        module Error =
          // let rec valuePath (context : TCK.Context) : string =
          //   match context with
          //   | TCK.FunctionCallParameter(_, parameter, _, _) -> parameter.name
          //   | TCK.FunctionCallResult(_, _, _) -> "result"
          //   | TCK.RecordField(_, fieldName, _, _) -> fieldName
          //   | TCK.DictKey(key, _, _) -> $".{key}"
          //   | TCK.EnumField(_, caseName, _, _, _, _) -> caseName
          //   | TCK.DBSchemaType(dbName, _, _) -> dbName
          //   | TCK.DBQueryVariable(varName, _, _) -> varName
          //   | TCK.ListIndex(index, _, parent) -> valuePath parent + $"[{index}]"
          //   | TCK.TupleIndex(index, _, parent) -> valuePath parent + $"[{index}]"

          // let rec rootContext (context : TCK.Context) : TCK.Context =
          //   match context with
          //   | TCK.FunctionCallParameter _ -> context
          //   | TCK.FunctionCallResult _ -> context
          //   | TCK.RecordField _ -> context
          //   | TCK.DictKey _ -> context
          //   | TCK.EnumField _ -> context
          //   | TCK.DBSchemaType _ -> context
          //   | TCK.DBQueryVariable _ -> context
          //   | TCK.ListIndex(_, _, parent) -> rootContext parent
          //   | TCK.TupleIndex(_, _, parent) -> rootContext parent


          // // Return the segments describing the context as a short name, used in the description of errors
          // let rec contextSummary (context : TCK.Context) : List<ErrorSegment> =
          //   match context with
          //   | TCK.FunctionCallParameter(fnName, parameter, paramIndex, _) ->
          //     [ FunctionName fnName
          //       String "'s "
          //       Ordinal(paramIndex + 1)
          //       String " argument ("
          //       ParamName parameter.name
          //       String ")" ]
          //   | TCK.FunctionCallResult(fnName, returnType, _) ->
          //     [ FunctionName fnName; String "'s return value" ]
          //   | TCK.RecordField(recordType, fieldName, _, _) ->
          //     [ TypeName recordType; String "'s "; FieldName fieldName; String " field" ]
          //   | TCK.DictKey(key, _, _) ->
          //     let typeName =
          //       FQName.BuiltIn { name = TypeName.TypeName "Dict"; modules = []; version = 0 }
          //     [ TypeName typeName; String "'s "; FieldName key; String " value" ]
          //   | TCK.EnumField(enumType, caseName, fieldIndex, _, _, _) ->
          //     [ TypeName enumType
          //       String "."
          //       InlineFieldName caseName
          //       String "'s "
          //       Ordinal(fieldIndex + 1)
          //       String " argument" ]

          //   | TCK.DBSchemaType(dbName, expectedType, _) ->
          //     [ String "DB "; DBName dbName; String "'s value" ]
          //   | TCK.DBQueryVariable(varName, _, _) -> [ String "Variable "; VarName varName ]
          //   | TCK.TupleIndex(index, typ, parent)
          //   | TCK.ListIndex(index, typ, parent) ->
          //     let rootContext = rootContext parent
          //     [ String "In " ]
          //     @ contextSummary rootContext
          //     @ [ String ", the nested value "; VarName(valuePath context) ]

          // let rec contextAsActualExpected
          //   (argument : Dval)
          //   (context : TCK.Context)
          //   : List<ErrorSegment> * List<ErrorSegment> =

          //   // TODO: We do actual and expected in the same function so that we can display
          //   // them the same way. This hasn't been ported for all Context types, but
          //   // should be.
          //   let defaultActual =
          //     [ IndefiniteArticle; TypeOfValue argument; String ": "; FullValue argument ]

          //   match context with
          //   | TCK.FunctionCallParameter(fnName, parameter, paramIndex, _) ->
          //     // format:
          //     // (json : string) // some description
          //     let comment =
          //       if "" (* TODO parameter.comment*) = "" then
          //         []
          //       else
          //         [ String " // "; Description "" (*parameter.comment*) ]
          //     (defaultActual,
          //     [ String "("
          //       InlineParamName parameter.name
          //       String ": "
          //       TypeReference parameter.typ
          //       String ")" ]
          //     @ comment)


          //   | TCK.FunctionCallResult(fnName, returnType, _) ->
          //     // format:
          //     // Option<String>
          //     defaultActual, [ TypeReference returnType ]


          //   | TCK.RecordField(recordType, fieldName, fieldType, _) ->
          //     // format:
          //     // TODO: fetch the type and lookup the field definition as a comment
          //     let comment = []
          //     // ({ name : string; ... }) // some description
          //     // let comment =
          //     //   if fieldDef.description = "" then
          //     //     []
          //     //   else
          //     //     [ String " // "; Description fieldDef.description ]

          //     defaultActual,
          //     ([ String "({ "
          //       InlineFieldName fieldName
          //       String ": "
          //       TypeReference fieldType
          //       String "; ... })" ]
          //     @ comment)


          //   | TCK.DictKey(key, typ, _) ->
          //     // format:
          //     // ({ "name" : String; ... })
          //     defaultActual,
          //     ([ String "({ "
          //       InlineFieldName key
          //       String ": "
          //       TypeReference typ
          //       String "; ... })" ])


          //   | TCK.EnumField(enumType, caseName, fieldIndex, fieldCount, fieldType, _) ->
          //     // format:
          //     //   Ok (..., string, ...) // some description
          //     // TODO: extract description from the type definition later
          //     let prefix = if fieldIndex = 0 then [] else [ String "..., " ]
          //     let suffix = if fieldIndex = fieldCount - 1 then [] else [ String ", ..." ]
          //     let openParen = if fieldCount > 0 then [ String "(" ] else []
          //     let closeParen = if fieldCount > 0 then [ String ")" ] else []
          //     let display typ =
          //       [ ShortTypeName enumType; String "."; InlineFieldName caseName; String " " ]
          //       @ openParen
          //       @ prefix
          //       @ typ
          //       @ suffix
          //       @ closeParen


          //     (display [ TypeOfValue argument ]), (display [ TypeReference fieldType ])


          //   | TCK.DBSchemaType(dbName, expectedType, _) ->
          //     // format:
          //     // String
          //     defaultActual, [ TypeReference expectedType ]


          //   | TCK.DBQueryVariable(varName, expected, _) ->
          //     // format:
          //     // (varName : string) // some description
          //     defaultActual,
          //     ([ String "("
          //       InlineVarName varName

          //       String ": "
          //       TypeReference expected
          //       String ")" ])


          //   | TCK.ListIndex(index, typ, parent) -> defaultActual, [ TypeReference typ ]


          //   | TCK.TupleIndex(index, typ, parent) -> defaultActual, [ TypeReference typ ]

          // let contextVerb (context : TCK.Context) : string =
          //   match context with
          //   | TCK.FunctionCallParameter _ -> "passed"
          //   | TCK.FunctionCallResult _ -> "returned"
          //   | TCK.RecordField _ -> "passed"
          //   | TCK.DictKey _ -> "passed"
          //   | TCK.EnumField _ -> "passed"
          //   | TCK.DBSchemaType _ -> "passed"
          //   | TCK.DBQueryVariable _ -> "passed"
          //   | TCK.ListIndex _ -> "passed"
          //   | TCK.TupleIndex _ -> "passed"

          let toSegments (e: Error) : ErrorOutput =
            // match e with
            // | ValueNotExpectedType(argument, expected, context) ->
            //   let summary =
            //     contextSummary context
            //     @ [ String " should be "; IndefiniteArticle; TypeReference expected ]

            //   let extraExplanation =
            //     [ String ". However, "
            //       IndefiniteArticle
            //       TypeOfValue argument
            //       String " ("
            //       InlineValue argument
            //       String ") was passed instead." ]

            //   let (actual, expected) = contextAsActualExpected argument context

            //   { summary = summary
            //     extraExplanation = extraExplanation
            //     actual = actual
            //     expected = expected }

            // | TypeDoesntExist(typeName, _) ->
            //   // Perhaps this should be an internal error as this shouldn't be possible
            //   let summary = [ TypeName typeName; String " doesn't exist" ]

            //   let extraExplanation = []
            //   let actual = []
            //   let expected = []

            //   { summary = summary
            //     extraExplanation = extraExplanation
            //     actual = actual
            //     expected = expected }

            // | VTTODOMismatchedType msg ->
            //   { summary = [ String "VTTODOMismatchedType"; String msg ]
            //     extraExplanation = []
            //     actual = []
            //     expected = [] }

            // | VTTODOMergedValueTypeWrapper err ->
            //   { summary = [ String "VTTODOMergedValueTypeWrapper"; String err ]
            //     extraExplanation = []
            //     actual = []
            //     expected = [] }
            ()