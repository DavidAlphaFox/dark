// provides syntax highlighting
module Darklang =
  module LanguageTools =
    module LspServer =
      module SemanticTokens =
        /// note: these are referenced by their _index_!
        /// i.e. 'keyword' is 0, 'string' is 4, etc.
        let tokenTypes =
          [ "keyword" // for words 'let' and 'in'
            "function" // for function names/identifiers
            "parameter" // for function parameter identifiers
            "type" // for type names like Int, Bool, etc.
            "string" // for string literals
            "operator" // for operators like +, -
            "variable" ] // for general identifiers

        let tokenModifiers = []


        /// Maps from "exact" semantic tokens that try to remain ignorant of
        /// the LSP's data format, into the UInt64-based format that the LSP
        /// _does_ expect.
        module EncodeSemanticTokens =
          let tokenType
            (t: Darklang.LanguageTools.SemanticTokens.TokenType)
            : UInt64 =
            match t with
            | Keyword -> 0UL
            | Function -> 1UL
            | Parameter -> 2UL
            | Type -> 3UL
            | String -> 4UL
            | Operator -> 5UL
            | Variable -> 6UL


          let toRelativeTokens
            (tokens: List<LanguageTools.SemanticTokens.SemanticToken>)
            : List<LanguageServerProtocol.SemanticTokens.RelativeSemanticToken.RelativeSemanticToken<LanguageTools.SemanticTokens.TokenType>> =
            tokens
            |> Stdlib.List.sortByComparator_v0 (fun a b ->
              // TODO: sort by rows, too
              // TODO: handle equality?
              if
                Stdlib.Int64.lessThan
                  a.sourceRange.start.column
                  b.sourceRange.start.column
              then
                -1L
              else
                1L)
            |> Builtin.unwrap
            |> (Stdlib.List.fold
              (([], Parser.Point { row = 0L; column = 0L }))
              (fun acc token ->
                let (tokensSoFar, startOfLastToken) = acc

                let (deltaLine, deltaStart) =
                  match token.sourceRange.start.row - startOfLastToken.row with
                  | 0L ->
                    (0UL, token.sourceRange.start.column - startOfLastToken.column)
                  | lineDiff -> (lineDiff, token.sourceRange.start.column)

                let newToken =
                  LanguageServerProtocol.SemanticTokens.RelativeSemanticToken.RelativeSemanticToken //<LanguageTools.SemanticTokens.TokenType>
                    { deltaLine = deltaLine
                      deltaStart =
                        deltaStart |> Stdlib.UInt64.fromInt64 |> Builtin.unwrap
                      length =
                        (token.sourceRange.end_.column
                         - token.sourceRange.start.column)
                        |> Stdlib.UInt64.fromInt64
                        |> Builtin.unwrap
                      tokenType = token.tokenType }

                (Stdlib.List.push tokensSoFar newToken, token.sourceRange.start)))
            |> Stdlib.Tuple2.first
            |> Stdlib.List.reverse


          let toLspFormat
            (tokens:
              List<LanguageServerProtocol.SemanticTokens.RelativeSemanticToken.RelativeSemanticToken>)
            : List<UInt64> =
            LanguageServerProtocol.SemanticTokens.RelativeSemanticToken.mapListToFlatDataForResult<Darklang.LanguageTools.SemanticTokens.TokenType>
              (fun t -> tokenType t)
              tokens



        let hardcodedServerCapabilities
          ()
          : LanguageServerProtocol.SemanticTokens.SemanticTokenProviderOptions.SemanticTokenProviderOptions =
          LanguageServerProtocol
            .SemanticTokens
            .SemanticTokenProviderOptions
            .SemanticTokenProviderOptions
            .SemanticTokensOptions(
              LanguageServerProtocol.SemanticTokens.SemanticTokensOptions.SemanticTokensOptions
                { legend =
                    LanguageServerProtocol.SemanticTokens.SemanticTokensLegend.SemanticTokensLegend
                      { tokenTypes = tokenTypes
                        tokenModifiers = tokenModifiers }
                  range =
                    Stdlib.Option.Option.Some(
                      LanguageServerProtocol.SemanticTokens.SemanticTokensOptions.SemanticTokensOptionsRange.SemanticTokensOptionsRange.Bool
                        false
                    )
                  full =
                    Stdlib.Option.Option.Some(
                      LanguageServerProtocol.SemanticTokens.SemanticTokensOptions.SemanticTokensOptionsFull.SemanticTokensOptionsFull.Bool
                        true
                    ) }
            )

        let handleSemanticTokensRequest
          (state: LspState)
          (requestId: JsonRPC.RequestId)
          (requestParams:
            LanguageServerProtocol.SemanticTokens.SemanticTokensRequest.SemanticTokensParams.SemanticTokensParams)
          : LspState =
          let relevantDoc =
            Stdlib.Dict.get state.documentsInScope requestParams.textDocument.uri

          match relevantDoc with
          | None ->
            (JsonRPC.Response.Error.make
              (Stdlib.Option.Option.Some requestId)
              JsonRPC.Response.Error.KnownErrorCodes.internalError
              $"Failed to find document text in language server's cache: {requestParams.textDocument.uri}"
              Stdlib.Option.Option.None)
            |> Stdlib.AltJson.format
            |> logAndSendToClient

          | Some docText ->
            let parsed =
              docText |> Parser.parse |> Parser.parseNodeToWrittenTypesSourceFile

            match parsed with
            | Ok parsedFile ->
              let data =
                parsedFile
                |> LanguageTools.SemanticTokens.fromParsedFile
                |> EncodeSemanticTokens.toRelativeTokens
                |> EncodeSemanticTokens.toLspFormat

              let result =
                LanguageServerProtocol
                  .SemanticTokens
                  .SemanticTokensRequest
                  .SemanticTokensResult
                  .SemanticTokensResult
                  .SemanticTokens(
                    LanguageServerProtocol.SemanticTokens.SemanticTokens.SemanticTokens
                      { resultId = Stdlib.Option.Option.None
                        data = data }
                  )

              let resultJson =
                result
                |> LanguageServerProtocol.SemanticTokens.SemanticTokensRequest.SemanticTokensResult.toJson
                |> (fun r ->
                  JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some requestId) r)
                |> Stdlib.AltJson.format

              logAndSendToClient resultJson

            | Error parseError ->
              (JsonRPC.Response.Error.make
                (Stdlib.Option.Option.Some requestId)
                JsonRPC.Response.Error.KnownErrorCodes.internalError
                $"Couldn't parse code for syntax highlighting: {requestParams.textDocument.uri}"
                Stdlib.Option.Option.None)
              |> Stdlib.AltJson.format
              |> logAndSendToClient

          state