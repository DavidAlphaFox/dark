// provides syntax highlighting
module Darklang =
  module LanguageTools =
    module LspServer =
      module SemanticTokens =
        /// note: these are referenced by their _index_!
        /// i.e. 'keyword' is 0, 'string' is 4, etc.
        let tokenTypes =
          [ "keyword" // for words 'let' and 'in'
            "function" // for function names/identifiers
            "parameter" // for function parameter identifiers
            "type" // for type names like Int, Bool, etc.
            "string" // for string literals
            "operator" // for operators like +, -
            "variable" ] // for general identifiers

        let tokenModifiers = []


        // (for quick reference while this is in progress)
        // let double (i: Int) : Int = i + i
        module WrittenTypesToRelativeSemanticTokens =
          module TokenType =
            type TokenType =
              | Keyword
              | Function
              | Parameter
              | Type
              | String
              | Operator
              | Variable

            let toUInt (t: TokenType) : UInt64 =
              match t with
              | Keyword -> 0UL
              | Function -> 1UL
              | Parameter -> 2UL
              | Type -> 3UL
              | String -> 4UL
              | Operator -> 5UL
              | Variable -> 6UL

          module DarkToken =
            type DarkToken =
              LanguageServerProtocol.SemanticTokens.RelativeSemanticToken.RelativeSemanticToken<TokenType.TokenType>

            let mapListToFlatDataForResult (tokens: List<DarkToken>) : List<UInt64> =
              LanguageServerProtocol.SemanticTokens.RelativeSemanticToken.mapListToFlatDataForResult<TokenType.TokenType>
                TokenType.toUInt
                tokens

          let mapParsedFile
            (wt: WrittenTypes.ParsedFile)
            : List<DarkToken.DarkToken> =
            match wt with
            | PackageFunctions(_, fns) ->
              // TODO: make this real
              [ DarkToken.DarkToken
                  { deltaLine = 0UL
                    deltaStart = 0UL
                    length = 3UL
                    tokenType = TokenType.TokenType.Keyword } ]


        let hardcodedServerCapabilities
          ()
          : LanguageServerProtocol.SemanticTokens.SemanticTokenProviderOptions.SemanticTokenProviderOptions =
          LanguageServerProtocol
            .SemanticTokens
            .SemanticTokenProviderOptions
            .SemanticTokenProviderOptions
            .SemanticTokensOptions(
              LanguageServerProtocol.SemanticTokens.SemanticTokensOptions.SemanticTokensOptions
                { legend =
                    LanguageServerProtocol.SemanticTokens.SemanticTokensLegend.SemanticTokensLegend
                      { tokenTypes = tokenTypes
                        tokenModifiers = tokenModifiers }
                  range =
                    Stdlib.Option.Option.Some(
                      LanguageServerProtocol.SemanticTokens.SemanticTokensOptions.SemanticTokensOptionsRange.SemanticTokensOptionsRange.Bool
                        false
                    )
                  full =
                    Stdlib.Option.Option.Some(
                      LanguageServerProtocol.SemanticTokens.SemanticTokensOptions.SemanticTokensOptionsFull.SemanticTokensOptionsFull.Bool
                        true
                    ) }
            )

        let handleSemanticTokensRequest
          (state: LspState)
          (requestId: JsonRPC.RequestId)
          (requestParams:
            LanguageServerProtocol.SemanticTokens.SemanticTokensRequest.SemanticTokensParams.SemanticTokensParams)
          : LspState =
          let relevantDoc =
            Stdlib.Dict.get state.documentsInScope requestParams.textDocument.uri

          match relevantDoc with
          | None ->
            (JsonRPC.Response.Error.make
              (Stdlib.Option.Option.Some requestId)
              JsonRPC.Response.Error.KnownErrorCodes.internalError
              $"Failed to find document text in language server's cache: {requestParams.textDocument.uri}"
              Stdlib.Option.Option.None)
            |> Stdlib.AltJson.format
            |> logAndSendToClient

          | Some docText ->
            let parsed =
              docText |> Parser.parse |> Parser.parseNodeToWrittenTypesSourceFile

            match parsed with
            | Ok parsedFile ->
              let data =
                parsedFile
                |> WrittenTypesToRelativeSemanticTokens.mapParsedFile
                |> WrittenTypesToRelativeSemanticTokens.DarkToken.mapListToFlatDataForResult

              let result =
                LanguageServerProtocol
                  .SemanticTokens
                  .SemanticTokensRequest
                  .SemanticTokensResult
                  .SemanticTokensResult
                  .SemanticTokens(
                    LanguageServerProtocol.SemanticTokens.SemanticTokens.SemanticTokens
                      { resultId = Stdlib.Option.Option.None
                        data = data }
                  )

              let resultJson =
                result
                |> LanguageServerProtocol.SemanticTokens.SemanticTokensRequest.SemanticTokensResult.toJson
                |> (fun r ->
                  JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some requestId) r)
                |> Stdlib.AltJson.format

              logAndSendToClient resultJson

            | Error parseError ->
              (JsonRPC.Response.Error.make
                (Stdlib.Option.Option.Some requestId)
                JsonRPC.Response.Error.KnownErrorCodes.internalError
                $"Couldn't parse code for syntax highlighting: {requestParams.textDocument.uri}"
                Stdlib.Option.Option.None)
              |> Stdlib.AltJson.format
              |> logAndSendToClient

          state