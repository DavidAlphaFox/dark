module Darklang =
  module LanguageTools =
    module LspServer =
      module Completions =
        let hardcodedServerCapabilities
          ()
          : LanguageServerProtocol.Completions.CompletionOptions.CompletionOptions =
          LanguageServerProtocol.Completions.CompletionOptions.CompletionOptions
            { triggerCharacters = Stdlib.Option.Option.Some [ "." ]
              allCommitCharacters = Stdlib.Option.Option.Some [ "\t" ]
              resolveProvider = Stdlib.Option.Option.Some false // just return all info at once
              completionItem = Stdlib.Option.Option.None }

        let createCompletionItem
          (label: String)
          (kind:
            LanguageServerProtocol.Completions.CompletionItem.CompletionItemKind.CompletionItemKind)
          (detail: String)
          (insertText: String)
          : LanguageServerProtocol.Completions.CompletionItem.CompletionItem =
          LanguageServerProtocol.Completions.CompletionItem.CompletionItem
            { label = label
              kind = Stdlib.Option.Option.Some kind
              detail = Stdlib.Option.Option.Some detail
              preselect = Stdlib.Option.Option.Some true
              sortText = Stdlib.Option.Option.Some label
              filterText = Stdlib.Option.Option.Some label
              insertText = Stdlib.Option.Option.Some insertText
              insertTextFormat =
                Stdlib.Option.Option.Some
                  LanguageServerProtocol.Completions.InsertTextFormat.InsertTextFormat.PlainText
              insertTextMode = Stdlib.Option.Option.None
              // textEdit = Stdlib.Option.Option.None
              textEditText = Stdlib.Option.Option.None
              commitCharacters = Stdlib.Option.Option.Some [ " " ]
              data = Stdlib.Option.Option.None }

        let createCompletions
          (wordUnderCursor: String)
          : List<LanguageServerProtocol.Completions.CompletionItem.CompletionItem> =
          let keywords =
            [ "module"
              "type"
              "const"
              "let"
              "if"
              "then"
              "else"
              "match"
              "with"
              "fun" ]
            |> Stdlib.List.map (fun k ->
              createCompletionItem
                k
                LanguageServerProtocol.Completions.CompletionItem.CompletionItemKind.CompletionItemKind.Keyword
                "keyword"
                k)


          // Try to extract each character individually to see what's really there
          let chars = wordUnderCursor |> Stdlib.String.toList

          // Try a character-by-character approach
          let (modulePath, searchText) =
            match wordUnderCursor |> Stdlib.String.lastIndexOf "." with
            | Some i ->
              let moduleString = Stdlib.String.slice wordUnderCursor 0L i
              let modules = if moduleString == "" then [] else Stdlib.String.split moduleString "."

              let afterDotChars =
                chars
                |> Stdlib.List.drop (i + 1L)

              let searchStr =
                if Stdlib.List.isEmpty afterDotChars then
                  ""
                else
                  afterDotChars |> Stdlib.String.fromList

              (modules, searchStr)
            | None ->
              ([], wordUnderCursor)


          let query =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = modulePath
                text = searchText
                searchDepth =
                  LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes =
                  [ LanguageTools.ProgramTypes.Search.EntityType.Fn
                    LanguageTools.ProgramTypes.Search.EntityType.Constant
                    LanguageTools.ProgramTypes.Search.EntityType.Type
                    LanguageTools.ProgramTypes.Search.EntityType.Module ] }


          let searchResults =
            LanguageTools.PackageManager.Search.search query

          let fns =
            searchResults.fns
            |> Stdlib.List.map (fun fn -> LanguageTools.ProgramTypes.PackageFn.nameToString fn.name)

          let types =
            searchResults.types
            |> Stdlib.List.map (fun t -> LanguageTools.ProgramTypes.PackageType.nameToString t.name)

          let constants =
            searchResults.constants
            |> Stdlib.List.map (fun c -> LanguageTools.ProgramTypes.PackageConstant.nameToString c.name)

          let submodules =
            searchResults.submodules
            |> Stdlib.List.map (fun m ->
              m
              |> Stdlib.List.map (fun s ->
                s
                |> Stdlib.String.join "."))
            |> Stdlib.List.flatten


          let functions =
            fns
            |> Stdlib.List.map (fun f ->
              // drop "Darklang." prefix
              let f = f |> Stdlib.String.dropFirst 9L
              let currentPrefix =
                match wordUnderCursor |> Stdlib.String.lastIndexOf "." with
                | Some i -> Stdlib.String.slice wordUnderCursor 0L (i + 1L)
                | None -> ""

              let prefixLength = Stdlib.String.length currentPrefix

              // Calculate what text to insert when item is selected from the completion list
              let insertText =
                if prefixLength > 0L then
                  if Stdlib.String.startsWith f currentPrefix then
                    Stdlib.String.slice f prefixLength (Stdlib.String.length f)
                  else
                    f
                else
                  f

              createCompletionItem
                f
                LanguageServerProtocol.Completions.CompletionItem.CompletionItemKind.CompletionItemKind.Function
                "function"
                insertText)


          let types =
            types
            |> Stdlib.List.map (fun t ->
              // drop "Darklang." prefix
              let t = t |> Stdlib.String.dropFirst 9L
              let currentPrefix =
                match wordUnderCursor |> Stdlib.String.lastIndexOf "." with
                | Some i -> Stdlib.String.slice wordUnderCursor 0L (i + 1L)
                | None -> ""

              let prefixLength = Stdlib.String.length currentPrefix

              // Calculate what text to insert when item is selected from the completion list
              let insertText =
                if prefixLength > 0L then
                  if Stdlib.String.startsWith t currentPrefix then
                    Stdlib.String.slice t prefixLength (Stdlib.String.length t)
                  else
                    t
                else
                  t

              createCompletionItem
                t
                LanguageServerProtocol.Completions.CompletionItem.CompletionItemKind.CompletionItemKind.Class
                "type"
                insertText)


          let constants =
            constants
            |> Stdlib.List.map (fun c ->
              // drop "Darklang." prefix
              let c = c |> Stdlib.String.dropFirst 9L
              let currentPrefix =
                match wordUnderCursor |> Stdlib.String.lastIndexOf "." with
                | Some i -> Stdlib.String.slice wordUnderCursor 0L (i + 1L)
                | None -> ""

              let prefixLength = Stdlib.String.length currentPrefix

              // Calculate what text to insert when item is selected from the completion list
              let insertText =
                if prefixLength > 0L then
                  if Stdlib.String.startsWith c currentPrefix then
                    Stdlib.String.slice c prefixLength (Stdlib.String.length c)
                  else
                    c
                else
                  c

              createCompletionItem
                c
                LanguageServerProtocol.Completions.CompletionItem.CompletionItemKind.CompletionItemKind.Constant
                "constant"
                insertText)


          let submodules =
            submodules
            |> Stdlib.List.map (fun m ->
              let currentPrefix =
                match wordUnderCursor |> Stdlib.String.lastIndexOf "." with
                | Some i -> Stdlib.String.slice wordUnderCursor 0L (i + 1L)
                | None -> ""

              let prefixLength = Stdlib.String.length currentPrefix

              // Calculate what text to insert when item is selected from the completion list
              let insertText =
                if prefixLength > 0L then
                  if Stdlib.String.startsWith m currentPrefix then
                    Stdlib.String.slice m prefixLength (Stdlib.String.length m)
                  else
                    m
                else
                  m

              createCompletionItem
                m
                LanguageServerProtocol.Completions.CompletionItem.CompletionItemKind.CompletionItemKind.Module
                "module"
                insertText)


          let completions = Stdlib.List.flatten [ keywords; functions; types; constants ; submodules ]

          completions


        /// handles `textDocument/completion` requests
        let handleCompletionRequest
          (state: LspState)
          (requestId: JsonRPC.RequestId)
          (requestParams:
            LanguageServerProtocol.Completions.CompletionRequest.CompletionParams.CompletionParams)
          : LspState =
          let content =
            (state.documentsInScope
             |> Stdlib.Dict.get requestParams.textDocument.uri
             |> Builtin.unwrap)

          let wordUnderCursor =
            CursorPosition.wordUnderCursor content.text requestParams.position

          let completions =
            (createCompletions wordUnderCursor)
            |> Stdlib.List.filter (fun c ->
              c.label |> Stdlib.String.startsWith wordUnderCursor)


          let response =
            LanguageServerProtocol.Completions.CompletionList.CompletionList
              { isIncomplete = true
                itemDefaults = Stdlib.Option.Option.None
                items = completions }

          let responseJson =
            response
            |> LanguageServerProtocol.Completions.CompletionList.toJson
            |> (fun r ->
              JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some requestId) r)
            |> Stdlib.AltJson.format

          logAndSendToClient responseJson

          state