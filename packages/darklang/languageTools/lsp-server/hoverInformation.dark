module Darklang =
  module LanguageTools =
    module LspServer =
      module HoverInformation =
        type Info =
          { range: WrittenTypes.Range
            description: Stdlib.Option.Option<String>
            metadata: Stdlib.Option.Option<String> }


        let createHoverInfo
          (range: WrittenTypes.Range)
          (description: Stdlib.Option.Option<String>)
          (metadata: Stdlib.Option.Option<String>)
          : Info =
          Info
            { range = range
              description = description
              metadata = metadata }


        let createCodeSnippet (text: String) : String =
          $"""
```fsharp
{text}
```"""

        let pkgFnSignature (f: ProgramTypes.PackageFn.PackageFn) : String =
          let params =
            f.parameters
            |> Stdlib.List.map (fun p ->
              p |> PrettyPrinter.ProgramTypes.PackageFn.parameter)
            |> Stdlib.String.join ", "

          let returnType = f.returnType |> PrettyPrinter.ProgramTypes.typeReference

          params ++ " -> " ++ returnType

        let builtinFnSignature (f: BuiltinFunction) : String =
          let parameters =
            f.parameters
            |> Stdlib.List.map (fun p -> $"({p.name} : {p.``type``})")
            |> Stdlib.String.join ", "

          parameters ++ " -> " ++ f.returnType

        let getBuiltinFn (name: String) : Stdlib.Option.Option<BuiltinFunction> =
          (Builtin.languageToolsAllBuiltinFns ())
          |> Stdlib.List.findFirst (fun f -> f.name == name)


        /// Helper function to find and get package functions, types, and constants by name from the package manager
        let tryGetFnAndCollectHoverInfo
          (fnName: List<String>)
          (range: WrittenTypes.Range)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          let onMissing = LanguageTools.NameResolver.OnMissing.Allow
          let range = Parser.createRange (0L, 0L) (0L, 0L)
          let fnName = WrittenTypes.Name.Unresolved range fnName

          let resolvedFn =
            NameResolver.FnName.resolve onMissing pm owner currentModules fnName

          match resolvedFn with
          | Ok fn ->
            match fn with
            | Package pkgFn ->
              let getFn = pm.getFn

              match getFn pkgFn with
              | Some f ->
                let signature = pkgFnSignature f

                let fqName =
                  (Stdlib.List.append f.name.modules [ f.name.name ])
                  |> Stdlib.String.join "."

                let metadata =
                  Stdlib.Option.Option.Some(
                    "Fully qualified name: "
                    ++ fqName
                    ++ "\n\n"
                    ++ (createCodeSnippet signature)
                  )

                let description =
                  Stdlib.Option.Option.Some("//TODO: add description")

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None -> Stdlib.Option.Option.None

            | Builtin b ->
              let builtin = getBuiltinFn b.name

              match builtin with
              | Some b ->
                let signature = builtinFnSignature b

                let metadata =
                  Stdlib.Option.Option.Some(
                    "Builtin function\n\n" ++ (createCodeSnippet signature)
                  )

                let description =
                  Stdlib.Option.Option.Some("//TODO: add description")

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None -> Stdlib.Option.Option.None

          | _ -> Stdlib.Option.Option.None


        let tryGetPkgType
          (typeName: List<String>)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<ProgramTypes.PackageType.PackageType> =
          let onMissing = LanguageTools.NameResolver.OnMissing.Allow
          let range = Parser.createRange (0L, 0L) (0L, 0L)
          let typeName = WrittenTypes.Name.Unresolved range typeName

          let resolvedType =
            NameResolver.TypeName.resolve onMissing pm owner currentModules typeName

          match resolvedType with
          | Ok typ ->
            let t =
              match typ with
              | Package t -> t

            let getType = pm.getType
            getType t
          | _ -> Stdlib.Option.Option.None


        let tryGetPkgConst
          (constName: List<String>)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<ProgramTypes.PackageConstant.PackageConstant> =
          let onMissing = LanguageTools.NameResolver.OnMissing.Allow
          let range = Parser.createRange (0L, 0L) (0L, 0L)
          let constName = WrittenTypes.Name.Unresolved range constName

          let resolvedConst =
            NameResolver.ConstantName.resolve
              onMissing
              pm
              owner
              currentModules
              constName

          match resolvedConst with
          | Ok constant ->
            let c =
              match constant with
              | Package c -> c

            let getConstant = pm.getConstant
            getConstant c
          | _ -> Stdlib.Option.Option.None


        /// Check if the position falls within the node's range; to help escaping early
        let checkIfPositionWithinRange
          (position: LanguageServerProtocol.Position.Position)
          (range: WrittenTypes.Range)
          : Stdlib.Option.Option<WrittenTypes.Range> =
          let line = position.line |> Stdlib.Int64.fromUInt64

          let character = position.character |> Stdlib.Int64.fromUInt64

          let rangeStartLine = range.start.row
          let rangeEndLine = range.end_.row
          let rangeStartCharacter = range.start.column
          let rangeEndCharacter = range.end_.column

          match line, character with
          | Some line, Some character ->
            if
              line == rangeStartLine
              && rangeStartCharacter <= character
              && character <= rangeEndCharacter
            then
              Stdlib.Option.Option.Some(range)
            else
              Stdlib.Option.Option.None
          | _, _ -> Stdlib.Option.Option.None

        let isLineNumberInRange
          (position: LanguageServerProtocol.Position.Position)
          (range: WrittenTypes.Range)
          : Bool =
          let line = position.line |> Stdlib.Int64.fromUInt64 |> Builtin.unwrap
          let rangeStartLine = range.start.row
          let rangeEndLine = range.end_.row

          line >= rangeStartLine && line <= rangeEndLine


        /// Helper function for `collectBuiltinTypeHoverInfoAtPos`
        let createBuiltinTypeInfoIfInRange
          (range: WrittenTypes.Range)
          (typeName: String)
          (position: LanguageServerProtocol.Position.Position)
          : Stdlib.Option.Option<Info> =
          match checkIfPositionWithinRange position range with
          | Some r ->
            let metadata = Stdlib.Option.Option.Some($"Builtin type {typeName}")
            let description = Stdlib.Option.Option.None
            Stdlib.Option.Option.Some(createHoverInfo r description metadata)

          | None -> Stdlib.Option.Option.None

        let collectBuiltinTypeHoverInfoAtPos
          (builtin: WrittenTypes.TypeReference.Builtin)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match builtin with
          | TUnit r -> createBuiltinTypeInfoIfInRange r "Unit" position
          | TBool r -> createBuiltinTypeInfoIfInRange r "Bool" position
          | TInt8 r -> createBuiltinTypeInfoIfInRange r "Int8" position
          | TUInt8 r -> createBuiltinTypeInfoIfInRange r "UInt8" position
          | TInt16 r -> createBuiltinTypeInfoIfInRange r "Int16" position
          | TUInt16 r -> createBuiltinTypeInfoIfInRange r "UInt16" position
          | TInt32 r -> createBuiltinTypeInfoIfInRange r "Int32" position
          | TUInt32 r -> createBuiltinTypeInfoIfInRange r "UInt32" position
          | TInt64 r -> createBuiltinTypeInfoIfInRange r "Int64" position
          | TUInt64 r -> createBuiltinTypeInfoIfInRange r "UInt64" position
          | TInt128 r -> createBuiltinTypeInfoIfInRange r "Int128" position
          | TUInt128 r -> createBuiltinTypeInfoIfInRange r "UInt128" position
          | TFloat r -> createBuiltinTypeInfoIfInRange r "Float" position
          | TChar r -> createBuiltinTypeInfoIfInRange r "Char" position
          | TString r -> createBuiltinTypeInfoIfInRange r "String" position
          | TDateTime r -> createBuiltinTypeInfoIfInRange r "DateTime" position
          | TUuid r -> createBuiltinTypeInfoIfInRange r "Uuid" position

          | TList(r, keywordRange, _, typ, _) ->
            // check if position is within the List range
            if isLineNumberInRange position r then
              // check if we are hovering over the List keyword
              match checkIfPositionWithinRange position keywordRange with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "List"
                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the type reference
                collectTypeRefHoverInfoAtPos typ position pm owner currentModules
            else
              Stdlib.Option.Option.None

          | TDict(r, keywordRange, _, typ, _) ->
            // check if position is within the Dict range
            if isLineNumberInRange position r then
              // check if we are hovering over the Dict keyword
              match checkIfPositionWithinRange position keywordRange with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "Dict"
                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the type reference
                collectTypeRefHoverInfoAtPos typ position pm owner currentModules

            else
              Stdlib.Option.Option.None

          | TTuple(range, f, _, s, rest, _, _) ->
            // check if position is within the Tuple range
            if isLineNumberInRange position r then
              // check if we are hovering over the first type reference
              match
                collectTypeRefHoverInfoAtPos f position pm owner currentModules
              with
              | Some r -> Stdlib.Option.Option.Some(r)
              | None ->
                // check if we are hovering over the second type reference
                match
                  collectTypeRefHoverInfoAtPos s position pm owner currentModules
                with
                | Some r -> Stdlib.Option.Option.Some(r)
                | None ->
                  // check if we are hovering over the rest type references
                  rest
                  |> Stdlib.List.filterMap (fun (_, t) ->
                    collectTypeRefHoverInfoAtPos t position pm owner currentModules)
                  |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | TFn(r, args, ret) ->
            // check if position is within the Fn range
            if isLineNumberInRange position r then
              // check if we are hovering over the return type
              match
                collectTypeRefHoverInfoAtPos ret position pm owner currentModules
              with
              | Some r -> Stdlib.Option.Option.Some(r)
              | None ->
                // check if we are hovering over the arguments
                args
                |> Stdlib.List.filterMap (fun (t, _) ->
                  collectTypeRefHoverInfoAtPos t position pm owner currentModules)
                |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | TDB(r, keywordRange, _, typ, _) ->
            // check if position is within the DB range
            if isLineNumberInRange position r then
              // check if we are hovering over the DB keyword
              match checkIfPositionWithinRange position keywordRange with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "DB"
                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the type reference
                collectTypeRefHoverInfoAtPos typ position pm owner currentModules
            else
              Stdlib.Option.Option.None

          | TVariable(r, _, name) ->
            match checkIfPositionWithinRange position r with
            | Some r ->
              let metadata = Stdlib.Option.Option.Some("Variable type")

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None -> Stdlib.Option.Option.None

          | _ -> Stdlib.Option.Option.None


        let collectTypeRefHoverInfoAtPos
          (typeRef: WrittenTypes.TypeReference.TypeReference)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match typeRef with
          | Builtin b ->
            collectBuiltinTypeHoverInfoAtPos b position pm currentModules
          | QualifiedName qn ->
            // check if we are hovering over the one of the modules
            let moduleHoverInfo =
              qn.modules
              |> Stdlib.List.filterMap (fun (m, _) ->
                match checkIfPositionWithinRange position m.range with
                | Some r ->
                  let metadata = Stdlib.Option.Option.Some("Module type")

                  let description =
                    Stdlib.Option.Option.Some(
                      "TODO: add description when /// comments are supported"
                    )

                  Stdlib.Option.Option.Some(createHoverInfo r description metadata)
                | None -> Stdlib.Option.Option.None)

              |> Stdlib.List.head

            match moduleHoverInfo with
            | Some r -> Stdlib.Option.Option.Some r
            | None ->
              // check if we are hovering over the type name
              match checkIfPositionWithinRange position qn.typ.range with
              | Some r ->
                let modules = qn.modules |> Stdlib.List.map (fun (m, _) -> m.name)
                let typeName = Stdlib.List.append modules [ qn.typ.name ]

                let typ = tryGetPkgType typeName pm owner currentModules

                let prettyType =
                  match typ with
                  | Some t -> PrettyPrinter.ProgramTypes.packageType t
                  | None -> "could not get type"

                let fqName =
                  match typ with
                  | Some t ->
                    let fqName = Stdlib.List.append t.name.modules [ t.name.name ]
                    Stdlib.String.join fqName "."
                  | None -> typeName |> Stdlib.String.join "."

                let metadata =
                  Stdlib.Option.Option.Some(
                    createCodeSnippet prettyType
                    ++ "\n\n"
                    ++ $"Fully qualified name: {fqName}"
                  )

                let description =
                  Stdlib.Option.Option.Some(
                    "TODO: add description when /// comments are supported"
                  )

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the type parameters
                qn.typeArgs
                |> Stdlib.List.filterMap (fun tr ->
                  collectTypeRefHoverInfoAtPos tr position pm owner currentModules)
                |> Stdlib.List.head


        // ---------------------------
        // Type declaration Hover Info
        // ---------------------------
        let collectEnumFieldHoverInfoAtPos
          (enumField: WrittenTypes.TypeDeclaration.EnumField)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          // check if we are hovering over an enum field
          match checkIfPositionWithinRange position enumField.range with
          | Some r ->
            let typ =
              enumField.typ
              |> collectTypeRefHoverInfoAtPos position pm owner currentModules
            // check if we are hovering over the enum field type
            match typ with
            | Some _ -> typ
            | None ->
              let label =
                match enumField.label with
                | Some((r, _)) -> Stdlib.Option.Option.Some r
                | None -> Stdlib.Option.Option.None

              // check if we are hovering over the enum field label
              match label with
              | Some r ->
                match checkIfPositionWithinRange position r with
                | Some r ->
                  let metadata = Stdlib.Option.Option.Some("label")
                  // TODO: the enumField.description isn't only for the label, we need a way to get the description for the whole enumField
                  let description = Stdlib.Option.Option.Some(enumField.description)

                  Stdlib.Option.Option.Some(createHoverInfo r description metadata)

                | None -> Stdlib.Option.Option.None
              | None -> Stdlib.Option.Option.None
          | None -> Stdlib.Option.Option.None

        let collectEnumCaseHoverInfoAtPos
          (enumCase: WrittenTypes.TypeDeclaration.EnumCase)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          let (nameRange, _) = enumCase.name
          // check if we are hovering over the enum case
          match checkIfPositionWithinRange position enumCase.range with
          | Some r ->
            // check if we are hovering over the enum case name
            match checkIfPositionWithinRange position nameRange with
            | Some r ->
              let metadata = Stdlib.Option.Option.Some("Enum case")
              let description = Stdlib.Option.Option.Some(enumCase.description)

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None ->
              // check if we are hovering over the of keyword
              match enumCase.keywordOf with
              | Some r ->
                match checkIfPositionWithinRange position r with
                | Some r ->
                  let metadata = Stdlib.Option.Option.None
                  let description = KeywordDescription.getKeywordDescription "of"

                  Stdlib.Option.Option.Some(createHoverInfo r description metadata)

                | None ->
                  // check if we are hovering over one of the enum case fields
                  enumCase.fields
                  |> Stdlib.List.filterMap (fun field ->
                    collectEnumFieldHoverInfoAtPos
                      field
                      position
                      pm
                      owner
                      currentModules)
                  |> Stdlib.List.head

              | None -> Stdlib.Option.Option.None
          | None -> Stdlib.Option.Option.None


        let collectDefintionHoverInfoAtPos
          (def: WrittenTypes.TypeDeclaration.Definition)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match def with
          | Alias a ->
            collectTypeRefHoverInfoAtPos a position pm owner currentModules
          | Record r ->
            r
            |> Stdlib.List.filterMap (fun (field, _) ->
              let (nameRange, _) = field.name
              // check if we are hovering over the record field name
              match checkIfPositionWithinRange position nameRange with
              | Some r ->
                let metadata = Stdlib.Option.Option.Some("Record field")
                let description = Stdlib.Option.Option.Some(field.description)

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the record field type
                collectTypeRefHoverInfoAtPos
                  field.typ
                  position
                  pm
                  owner
                  currentModules)

            |> Stdlib.List.head

          | Enum enumCases ->
            enumCases
            |> Stdlib.List.filterMap (fun (_, enumCase) ->
              collectEnumCaseHoverInfoAtPos
                enumCase
                position
                pm
                owner
                currentModules)

            |> Stdlib.List.head


        let collectTypeHoverInfoAtPosition
          (typeDecl: WrittenTypes.TypeDeclaration.TypeDeclaration)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          // check if we are hovering over the type keyword
          match checkIfPositionWithinRange position typeDecl.keywordType with
          | Some r ->
            let metadata = Stdlib.Option.Option.None
            let description = KeywordDescription.getKeywordDescription "type"

            Stdlib.Option.Option.Some(createHoverInfo r description metadata)

          | None ->
            // check if we are hovering over the type name
            match checkIfPositionWithinRange position typeDecl.name.range with
            | Some r ->
              let modules = Stdlib.String.join currentModules "."

              let fqName =
                match modules with
                | "" -> typeDecl.name.name
                | _ -> modules ++ "." ++ typeDecl.name.name

              let metadata =
                Stdlib.Option.Option.Some("Fully qualified name: " ++ fqName)

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None ->
              // check if we are hovering over type parameters
              let typeParams =
                typeDecl.typeParams
                |> Stdlib.List.filterMap (fun (range, name) ->
                  match checkIfPositionWithinRange position range with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("Type parameter")

                    let description = Stdlib.Option.Option.None

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )

                  | None -> Stdlib.Option.Option.None)

                |> Stdlib.List.head

              match typeParams with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the type definition
                collectDefintionHoverInfoAtPos
                  typeDecl.definition
                  position
                  pm
                  currentModules


        // ---------------------------
        // Constant declaration Hover Info
        // ---------------------------
        let createConstInfoIfInRange
          (range: WrittenTypes.Range)
          (constName: String)
          (position: LanguageServerProtocol.Position.Position)
          : Stdlib.Option.Option<Info> =
          match checkIfPositionWithinRange position range with
          | Some r ->
            let metadata = Stdlib.Option.Option.Some($"{constName} constant")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo r description metadata)

          | None -> Stdlib.Option.Option.None

        let collectConstBodyHoverInfoAtPos
          (body: WrittenTypes.Const)
          (position: LanguageServerProtocol.Position.Position)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match body with
          | CUnit r -> createConstInfoIfInRange r "Unit" position

          | CBool(r, _b) -> createConstInfoIfInRange r "Bool" position

          | CInt8(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "Int8" position
          | CUInt8(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "UInt8" position
          | CInt16(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "Int16" position
          | CUInt16(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "UInt16" position
          | CInt32(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "Int32" position
          | CUInt32(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "UInt32" position
          | CInt64(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "Int64" position
          | CUInt64(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "UInt64" position
          | CInt128(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "Int128" position
          | CUInt128(r, _intPart, _suffixPart) ->
            createConstInfoIfInRange r "UInt128" position

          | CFloat(r, _sign, _w, _f) -> createConstInfoIfInRange r "Float" position

          | CChar(r, _contents, _soq, _scq) ->
            createConstInfoIfInRange r "Char" position
          | CString(r, _contents, _soq, _scq) ->
            createConstInfoIfInRange r "String" position

          | CList(r, contents, _sob, _scb) ->
            // check if we are hovering over a List constant
            if isLineNumberInRange position r then
              // check if we are hovering over one of the list elements
              contents
              |> Stdlib.List.filterMap (fun (c, _) ->
                collectConstBodyHoverInfoAtPos c position currentModules)
              |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | CDict(r, contents, keywordDict, _sob, _scb) ->
            // check if we are hovering over a Dict constant
            if isLineNumberInRange position r then
              // check if we are hovering over the Dict keyword
              match checkIfPositionWithinRange position keywordDict with
              | Some r ->
                let metadata = Stdlib.Option.Option.Some("")
                let description = KeywordDescription.getKeywordDescription "Dict"

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over one of the dict elements
                contents
                |> Stdlib.List.filterMap (fun (_, key, c) ->
                  let (keyRange, _) = key

                  match checkIfPositionWithinRange position keyRange with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("TODO: Dict key")

                    let description =
                      Stdlib.Option.Option.Some(
                        "TODO: add description when /// comments are supported"
                      )

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )
                  | None -> collectConstBodyHoverInfoAtPos c position currentModules)
                |> Stdlib.List.head
            else
              Stdlib.Option.Option.None


          | CTuple(r, first, _sc, second, rest, _sop, _scp) ->
            // check if position is within the Tuple constant range
            if isLineNumberInRange position r then
              // check if we are hovering over the first constant
              match collectConstBodyHoverInfoAtPos first position currentModules with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the second constant
                match
                  collectConstBodyHoverInfoAtPos second position currentModules
                with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over one of the rest constants
                  rest
                  |> Stdlib.List.filterMap (fun (_, c) ->
                    collectConstBodyHoverInfoAtPos c position currentModules)
                  |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | CEnum(r, typeName, caseName, fields, _sd) ->
            // check if position is within the Enum constant range
            if isLineNumberInRange position r then
              collectEnumHoverInfo
                typeName
                caseName
                fields
                position
                r
                pm
                owner
                currentModules
                HoverInformation.collectConstBodyHoverInfoAtPos
            else
              Stdlib.Option.Option.None

          | _ -> Stdlib.Option.Option.None

        /// Collect hover information for a constant declaration at a given position
        let collectConstHoverInfoAtPos
          (c: WrittenTypes.ConstantDeclaration.ConstantDeclaration)
          (position: LanguageServerProtocol.Position.Position)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          // check if we are hovering over the const keyword
          match checkIfPositionWithinRange position c.keywordConst with
          | Some r ->
            let metadata = Stdlib.Option.Option.None
            let description = KeywordDescription.getKeywordDescription "const"

            Stdlib.Option.Option.Some(createHoverInfo r description metadata)

          | None ->
            // check if we are hovering over the constant name
            match checkIfPositionWithinRange position c.name.range with
            | Some r ->
              let fqName =
                (Stdlib.String.join currentModules ".")
                |> (fun currentModules ->
                  if currentModules == "" then
                    c.name.name
                  else
                    currentModules ++ "." ++ c.name.name)

              let metadata =
                Stdlib.Option.Option.Some("Fully qualified name: " ++ fqName)

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None ->
              // check if we are hovering over the constant body
              collectConstBodyHoverInfoAtPos c.body position currentModules


        // ---------------------------
        // Function declaration Hover Info
        // ---------------------------
        let collectFnParameterHoverInfoAtPos
          (p: WrittenTypes.FnDeclaration.Parameter)
          (position: LanguageServerProtocol.Position.Position)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match p with
          | Unit r -> createBuiltinTypeInfoIfInRange r "Unit" position
          | Normal np ->
            // check if we are hovering over a parameter
            match checkIfPositionWithinRange position np.range with
            | Some r ->
              // check if we are hovering over the parameter name
              match checkIfPositionWithinRange position np.name.range with
              | Some r ->
                let onMissing = LanguageTools.NameResolver.OnMissing.Allow
                let pm = LanguageTools.PackageManager.pm ()

                let owner =
                  match currentModules |> Stdlib.List.head with
                  | Some o -> o
                  | None -> ""

                let modules =
                  currentModules |> Stdlib.List.tail |> Stdlib.Option.withDefault []

                let typ =
                  (WrittenTypesToProgramTypes.TypeReference.toPT
                    onMissing
                    pm
                    owner
                    modules
                    np.typ)
                  |> Stdlib.Tuple2.first

                let typAsString = PrettyPrinter.ProgramTypes.typeReference

                let metadata =
                  Stdlib.Option.Option.Some(np.name.name ++ " : " ++ typAsString typ)

                let description =
                  Stdlib.Option.Option.Some(
                    "TODO: add description when /// comments are supported"
                  )

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the parameter type
                collectTypeRefHoverInfoAtPos np.typ position pm owner currentModules

            | None -> Stdlib.Option.Option.None

        let collectFnHoverInfoAtPos
          (f: WrittenTypes.FnDeclaration.FnDeclaration)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          // check if we are hovering over the let keyword
          match checkIfPositionWithinRange position f.keywordLet with
          | Some r ->
            let metadata = Stdlib.Option.Option.None
            let description = KeywordDescription.getKeywordDescription "let"

            Stdlib.Option.Option.Some(createHoverInfo r description metadata)

          | None ->
            // check if we are hovering over the function name
            match checkIfPositionWithinRange position f.name.range with
            | Some r ->
              let fqName =
                (Stdlib.String.join currentModules ".")
                |> (fun currentModules ->
                  if currentModules == "" then
                    f.name.name
                  else
                    currentModules ++ "." ++ f.name.name)

              let metadata =
                Stdlib.Option.Option.Some("Fully qualified name: " ++ fqName)

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None ->
              // check if we are hovering over the function type parameters
              let typeParams =
                f.typeParams
                |> Stdlib.List.filterMap (fun (range, name) ->
                  match checkIfPositionWithinRange position range with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("Type parameter")

                    let description = Stdlib.Option.Option.None

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )

                  | None -> Stdlib.Option.Option.None)

                |> Stdlib.List.head

              match typeParams with
              | Some _ -> typeParams
              | None ->
                // check if we are hovering over the function parameters
                let parameters =
                  f.parameters
                  |> Stdlib.List.filterMap (fun p ->
                    p |> collectFnParameterHoverInfoAtPos position currentModules)
                  |> Stdlib.List.head

                match parameters with
                | Some _ -> parameters
                | None ->
                  // check if we are hovering over the function return type
                  let returnType =
                    f.returnType
                    |> collectTypeRefHoverInfoAtPos position pm owner currentModules

                  match returnType with
                  | Some _ -> returnType
                  | None ->
                    // check if we are hovering over the function body
                    collectExpressionHoverInfoAtPos
                      f.body
                      position
                      pm
                      owner
                      currentModules


        // ---------------------------
        // Expression Hover Info
        // ---------------------------
        /// Collect hover information for match expression at a given position
        let collectMatchPatternHoverInfoAtPos
          (mp: WrittenTypes.MatchPattern)
          (position: LanguageServerProtocol.Position.Position)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match mp with
          | MPUnit r -> Stdlib.Option.Option.None
          | MPBool(r, _) -> Stdlib.Option.Option.None
          | MPInt8(r, _, _) -> Stdlib.Option.Option.None
          | MPUInt8(r, _, _) -> Stdlib.Option.Option.None
          | MPInt16(r, _, _) -> Stdlib.Option.Option.None
          | MPUInt16(r, _, _) -> Stdlib.Option.Option.None
          | MPInt32(r, _, _) -> Stdlib.Option.Option.None
          | MPUInt32(r, _, _) -> Stdlib.Option.Option.None
          | MPInt64(r, _, _) -> Stdlib.Option.Option.None
          | MPUInt64(r, _, _) -> Stdlib.Option.Option.None
          | MPInt128(r, _, _) -> Stdlib.Option.Option.None
          | MPUInt128(r, _, _) -> Stdlib.Option.Option.None
          | MPFloat(r, _, _, _) -> Stdlib.Option.Option.None
          | MPChar(r, _, _, _) -> Stdlib.Option.Option.None
          | MPString(r, _, _, _) -> Stdlib.Option.Option.None
          | MPList(r, contents, _, _) ->
            // check if position is within the List range
            match checkIfPositionWithinRange position r with
            | Some r ->
              contents
              |> Stdlib.List.filterMap (fun (c, _) ->
                collectMatchPatternHoverInfoAtPos c position currentModules)
              |> Stdlib.List.head
            | None -> Stdlib.Option.Option.None

          | MPListCons(r, head, tail, symbolCons) ->
            // check if position is within the List cons range
            if isLineNumberInRange position r then
              // check if we are hovering over the cons symbol
              match checkIfPositionWithinRange position symbolCons with
              | Some r ->
                let metadata = Stdlib.Option.Option.None

                let description =
                  Stdlib.Option.Option.Some(
                    "Cons operator: used to decompose a list into its head (first element) and tail (remaining elements)"
                  )

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the head
                match
                  collectMatchPatternHoverInfoAtPos head position currentModules
                with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over the tail
                  collectMatchPatternHoverInfoAtPos tail position currentModules
            else
              Stdlib.Option.Option.None

          | MPTuple(r, first, _, second, rest, _, _) ->
            // check if position is within the Tuple range
            if isLineNumberInRange position r then
              // check if we are hovering over the first match pattern
              match
                collectMatchPatternHoverInfoAtPos first position currentModules
              with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the second match pattern
                match
                  collectMatchPatternHoverInfoAtPos second position currentModules
                with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over the rest match patterns
                  rest
                  |> Stdlib.List.filterMap (fun (_, mp) ->
                    collectMatchPatternHoverInfoAtPos mp position currentModules)
                  |> Stdlib.List.head

            else
              Stdlib.Option.Option.None

          | MPVariable(r, _) -> Stdlib.Option.Option.None
          | MPEnum(r, caseName, fieldPats) ->
            // check if position is within the Enum range
            if isLineNumberInRange position r then
              // check if we are hovering over the enum case name
              let (caseNameRange, _) = caseName

              match checkIfPositionWithinRange position caseNameRange with
              | Some r ->
                let metadata = Stdlib.Option.Option.Some("TODO: MPEnum case")

                let description =
                  Stdlib.Option.Option.Some(
                    "TODO: add description when /// comments are supported"
                  )

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the field patterns
                fieldPats
                |> Stdlib.List.filterMap (fun mp ->
                  collectMatchPatternHoverInfoAtPos mp position currentModules)
                |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | _ -> Stdlib.Option.Option.None

        let collectMatchCaseHoverInfoAtPos
          (mc: WrittenTypes.MatchCase)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          let (_, matchPattern, _) = mc.pat

          // check if we are hovering over the match case pattern
          match
            collectMatchPatternHoverInfoAtPos matchPattern position currentModules
          with
          | Some r -> Stdlib.Option.Option.Some r
          | None ->
            // check if we are hovering over the match case rhs
            match
              collectExpressionHoverInfoAtPos mc.rhs position pm owner currentModules
            with
            | Some r -> Stdlib.Option.Option.Some r
            | None ->
              match mc.whenCondition with
              | Some((whenKeyword, expr)) ->
                // check if we are hovering over the when keyword
                match checkIfPositionWithinRange position whenKeyword with
                | Some r ->
                  match KeywordDescription.getKeywordDescription "when" with
                  | Some description ->
                    let metadata = Stdlib.Option.Option.Some("")
                    let description = Stdlib.Option.Option.Some(description)

                    Stdlib.Option.Option.Some(createHoverInfo r description metadata)

                  | None -> Stdlib.Option.Option.None

                | None ->
                  // check if we are hovering over the when condition expression
                  collectExpressionHoverInfoAtPos
                    expr
                    position
                    pm
                    owner
                    currentModules

              | None -> Stdlib.Option.Option.None


        /// Collect hover information for Infix operations at a given position
        let collectInfixFnNameHoverInfoAtPos
          (i: WrittenTypes.InfixFnName)
          (range: WrittenTypes.Range)
          : Stdlib.Option.Option<Info> =
          match i with
          | ArithmeticPlus ->
            let metadata = Stdlib.Option.Option.Some("Arithmetic plus")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ArithmeticMinus ->
            let metadata = Stdlib.Option.Option.Some("Arithmetic minus")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ArithmeticMultiply ->
            let metadata = Stdlib.Option.Option.Some("Arithmetic multiply")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ArithmeticDivide ->
            let metadata = Stdlib.Option.Option.Some("Arithmetic divide")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ArithmeticModulo ->
            let metadata = Stdlib.Option.Option.Some("Arithmetic modulo")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ArithmeticPower ->
            let metadata = Stdlib.Option.Option.Some("Arithmetic power")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ComparisonGreaterThan ->
            let metadata = Stdlib.Option.Option.Some("Comparison greater than")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ComparisonGreaterThanOrEqual ->
            let metadata =
              Stdlib.Option.Option.Some("Comparison greater than or equal")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ComparisonLessThan ->
            let metadata = Stdlib.Option.Option.Some("Comparison less than")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ComparisonLessThanOrEqual ->
            let metadata = Stdlib.Option.Option.Some("Comparison less than or equal")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ComparisonEquals ->
            let metadata = Stdlib.Option.Option.Some("Comparison equals")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | ComparisonNotEquals ->
            let metadata = Stdlib.Option.Option.Some("Comparison not equals")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | StringConcat ->
            let metadata = Stdlib.Option.Option.Some("String concat")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

        let collectBinOpHoverInfoAtPos
          (b: WrittenTypes.BinaryOperation)
          (range: WrittenTypes.Range)
          : Stdlib.Option.Option<Info> =
          match b with
          | BinOpAnd ->
            let metadata = Stdlib.Option.Option.Some("Logical and")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

          | BinOpOr ->
            let metadata = Stdlib.Option.Option.Some("Logical or")

            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            Stdlib.Option.Option.Some(createHoverInfo range description metadata)

        let collectInfixHoverInfoAtPos
          (infix: WrittenTypes.Infix)
          (range: WrittenTypes.Range)
          : Stdlib.Option.Option<Info> =
          match infix with
          | InfixFnCall i -> collectInfixFnNameHoverInfoAtPos i range
          | BinOp b -> collectBinOpHoverInfoAtPos b range


        /// Collect hover information for let pattern at a given position
        let collectLetPatternHoverInfoAtPos
          (lp: WrittenTypes.LetPattern)
          (position: LanguageServerProtocol.Position.Position)
          : Stdlib.Option.Option<Info> =
          match lp with
          | LPUnit r ->
            // check if position is within the Unit range
            match checkIfPositionWithinRange position r with
            | Some r ->
              let metadata = Stdlib.Option.Option.Some("Unit let pattern")
              let description = Stdlib.Option.Option.None

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None -> Stdlib.Option.Option.None

          | LPVariable(r, _) ->
            // check if position is within the Variable range
            match checkIfPositionWithinRange position r with
            | Some r ->
              let metadata = Stdlib.Option.Option.Some("TODO: LPVariable")
              let description = Stdlib.Option.Option.None

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None -> Stdlib.Option.Option.None

          | LPTuple(r, first, _, second, rest, _, _) ->
            // check if position is within the Tuple range
            if isLineNumberInRange position r then
              // check if we are hovering over the first let pattern
              match collectLetPatternHoverInfoAtPos first position with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the second let pattern
                match collectLetPatternHoverInfoAtPos second position with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over one of the rest let patterns
                  rest
                  |> Stdlib.List.filterMap (fun (_, lp) ->
                    collectLetPatternHoverInfoAtPos lp position)
                  |> Stdlib.List.head

            else
              Stdlib.Option.Option.None

        let collectEnumHoverInfo
          (typeName: WrittenTypes.QualifiedTypeIdentifier)
          (caseName: (WrittenTypes.Range * String))
          (fields: List<'a>)
          (position: LanguageServerProtocol.Position.Position)
          (range: WrittenTypes.Range)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          (hoverInfoFn:
            'a
              -> LanguageServerProtocol.Position.Position
              -> List<String>
              -> Stdlib.Option.Option<Info>)
          : Stdlib.Option.Option<Info> =
          // check if we are hovering over the fully qualified type name
          match checkIfPositionWithinRange position typeName.range with
          | Some r ->
            let modules =
              typeName.modules
              |> Stdlib.List.filterMap (fun (m, _) ->
                match checkIfPositionWithinRange position m.range with
                | Some r ->
                  let metadata = Stdlib.Option.Option.Some("Module name")

                  let description =
                    Stdlib.Option.Option.Some(
                      "TODO: add description when /// comments are supported"
                    )

                  Stdlib.Option.Option.Some(createHoverInfo r description metadata)
                | None -> Stdlib.Option.Option.None)

              |> Stdlib.List.head

            // check if we are hovering over one of the module names
            match modules with
            | Some r -> Stdlib.Option.Option.Some r
            | None ->
              // check if we are hovering over the type name
              match checkIfPositionWithinRange position typeName.typ.range with
              | Some r ->
                let modules =
                  typeName.modules |> Stdlib.List.map (fun (name, _) -> name.name)

                let name = typeName.typ.name
                let range = typeName.typ.range
                let fqName = Stdlib.List.append modules [ name ]

                let typ = tryGetPkgType fqName pm owner currentModules

                match typ with
                | Some t ->
                  let prettyType = PrettyPrinter.ProgramTypes.packageType t

                  let metadata =
                    Stdlib.Option.Option.Some(createCodeSnippet prettyType)

                  let description =
                    Stdlib.Option.Option.Some("//TODO: add description")

                  Stdlib.Option.Option.Some(
                    createHoverInfo range description metadata
                  )
                | None -> Stdlib.Option.Option.None
              | None -> Stdlib.Option.Option.None

          | None ->
            // check if we are hovering over the case name
            let (cnRange, camaseName) = caseName

            match checkIfPositionWithinRange position cnRange with
            | Some r ->
              let metadata = Stdlib.Option.Option.Some("Enum case")

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None ->
              // check if we are hovering over one of the fields
              fields
              |> Stdlib.List.filterMap (fun exprOrConst ->
                hoverInfoFn exprOrConst position currentModules)
              |> Stdlib.List.head


        /// Collect hover information for a PipeExpr at a given position
        let collectPipeExprHoverInfoAtPos
          (pe: WrittenTypes.PipeExpr)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match pe with
          | EPipeInfix(r, op, expr) ->
            // check if position is within the PipeInfix range
            if isLineNumberInRange position r then
              let (range, infix) = op
              // check if we are hovering over an infix operator
              match checkIfPositionWithinRange position range with
              | Some r -> collectInfixHoverInfoAtPos infix r
              | None ->
                // check if we are hovering over the expression
                collectExpressionHoverInfoAtPos expr position pm owner currentModules
            else
              Stdlib.Option.Option.None

          | EPipeLambda(r, pats, body, keywordFun, _symbolArrow) ->
            // check if position is within the PipeLambda range
            if isLineNumberInRange position r then
              // check if we are hovering over the fun keyword
              match checkIfPositionWithinRange position keywordFun with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "fun"

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over one of the let patterns
                let pats =
                  pats
                  |> Stdlib.List.filterMap (fun lp ->
                    collectLetPatternHoverInfoAtPos lp position)
                  |> Stdlib.List.head

                match pats with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over the body
                  collectExpressionHoverInfoAtPos
                    body
                    position
                    pm
                    owner
                    currentModules
            else
              Stdlib.Option.Option.None


          | EPipeEnum(r, typeName, caseName, fields, _symbolDot) ->
            if isLineNumberInRange position r then
              collectEnumHoverInfo
                typeName
                caseName
                fields
                position
                r
                pm
                owner
                currentModules
                HoverInformation.collectExpressionHoverInfoAtPos
            else
              Stdlib.Option.Option.None

          | EPipeFnCall(r, fnName, args) ->
            // check if position is within the PipeFnCall range first
            if isLineNumberInRange position r then
              // check if we are hovering over the fn name
              match checkIfPositionWithinRange position fnName.range with
              | Some r ->
                // check if we are hovering over one of the module names
                let modules =
                  fnName.modules
                  |> Stdlib.List.filterMap (fun (m, _) ->
                    match checkIfPositionWithinRange position m.range with
                    | Some r ->
                      let metadata = Stdlib.Option.Option.Some("Module name")

                      let description =
                        Stdlib.Option.Option.Some(
                          "TODO: add description when /// comments are supported"
                        )

                      Stdlib.Option.Option.Some(
                        createHoverInfo r description metadata
                      )

                    | None -> Stdlib.Option.Option.None)
                  |> Stdlib.List.head

                match modules with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  let modules =
                    fnName.modules |> Stdlib.List.map (fun (name, _) -> name.name)

                  let name = fnName.fn.name
                  // TODO: the range doesn't seem right, recheck parser code
                  let range = fnName.fn.range
                  let fn = Stdlib.List.append modules [ name ]

                  match
                    tryGetFnAndCollectHoverInfo fn range pm owner currentModules
                  with
                  | Some r -> Stdlib.Option.Option.Some r
                  | None ->
                    fnName.typeArgs
                    |> Stdlib.List.filterMap (fun tr ->
                      collectTypeRefHoverInfoAtPos
                        tr
                        position
                        pm
                        owner
                        currentModules)
                    |> Stdlib.List.head

              | None ->
                let typeArgs =
                  fnName.typeArgs
                  |> Stdlib.List.filterMap (fun tr ->
                    collectTypeRefHoverInfoAtPos tr position pm owner currentModules)
                  |> Stdlib.List.head

                // check if we are hovering over one of the arguments
                args
                |> Stdlib.List.filterMap (fun expr ->
                  collectExpressionHoverInfoAtPos
                    expr
                    position
                    pm
                    owner
                    currentModules)
                |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | EPipeVariableOrFnCall(r, name) ->
            // check if position is within the PipeExpr range
            if isLineNumberInRange position r then
              match tryGetFnAndCollectHoverInfo name r pm owner currentModules with
              | Some r -> Stdlib.Option.Option.Some r
              | None -> Stdlib.Option.Option.None // TODO: EPipeVariable

            else
              Stdlib.Option.Option.None


        let collectExpressionHoverInfoAtPos
          (e: WrittenTypes.Expr)
          (position: LanguageServerProtocol.Position.Position)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModules: List<String>)
          : Stdlib.Option.Option<Info> =
          match e with
          | EList(r, contents, sob, scb) ->
            // check if position is within the List range
            if isLineNumberInRange position r then
              // check if we are hovering over one of the List contents
              contents
              |> Stdlib.List.filterMap (fun (c, _) ->
                collectExpressionHoverInfoAtPos c position pm owner currentModules)
              |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | EDict(r, contents, keywordDict, sob, scb) ->
            // check if position is within the Dict range
            if isLineNumberInRange position r then
              // check if we are hovering over the Dict keyword
              match checkIfPositionWithinRange position keywordDict with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "Dict"

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over one of the Dict contents
                contents
                |> Stdlib.List.filterMap (fun (_, k, v) ->
                  let (keyRange, key) = k

                  match checkIfPositionWithinRange position keyRange with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("Dict key")

                    let description =
                      Stdlib.Option.Option.Some(
                        "TODO: add description when /// comments are supported"
                      )

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )

                  | None ->
                    collectExpressionHoverInfoAtPos
                      v
                      position
                      pm
                      owner
                      currentModules)
                |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | ETuple(r, first, sc, second, rest, _, _) ->
            // check if position is within the Tuple range
            if isLineNumberInRange position r then
              // check if we are hovering over the first expression
              match
                collectExpressionHoverInfoAtPos
                  first
                  position
                  pm
                  owner
                  currentModules
              with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the second expression
                match
                  collectExpressionHoverInfoAtPos
                    second
                    position
                    pm
                    owner
                    currentModules
                with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over one of the rest expressions
                  rest
                  |> Stdlib.List.filterMap (fun (_, e) ->
                    collectExpressionHoverInfoAtPos
                      e
                      position
                      pm
                      owner
                      currentModules)
                  |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | ERecord(r, typeName, fields, _, _) ->
            // check if position is within the Record range
            if isLineNumberInRange position r then
              let (tnRange, typeName) =
                match typeName with
                | Unresolved(range, name) -> (range, name)

              match checkIfPositionWithinRange position tnRange with
              | Some range ->
                let typ = tryGetPkgType typeName pm owner currentModules

                match typ with
                | Some t ->
                  let prettyType = PrettyPrinter.ProgramTypes.packageType t

                  let fqName =
                    (Stdlib.List.append t.name.modules [ t.name.name ])
                    |> Stdlib.String.join "."

                  let metadata =
                    Stdlib.Option.Option.Some(
                      "Fully qualified name: "
                      ++ fqName
                      ++ "\n\n"
                      ++ createCodeSnippet prettyType
                    )

                  let description =
                    Stdlib.Option.Option.Some(
                      "TODO: add description when /// comments are supported"
                    )

                  Stdlib.Option.Option.Some(
                    createHoverInfo range description metadata
                  )

                | None -> Stdlib.Option.Option.None

              | None ->
                fields
                |> Stdlib.List.filterMap (fun (_, fieldName, expr) ->
                  let (fieldNameRange, name) = fieldName

                  match checkIfPositionWithinRange position fieldNameRange with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("Field name")

                    let description =
                      Stdlib.Option.Option.Some(
                        "TODO: add description when /// comments are supported"
                      )

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )

                  | None ->
                    collectExpressionHoverInfoAtPos
                      expr
                      position
                      pm
                      owner
                      currentModules)

                |> Stdlib.List.head

            else
              Stdlib.Option.Option.None

          | ERecordUpdate(r, record, updates, _sob, _scb, keywordWith) ->
            // check if position is within the RecordUpdate range
            if isLineNumberInRange position r then
              // check if we are hovering over the record expression
              match
                collectExpressionHoverInfoAtPos
                  record
                  position
                  pm
                  owner
                  currentModules
              with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the with keyword
                match checkIfPositionWithinRange position keywordWith with
                | Some r ->
                  let metadata = Stdlib.Option.Option.None
                  let description = KeywordDescription.getKeywordDescription "with"

                  Stdlib.Option.Option.Some(createHoverInfo r description metadata)
                | None ->
                  // check if we are hovering over one of the updates
                  updates
                  |> Stdlib.List.filterMap (fun (fieldName, _, expr) ->
                    let (range, name) = fieldName

                    match checkIfPositionWithinRange position range with
                    | Some r ->
                      let metadata = Stdlib.Option.Option.Some("Field name")

                      let description =
                        Stdlib.Option.Option.Some("//TODO: add description")

                      Stdlib.Option.Option.Some(
                        createHoverInfo r description metadata
                      )

                    | None ->
                      collectExpressionHoverInfoAtPos
                        expr
                        position
                        pm
                        owner
                        currentModules)
                  |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | EEnum(r, typeName, caseName, fields, _) ->
            if isLineNumberInRange position r then
              collectEnumHoverInfo
                typeName
                caseName
                fields
                position
                r
                pm
                owner
                currentModules
                HoverInformation.collectExpressionHoverInfoAtPos
            else
              Stdlib.Option.Option.None

          | ELet(r, letPattern, expr, body, keywordLet, _) ->
            // check if position is within the Let range
            if isLineNumberInRange position r then
              // check if we are hovering over the let keyword
              match checkIfPositionWithinRange position keywordLet with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "let"

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the let pattern
                match collectLetPatternHoverInfoAtPos letPattern position with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over the let expression
                  match
                    collectExpressionHoverInfoAtPos
                      expr
                      position
                      pm
                      owner
                      currentModules
                  with
                  | Some r -> Stdlib.Option.Option.Some r
                  | None ->
                    // check if we are hovering over the let body
                    collectExpressionHoverInfoAtPos
                      body
                      position
                      pm
                      owner
                      currentModules
            else
              Stdlib.Option.Option.None

          | EVariable(r, name) ->
            match checkIfPositionWithinRange position r with
            | Some r ->
              let metadata = Stdlib.Option.Option.Some("Variable //TODO")

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              Stdlib.Option.Option.Some(createHoverInfo r description metadata)

            | None -> Stdlib.Option.Option.None

          | EFieldAccess(r, expr, fieldName, _symbolDot) ->
            // check if we are hovering over a field access expression range
            if isLineNumberInRange position r then
              // check if we are hovering over the expression
              match
                collectExpressionHoverInfoAtPos expr position pm owner currentModules
              with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the field name
                let (fnRange, name) = fieldName

                match checkIfPositionWithinRange position fnRange with
                | Some r ->
                  let metadata = Stdlib.Option.Option.Some("Field name")

                  let description =
                    Stdlib.Option.Option.Some(
                      "TODO: add description when /// comments are supported"
                    )

                  Stdlib.Option.Option.Some(createHoverInfo r description metadata)

                | None -> Stdlib.Option.Option.None

            else
              Stdlib.Option.Option.None

          | EIf(r, cond, thenExpr, elseExpr, keywordIf, keywordThen, keywordElse) ->
            // check if we are hovering over an if expression range
            if isLineNumberInRange position r then
              // check if we are hovering over the if keyword
              match checkIfPositionWithinRange position keywordIf with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "if"

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over the condition
                match
                  collectExpressionHoverInfoAtPos
                    cond
                    position
                    pm
                    owner
                    currentModules
                with
                | Some c -> Stdlib.Option.Option.Some(c)
                | None ->
                  // check if we are hovering over the then keyword
                  match checkIfPositionWithinRange position keywordThen with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.None
                    let description = KeywordDescription.getKeywordDescription "then"

                    Stdlib.Option.Option.Some(createHoverInfo r description metadata)

                  | None ->
                    // check if we are hovering over the then expression
                    match
                      collectExpressionHoverInfoAtPos
                        thenExpr
                        position
                        pm
                        owner
                        currentModules
                    with
                    | Some t -> Stdlib.Option.Option.Some(t)
                    | None ->
                      // check if we are hovering over the else keyword
                      match keywordElse with
                      | Some r ->
                        match checkIfPositionWithinRange position r with
                        | Some r ->
                          let metadata = Stdlib.Option.Option.None

                          let description =
                            KeywordDescription.getKeywordDescription "else"

                          Stdlib.Option.Option.Some(
                            createHoverInfo r description metadata
                          )

                        | None ->
                          // check if we are hovering over the else expression
                          match elseExpr with
                          | Some e ->
                            collectExpressionHoverInfoAtPos
                              e
                              position
                              pm
                              owner
                              currentModules
                          | None -> Stdlib.Option.Option.None

                      | None -> Stdlib.Option.Option.None
            else
              Stdlib.Option.Option.None

          | EMatch(r, expr, cases, keywordMatch, keywordWith) ->
            // check if we are hovering over a match expression range
            if isLineNumberInRange position r then
              // check if we are hovering over the match keyword
              match checkIfPositionWithinRange position keywordMatch with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "match"

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)
              | None ->
                // check if we are hovering over the expression
                match
                  collectExpressionHoverInfoAtPos
                    expr
                    position
                    pm
                    owner
                    currentModules
                with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over the with keyword
                  match checkIfPositionWithinRange position keywordWith with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.None
                    let description = KeywordDescription.getKeywordDescription "with"

                    Stdlib.Option.Option.Some(createHoverInfo r description metadata)

                  | None ->
                    // check if we are hovering over one of the match cases
                    cases
                    |> Stdlib.List.filterMap (fun c ->
                      collectMatchCaseHoverInfoAtPos
                        c
                        position
                        pm
                        owner
                        currentModules)
                    |> Stdlib.List.head

            else
              Stdlib.Option.Option.None

          | EPipe(r, expr, pipeExprs) ->
            // check if we are hovering over a pipe expression range
            if isLineNumberInRange position r then
              // check if we are hovering over the expression
              match
                collectExpressionHoverInfoAtPos expr position pm owner currentModules
              with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                // check if we are hovering over the pipe expression
                pipeExprs
                |> Stdlib.List.filterMap (fun (_, pe) ->
                  collectPipeExprHoverInfoAtPos pe position pm owner currentModules)
                |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | EInfix(r, op, left, right) ->
            if isLineNumberInRange position r then
              let (opRange, op) = op

              match checkIfPositionWithinRange position opRange with
              | Some range ->
                match collectInfixHoverInfoAtPos op range with
                | Some r -> Stdlib.Option.Option.Some r
                | None -> Stdlib.Option.Option.None

              | None ->
                match
                  collectExpressionHoverInfoAtPos
                    left
                    position
                    pm
                    owner
                    currentModules
                with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  collectExpressionHoverInfoAtPos
                    right
                    position
                    pm
                    owner
                    currentModules

            else
              Stdlib.Option.Option.None

          | ELambda(r, pats, body, keywordFun, _symbolArrow) ->
            // check if position is within the Lambda range
            if isLineNumberInRange position r then
              // check if we are hovering over the fun keyword
              match checkIfPositionWithinRange position keywordFun with
              | Some r ->
                let metadata = Stdlib.Option.Option.None
                let description = KeywordDescription.getKeywordDescription "fun"

                Stdlib.Option.Option.Some(createHoverInfo r description metadata)

              | None ->
                // check if we are hovering over one of the lambda patterns
                let pats =
                  pats
                  |> Stdlib.List.filterMap (fun lp ->
                    collectLetPatternHoverInfoAtPos lp position)
                  |> Stdlib.List.head

                match pats with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  // check if we are hovering over the lambda body
                  collectExpressionHoverInfoAtPos
                    body
                    position
                    pm
                    owner
                    currentModules

            else
              Stdlib.Option.Option.None

          | EApply(r, lhs, typeArgs, args) ->
            // check if position is within the EApply range
            if isLineNumberInRange position r then
              // check if we are hovering over the lhs expression
              match
                collectExpressionHoverInfoAtPos lhs position pm owner currentModules
              with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                match
                  typeArgs
                  |> Stdlib.List.filterMap (fun tr ->
                    collectTypeRefHoverInfoAtPos tr position pm owner currentModules)
                  |> Stdlib.List.head
                with
                | Some r -> Stdlib.Option.Option.Some r
                | None ->
                  args
                  |> Stdlib.List.filterMap (fun e ->
                    collectExpressionHoverInfoAtPos
                      e
                      position
                      pm
                      owner
                      currentModules)
                  |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | EFnName(r, name) ->
            // check if position is within the EFnName range
            if isLineNumberInRange position r then
              match checkIfPositionWithinRange position name.fn.range with
              | Some r ->
                let modules = name.modules |> Stdlib.List.map (fun (m, _) -> m.name)
                let fnName = Stdlib.List.append modules [ name.fn.name ]

                tryGetFnAndCollectHoverInfo
                  fnName
                  name.fn.range
                  pm
                  owner
                  currentModules

              | None ->
                name.modules
                |> Stdlib.List.filterMap (fun (m, _) ->
                  match checkIfPositionWithinRange position m.range with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("Module name")

                    let description =
                      Stdlib.Option.Option.Some(
                        "TODO: add description when /// comments are supported"
                      )

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )

                  | None -> Stdlib.Option.Option.None)
                |> Stdlib.List.head
            else
              Stdlib.Option.Option.None

          | EConstantOrFn(r, fnOrConstName) ->
            // check if position is within the EConstantOrFn range
            if isLineNumberInRange position r then
              let modules =
                fnOrConstName.modules
                |> Stdlib.List.filterMap (fun (m, _) ->
                  match checkIfPositionWithinRange position m.range with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("Module name")

                    let description =
                      Stdlib.Option.Option.Some(
                        "TODO: add description when /// comments are supported"
                      )

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )
                  | None -> Stdlib.Option.Option.None)

                |> Stdlib.List.head

              match modules with
              | Some r -> Stdlib.Option.Option.Some r
              | None ->
                let modules =
                  fnOrConstName.modules |> Stdlib.List.map (fun (m, _) -> m.name)

                let fnOrConstantName =
                  Stdlib.List.append modules [ fnOrConstName.constantOrFn.name ]

                match checkIfPositionWithinRange position r with
                | Some r ->
                  // check if we are hovering over a function
                  match
                    tryGetFnAndCollectHoverInfo
                      fnOrConstantName
                      r
                      pm
                      owner
                      currentModules
                  with
                  | Some r -> Stdlib.Option.Option.Some r

                  // match getFunction with
                  // | Some f ->
                  //   let prettyFn = PrettyPrinter.ProgramTypes.packageFn f
                  //   let signature = fnSignature f

                  //   let fqName =
                  //     (Stdlib.List.append f.name.modules [ f.name.name ])
                  //     |> Stdlib.String.join "."

                  //   let metadata =
                  //     Stdlib.Option.Option.Some(
                  //       "Fully qualified name: "
                  //       ++ fqName
                  //       ++ "\n\n"
                  //       ++ (createCodeSnippet signature)
                  //       ++ "\n\n"
                  //       ++ (createCodeSnippet prettyFn)
                  //     )

                  //   let description =
                  //     Stdlib.Option.Option.Some("//TODO: add description")

                  //   Stdlib.Option.Option.Some(
                  //     createHoverInfo
                  //       fnOrConstName.constantOrFn.range
                  //       description
                  //       metadata
                  //   )

                  | None ->
                    // check if we are hovering over a constant
                    let getConstant =
                      tryGetPkgConst fnOrConstantName pm owner currentModules

                    match getConstant with
                    | Some c ->
                      let prettyConst = PrettyPrinter.ProgramTypes.packageConstant c

                      let fqName =
                        (Stdlib.List.append c.name.modules [ c.name.name ])
                        |> Stdlib.String.join "."

                      let metadata =
                        Stdlib.Option.Option.Some(
                          "Fully qualified name: "
                          ++ fqName
                          ++ "\n\n"
                          ++ createCodeSnippet prettyConst
                        )

                      let description =
                        Stdlib.Option.Option.Some("//TODO: add description")

                      Stdlib.Option.Option.Some(
                        createHoverInfo
                          fnOrConstName.constantOrFn.range
                          description
                          metadata
                      )

                    | None -> Stdlib.Option.Option.None
                | None -> Stdlib.Option.Option.None

            else
              Stdlib.Option.Option.None

          | _ -> Stdlib.Option.Option.None


        // ---------------------------
        // Source File Hover Info
        // ---------------------------
        let collectNodeHoverInfoAtPos
          (decls: List<WrittenTypes.SourceFile.SourceFileDeclaration>)
          (position: LanguageServerProtocol.Position.Position)
          (owner: String)
          (currentModules: List<String>)
          (pm: ProgramTypes.PackageManager.PackageManager)
          : Stdlib.Option.Option<Info> =
          let node =
            decls
            |> Stdlib.List.filterMap (fun decl ->
              match decl with
              | Type t ->
                // Check if position is within type range for early escape
                if isLineNumberInRange position t.range then
                  collectTypeHoverInfoAtPosition t position pm currentModules
                else
                  Stdlib.Option.Option.None

              | Constant c ->
                // Check if position is within const range for early escape
                if isLineNumberInRange position c.range then
                  collectConstHoverInfoAtPos c position currentModules
                else
                  Stdlib.Option.Option.None

              | Function f ->
                // Check if position is within function range for early escape
                if isLineNumberInRange position f.range then
                  collectFnHoverInfoAtPos f position pm owner currentModules
                else
                  Stdlib.Option.Option.None

              | Expr e ->
                collectExpressionHoverInfoAtPos e position pm owner currentModules

              | Module m ->
                // Check if position is within module range for early escape
                if isLineNumberInRange position m.range then
                  match checkIfPositionWithinRange position m.keywordModule with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.Some("")

                    let description =
                      KeywordDescription.getKeywordDescription "module"

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )

                  | None ->
                    let (nameRange, name) = m.name

                    match checkIfPositionWithinRange position nameRange with
                    | Some r ->
                      let metadata =
                        Stdlib.Option.Option.Some("Fully qualified name: " ++ name)

                      let description =
                        Stdlib.Option.Option.Some(
                          "TODO: add description when /// comments are supported"
                        )

                      Stdlib.Option.Option.Some(
                        createHoverInfo r description metadata
                      )

                    | None ->
                      let currentModules =
                        Stdlib.List.append currentModules [ name ]

                      m.declarations
                      |> collectNodeHoverInfoAtPos position owner currentModules pm

                else
                  Stdlib.Option.Option.None

              | SubModule m ->
                // Check if position is within submodule range for early escape
                if isLineNumberInRange position m.range then
                  match checkIfPositionWithinRange position m.keywordModule with
                  | Some r ->
                    let metadata = Stdlib.Option.Option.None

                    let description =
                      KeywordDescription.getKeywordDescription "module"

                    Stdlib.Option.Option.Some(
                      createHoverInfo r description metadata
                    )

                  | None ->
                    let (nameRange, subModuleName) = m.name

                    match checkIfPositionWithinRange position nameRange with
                    | Some r ->
                      let fqName =
                        (Stdlib.String.join currentModules ".")
                        |> (fun currentModules ->
                          if currentModules == "" then
                            subModuleName
                          else
                            currentModules ++ "." ++ subModuleName)

                      let metadata =
                        Stdlib.Option.Option.Some(
                          "Fully qualified name: " ++ fqName
                        )

                      let description =
                        Stdlib.Option.Option.Some(
                          "TODO: add description when /// comments are supported"
                        )

                      Stdlib.Option.Option.Some(
                        createHoverInfo r description metadata
                      )


                    | None ->
                      let currentModules =
                        Stdlib.List.append currentModules [ subModuleName ]

                      m.declarations
                      |> collectNodeHoverInfoAtPos position owner currentModules pm

                else
                  Stdlib.Option.Option.None

              | _ -> Stdlib.Option.Option.None)

          node |> Stdlib.List.head


        let getTextAtRange
          (text: String)
          (range: WrittenTypes.Range)
          : Stdlib.Option.Option<String> =
          let startLine = range.start.row
          let startColumn = range.start.column
          let endColumn = range.end_.column

          let lines = text |> Stdlib.String.split "\n"
          let textLines = lines |> Stdlib.List.getAt startLine

          match textLines with
          | Some line ->
            line
            |> Stdlib.String.slice startColumn endColumn
            |> Stdlib.Option.Option.Some

          | None -> Stdlib.Option.Option.None