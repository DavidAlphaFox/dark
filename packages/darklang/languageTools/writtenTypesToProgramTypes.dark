module Darklang =
  module LanguageTools =
    module WrittenTypesToProgramTypes =
      let gid () : Int64 =
        // TODO: fix upper range here
        Stdlib.Int64.random 0L 922337203685477580L

      let gtlid () : UInt64 =
        Stdlib.UInt64.random 0UL 9223372036854775807UL


      module Identifiers =
        module Type =
          let toPT (typ: WrittenTypes.TypeIdentifier) : String = typ.name

        module QualifiedType =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (i: WrittenTypes.QualifiedTypeIdentifier)
            : ProgramTypes.NameResolution<ProgramTypes.FQTypeName.FQTypeName> =
            let nameToResolve =
              Stdlib.List.append
                (Stdlib.List.map i.modules (fun (m, _) -> m.name))
                [ i.typ.name ]

            NameResolver.TypeName.resolve
              onMissing
              []
              (WrittenTypes.Name.Unresolved(i.range, nameToResolve))


        module Fn =
          let toPT (fn: WrittenTypes.FnIdentifier) : String = fn.name

        module QualifiedFn =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (i: WrittenTypes.QualifiedFnIdentifier)
            : ProgramTypes.NameResolution<ProgramTypes.FQFnName.FQFnName> =
            let nameToResolve =
              Stdlib.List.append
                (Stdlib.List.map i.modules (fun (m, _) -> m.name))
                [ i.fn.name ]

            NameResolver.FnName.resolve
              onMissing
              []
              (WrittenTypes.Name.Unresolved(i.range, nameToResolve))


      module TypeReference =
        module Builtin =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (t: WrittenTypes.TypeReference.Builtin)
            : ProgramTypes.TypeReference =
            match t with
            | TUnit _range -> ProgramTypes.TypeReference.TUnit
            | TBool _range -> ProgramTypes.TypeReference.TBool
            | TInt8 _range -> ProgramTypes.TypeReference.TInt8
            | TUInt8 _range -> ProgramTypes.TypeReference.TUInt8
            | TInt16 _range -> ProgramTypes.TypeReference.TInt16
            | TUInt16 _range -> ProgramTypes.TypeReference.TUInt16
            | TInt32 _range -> ProgramTypes.TypeReference.TInt32
            | TUInt32 _range -> ProgramTypes.TypeReference.TUInt32
            | TInt64 _range -> ProgramTypes.TypeReference.TInt64
            | TUInt64 _range -> ProgramTypes.TypeReference.TUInt64
            | TInt128 _range -> ProgramTypes.TypeReference.TInt128
            | TUInt128 _range -> ProgramTypes.TypeReference.TUInt128
            | TFloat _range -> ProgramTypes.TypeReference.TFloat
            | TChar _range -> ProgramTypes.TypeReference.TChar
            | TString _range -> ProgramTypes.TypeReference.TString
            | TList(_range, _, _, typ, _) ->
              let typ = TypeReference.toPT onMissing typ
              ProgramTypes.TypeReference.TList(typ)

            | TDict(_range, _, _, valueType, _) ->
              let valueType = TypeReference.toPT onMissing valueType

              ProgramTypes.TypeReference.TDict valueType

            | TTuple(_range, firstType, _, secondType, restTypes, _, _) ->
              let firstType = TypeReference.toPT onMissing firstType
              let secondType = TypeReference.toPT onMissing secondType

              let restTypes =
                Stdlib.List.map restTypes (fun (_, t) ->
                  TypeReference.toPT onMissing t)

              ProgramTypes.TypeReference.TTuple(firstType, secondType, restTypes)

            | TDateTime _range -> ProgramTypes.TypeReference.TDateTime
            | TUuid _range -> ProgramTypes.TypeReference.TUuid


        let toPT
          (onMissing: NameResolver.OnMissing)
          (t: WrittenTypes.TypeReference.TypeReference)
          : ProgramTypes.TypeReference =
          match t with
          | Builtin b -> Builtin.toPT onMissing b
          | QualifiedName qn ->
            let typeName = Identifiers.QualifiedType.toPT onMissing qn

            ProgramTypes.TypeReference.TCustomType(typeName, [])


      module TypeDeclaration =
        module RecordField =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (f: WrittenTypes.TypeDeclaration.RecordField)
            : ProgramTypes.TypeDeclaration.RecordField =
            let name = f.name |> Stdlib.Tuple2.second

            ProgramTypes.TypeDeclaration.RecordField
              { name = name
                typ = TypeReference.toPT onMissing f.typ
                description = "" }

        module EnumField =
          let toPT
            (resolver: NameResolver.NameResolutionSettings)
            (f: WrittenTypes.TypeDeclaration.EnumField)
            : ProgramTypes.TypeDeclaration.EnumField =

            let label =
              match f.label with
              | Some l -> Stdlib.Option.Option.Some(l |> Stdlib.Tuple2.second)
              | None -> Stdlib.Option.Option.None

            ProgramTypes.TypeDeclaration.EnumField
              { typ = TypeReference.toPT resolver f.typ
                label = label
                description = "" }

        module EnumCase =
          let toPT
            (resolver: NameResolver.NameResolutionSettings)
            (c: WrittenTypes.TypeDeclaration.EnumCase)
            : ProgramTypes.TypeDeclaration.EnumCase =

            let name = c.name |> Stdlib.Tuple2.second

            let fields =
              Stdlib.List.map c.fields (fun f -> EnumField.toPT resolver f)

            ProgramTypes.TypeDeclaration.EnumCase
              { name = name
                fields = fields
                description = "" }

        module Definition =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (d: WrittenTypes.TypeDeclaration.Definition)
            : ProgramTypes.TypeDeclaration.Definition =

            match d with
            | Alias typ ->
              let typ = TypeReference.toPT onMissing typ
              ProgramTypes.TypeDeclaration.Definition.Alias typ

            | Enum _cases -> "TODO"

            | Record fields ->
              let fields =
                Stdlib.List.map fields (fun (f, _) -> RecordField.toPT onMissing f)

              ProgramTypes.TypeDeclaration.Definition.Record fields

            | Enum cases ->
              let cases = Stdlib.List.map cases (fun c -> EnumCase.toPT resolver c)
              ProgramTypes.TypeDeclaration.Definition.Enum cases

        let toPT
          (onMissing: NameResolver.OnMissing)
          (d: WrittenTypes.TypeDeclaration.TypeDeclaration)
          : ProgramTypes.TypeDeclaration.TypeDeclaration =
          let def = Definition.toPT onMissing d.definition

          ProgramTypes.TypeDeclaration.TypeDeclaration
            { typeParams = []; definition = def }


        let toPackageTypePT
          (onMissing: NameResolver.OnMissing)
          (owner: String)
          (modules: List<String>)
          (d: WrittenTypes.TypeDeclaration.TypeDeclaration)
          : ProgramTypes.PackageType =
          ProgramTypes.PackageType
            { tlid = gtlid ()
              id = Stdlib.Uuid.generate ()
              name =
                ProgramTypes.FQTypeName.Package
                  { owner = owner
                    modules = modules
                    name = d.name.name
                    version = 0L }
              description = ""
              declaration = toPT onMissing d
              deprecated = ProgramTypes.Deprecation.NotDeprecated }


      module InfixFnName =
        let toPT (infix: WrittenTypes.InfixFnName) : ProgramTypes.InfixFnName =
          match infix with
          | ArithmeticPlus -> ProgramTypes.InfixFnName.ArithmeticPlus
          | ArithmeticMinus -> ProgramTypes.InfixFnName.ArithmeticMinus
          | ArithmeticMultiply -> ProgramTypes.InfixFnName.ArithmeticMultiply
          | ArithmeticDivide -> ProgramTypes.InfixFnName.ArithmeticDivide
          | ArithmeticModulo -> ProgramTypes.InfixFnName.ArithmeticModulo
          | ArithmeticPower -> ProgramTypes.InfixFnName.ArithmeticPower
          | ComparisonGreaterThan -> ProgramTypes.InfixFnName.ComparisonGreaterThan
          | ComparisonGreaterThanOrEqual ->
            ProgramTypes.InfixFnName.ComparisonGreaterThanOrEqual
          | ComparisonLessThan -> ProgramTypes.InfixFnName.ComparisonLessThan
          | ComparisonLessThanOrEqual ->
            ProgramTypes.InfixFnName.ComparisonLessThanOrEqual
          | ComparisonEquals -> ProgramTypes.InfixFnName.ComparisonEquals
          | ComparisonNotEquals -> ProgramTypes.InfixFnName.ComparisonNotEquals
          | StringConcat -> ProgramTypes.InfixFnName.StringConcat


      module BinaryOperation =
        let toPT
          (binop: WrittenTypes.BinaryOperation)
          : ProgramTypes.BinaryOperation =
          match binop with
          | BinOpAnd -> ProgramTypes.BinaryOperation.BinOpAnd
          | BinOpOr -> ProgramTypes.BinaryOperation.BinOpOr


      module Infix =
        let toPT (infix: WrittenTypes.Infix) : ProgramTypes.Infix =
          match infix with
          | InfixFnCall op -> ProgramTypes.Infix.InfixFnCall(InfixFnName.toPT op)
          | BinOp op -> ProgramTypes.Infix.BinOp(BinaryOperation.toPT op)

      module Expr =
        module LetPattern =
          let toPT (p: WrittenTypes.LetPattern) : ProgramTypes.LetPattern =
            match p with
            | LPVariable(_, name) -> ProgramTypes.LetPattern.LPVariable(gid (), name)


        let toPT
          (onMissing: NameResolver.OnMissing)
          (e: WrittenTypes.Expr)
          : ProgramTypes.Expr =
          match e with
          // simple
          | EUnit _ -> ProgramTypes.Expr.EUnit(gid ())

          | EBool(_, b) -> ProgramTypes.Expr.EBool(gid (), b)
          | EInt8(_, (_, i), _) -> ProgramTypes.Expr.EInt8(gid (), i)
          | EUInt8(_, (_, i), _) -> ProgramTypes.Expr.EUInt8(gid (), i)
          | EInt16(_, (_, i), _) -> ProgramTypes.Expr.EInt16(gid (), i)
          | EUInt16(_, (_, i), _) -> ProgramTypes.Expr.EUInt16(gid (), i)
          | EInt32(_, (_, i), _) -> ProgramTypes.Expr.EInt32(gid (), i)
          | EUInt32(_, (_, i), _) -> ProgramTypes.Expr.EUInt32(gid (), i)
          | EInt64(_, (_, i), _) -> ProgramTypes.Expr.EInt64(gid (), i)
          | EUInt64(_, (_, i), _) -> ProgramTypes.Expr.EUInt64(gid (), i)
          | EInt128(_, (_, i), _) -> ProgramTypes.Expr.EInt128(gid (), i)
          | EUInt128(_, (_, i), _) -> ProgramTypes.Expr.EUInt128(gid (), i)
          | EFloat(_, s, w, f) -> ProgramTypes.Expr.EFloat(gid (), s, w, f)
          | EString(_, contents, _, _) ->
            match contents with
            | None -> ProgramTypes.Expr.EString(gid (), [])
            | Some((_, s)) ->
              ProgramTypes.Expr.EString(
                gid (),
                [ ProgramTypes.StringSegment.StringText s ]
              )
          | EChar(_, c, _, _) ->
            match c with
            | None -> ProgramTypes.Expr.EChar(gid (), "")
            | Some((_, c)) -> ProgramTypes.Expr.EChar(gid (), c)

          | EList(_, contents, _, _) ->
            ProgramTypes.Expr.EList(
              gid (),
              Stdlib.List.map contents (fun (expr, _) -> toPT onMissing expr)
            )

          | EDict(_, contents, _, _, _) ->
            ProgramTypes.Expr.EDict(
              gid (),
              Stdlib.List.map contents (fun (_, k, v) -> (k, toPT onMissing v))
            )

          | ETuple(_, first, _, second, rest, _, _) ->
            let first = toPT onMissing first
            let second = toPT onMissing second
            let rest = Stdlib.List.map rest (fun (_, e) -> toPT onMissing e)

            ProgramTypes.Expr.ETuple(gid (), first, second, rest)

          | ERecord(_, typeName, fields, _, _) ->
            let typeName = NameResolver.TypeName.resolve onMissing [] typeName

            let fields =
              Stdlib.List.map fields (fun (_, name, typeName) ->
                let fieldName = name |> Stdlib.Tuple2.second
                (fieldName, toPT onMissing typeName))

            ProgramTypes.Expr.ERecord(gid (), typeName, fields)

          | EEnum(_, typeName, caseName, fields, _) ->
            let sr = Stdlib.Tuple2.first typeName
            let unresolvedTypeName = Stdlib.Tuple2.second typeName

            let typeName =
              NameResolver.TypeName.resolve
                resolver
                []
                (WrittenTypes.Name.Unresolved sr unresolvedTypeName)

            let caseName = caseName |> Stdlib.Tuple2.second
            let fields = Stdlib.List.map fields (fun expr -> toPT resolver expr)

            ProgramTypes.Expr.EEnum(gid (), typeName, caseName, fields)

          // declaring and accessing variables
          | ELet(_, pat, rhs, body, _, _) ->
            ProgramTypes.Expr.ELet(
              gid (),
              LetPattern.toPT pat,
              toPT onMissing rhs,
              toPT onMissing body
            )

          | EVariable(_, var) -> ProgramTypes.Expr.EVariable (gid ()) var

          | EIf(_, cond, thenExpr, elseExpr, _, _, _) ->
            let elseExpr =
              elseExpr |> Stdlib.Option.map (fun es -> Expr.toPT onMissing es)

            ProgramTypes.Expr.EIf(
              gid (),
              toPT onMissing cond,
              toPT onMissing thenExpr,
              elseExpr
            )

          // fn calls
          | EInfix(_, (_, op), left, right) ->
            let infix = Infix.toPT op

            ProgramTypes.Expr.EInfix(
              gid (),
              infix,
              toPT onMissing left,
              toPT onMissing right
            )

          | EFnCall(_, fnName, args, _, _) ->
            let fnName = Identifiers.QualifiedFn.toPT onMissing fnName

            let fnNameExpr = ProgramTypes.Expr.EFnName(gid (), fnName)

            ProgramTypes.Expr.EApply(
              gid (),
              fnNameExpr,
              [],
              Stdlib.List.map args (fun a -> toPT onMissing a)
            )


      module FunctionDeclaration =
        module Parameter =
          let toPackageFnParamPT
            (onMissing: NameResolver.OnMissing)
            (p: WrittenTypes.FnDeclaration.Parameter)
            : ProgramTypes.PackageFn.Parameter =

            match p with
            | Unit p ->
              ProgramTypes.PackageFn.Parameter
                { name = "_" // TODO ok?
                  typ = ProgramTypes.TypeReference.TUnit
                  description = "" }

            | Normal p ->
              ProgramTypes.PackageFn.Parameter
                { name = p.name.name
                  typ = TypeReference.toPT onMissing p.typ
                  description = "" }

        let toPackageFnPT
          (onMissing: NameResolver.OnMissing)
          (owner: String)
          (modules: List<String>)
          (fn: WrittenTypes.FnDeclaration.FnDeclaration)
          : ProgramTypes.PackageFn.PackageFn =
          ProgramTypes.PackageFn.PackageFn
            { tlid = gtlid ()
              id = Stdlib.Uuid.generate ()
              name =
                ProgramTypes.FQFnName.Package
                  { owner = owner
                    modules = modules
                    name = fn.name.name
                    version = 0L }
              typeParams = []
              parameters =
                fn.parameters
                |> Stdlib.List.map (fun p ->
                  Parameter.toPackageFnParamPT onMissing p)
              returnType = TypeReference.toPT onMissing fn.returnType
              description = ""
              deprecated = ProgramTypes.Deprecation.NotDeprecated
              body = Expr.toPT onMissing fn.body }