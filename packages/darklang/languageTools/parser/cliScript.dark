module Darklang =
  module LanguageTools =
    module Parser =
      let updateUnparseableStuff
        (result: WrittenTypes.CliScript)
        (e: WrittenTypes.Unparseable)
        : WrittenTypes.CliScript =
        { result with
            unparseableStuff = Stdlib.List.pushBack result.unparseableStuff e }

      let parseDeclaration
        (result: Stdlib.Result.Result<WrittenTypes.CliScript, String>)
        (decl: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.CliScript, String> =
        Stdlib.Result.map result (fun result ->
          match decl.typ with
          | "type_decl" ->
            match TypeDeclaration.parse decl with
            | Error e -> updateUnparseableStuff result e
            | Ok parsedTypeDef ->
              let newType = WrittenTypes.CliScriptTypeOrFnOrConst.Type parsedTypeDef

              { result with
                  typesAndFnsAndConsts =
                    Stdlib.List.pushBack result.typesAndFnsAndConsts newType }

          | "fn_decl" ->
            match FunctionDeclaration.parse decl with
            | Error e -> updateUnparseableStuff result e

            | Ok parsedFnDecl ->
              let newFn =
                WrittenTypes.CliScriptTypeOrFnOrConst.Function parsedFnDecl

              { result with
                  typesAndFnsAndConsts =
                    Stdlib.List.pushBack result.typesAndFnsAndConsts newFn }

          | "const_decl" ->
            match ConstantDeclaration.parse decl with
            | Error e -> updateUnparseableStuff result e

            | Ok parsedConstDecl ->
              let newConst =
                WrittenTypes.CliScriptTypeOrFnOrConst.Constant parsedConstDecl

              { result with
                  typesAndFnsAndConsts =
                    Stdlib.List.pushBack result.typesAndFnsAndConsts newConst }

          | "expression" ->
            match Expr.parse decl with
            | Error e -> updateUnparseableStuff result e
            | Ok parsedExpr ->
              { result with
                  exprsToEval = Stdlib.List.pushBack result.exprsToEval parsedExpr }

          | _ ->
            updateUnparseableStuff
              result
              (WrittenTypes.Unparseable
                { source = decl
                  note = Stdlib.Option.Option.None }))

      /// Map a ParsedNode to a WrittenTypes.ParsedFile
      ///
      /// This is the entrypoint for mapping a ParsedNode to WrittenTypes
      let parseCliScript
        (node: ParsedNode)
        : Stdlib.Result.Result<WrittenTypes.ParsedFile, String> =
        if node.typ == "source_file" then
          let init =
            WrittenTypes.CliScript
              { range = node.range
                typesAndFnsAndConsts = []
                unparseableStuff = []
                exprsToEval = [] }

          let result =
            Stdlib.List.fold
              node.children
              (Stdlib.Result.Result.Ok init)
              Parser.parseDeclaration

          Stdlib.Result.map result (fun parsedResult ->
            WrittenTypes.ParsedFile.CliScript parsedResult)
        else
          Stdlib.Result.Result.Error $"Not a source_file: {node.typ}"