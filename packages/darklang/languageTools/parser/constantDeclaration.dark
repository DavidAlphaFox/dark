module Darklang =
  module LanguageTools =
    module Parser =
      module ConstantDeclaration =
        let parseBoolConst
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let b =
            match getText node with
            | "true" -> true |> Stdlib.Result.Result.Ok
            | "false" -> false |> Stdlib.Result.Result.Ok
            | _ -> createUnparseableError node

          match b with
          | Ok b ->
            (WrittenTypes.Const.CBool(node.range, b)) |> Stdlib.Result.Result.Ok
          | Error _ -> createUnparseableError node


        // Helper function for parseIntConst
        let parseIntByType
          (intText: String)
          (typ: String)
          : Stdlib.Result.Result<_res, _err> =
          match typ with
          | "int8_literal" -> Stdlib.Int8.parse intText
          | "uint8_literal" -> Stdlib.UInt8.parse intText
          | "int16_literal" -> Stdlib.Int16.parse intText
          | "uint16_literal" -> Stdlib.UInt16.parse intText
          | "int32_literal" -> Stdlib.Int32.parse intText
          | "uint32_literal" -> Stdlib.UInt32.parse intText
          | "int64_literal" -> Stdlib.Int64.parse intText
          | "uint64_literal" -> Stdlib.UInt64.parse intText
          | "int128_literal" -> Stdlib.Int128.parse intText
          | "uint128_literal" -> Stdlib.UInt128.parse intText
          | _ -> Stdlib.Result.Result.Error $"Unsupported integer type: {typ}"

        let parseIntConst
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let supportedInts =
            [ "int8_literal"
              "uint8_literal"
              "int16_literal"
              "uint16_literal"
              "int32_literal"
              "uint32_literal"
              "int64_literal"
              "uint64_literal"
              "int128_literal"
              "uint128_literal" ]

          if (Stdlib.List.member_v0 supportedInts node.typ) then
            let intPart = findField node "digits"
            let suffixPart = findField node "suffix"

            match intPart, suffixPart with
            | Ok intPart, Ok sfx ->
              let intText = getText intPart

              match parseIntByType intText node.typ with
              | Ok parsedValue ->
                let intPart = (intPart.range, parsedValue)

                let constant =
                  match node.typ with
                  | "int8_literal" ->
                    WrittenTypes.Const.CInt8(node.range, intPart, sfx.range)
                  | "uint8_literal" ->
                    WrittenTypes.Const.CUInt8(node.range, intPart, sfx.range)
                  | "int16_literal" ->
                    WrittenTypes.Const.CInt16(node.range, intPart, sfx.range)
                  | "uint16_literal" ->
                    WrittenTypes.Const.CUInt16(node.range, intPart, sfx.range)
                  | "int32_literal" ->
                    WrittenTypes.Const.CInt32(node.range, intPart, sfx.range)
                  | "uint32_literal" ->
                    WrittenTypes.Const.CUInt32(node.range, intPart, sfx.range)
                  | "int64_literal" ->
                    WrittenTypes.Const.CInt64(node.range, intPart, sfx.range)
                  | "uint64_literal" ->
                    WrittenTypes.Const.CUInt64(node.range, intPart, sfx.range)
                  | "int128_literal" ->
                    WrittenTypes.Const.CInt128(node.range, intPart, sfx.range)
                  | "uint128_literal" ->
                    WrittenTypes.Const.CUInt128(node.range, intPart, sfx.range)

                constant |> Stdlib.Result.Result.Ok

              | Error _ -> createUnparseableError node

          else
            createUnparseableError node


        let parseFloatConst
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let floatStr = getText node

          match Stdlib.Float.parse floatStr with
          | Ok floatValue ->
            let (sign, whole, remainder) =
              let (sign, unsignedFloat) =
                if Stdlib.String.startsWith floatStr "-" then
                  (Sign.Negative, Stdlib.String.dropFirst floatStr 1L)
                else
                  (Sign.Positive, floatStr)

              let parts = Stdlib.String.split unsignedFloat "."

              let whole = parts |> Stdlib.List.head |> Stdlib.Option.withDefault "0"

              let remainder =
                parts
                |> Stdlib.List.tail
                |> Stdlib.Option.withDefault [ "0" ]
                |> Stdlib.List.head
                |> Stdlib.Option.withDefault "0"

              (sign, whole, remainder)

            (WrittenTypes.Const.CFloat(node.range, sign, whole, remainder))
            |> Stdlib.Result.Result.Ok

          | Error _ -> createUnparseableError node


        let parseStringConst
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let openQuoteNode = findField node "symbol_open_quote"
          let closeQuoteNode = findField node "symbol_close_quote"

          let contents =
            findAndParseOptional node "content" (fun stringPart ->
              (stringPart.range, stringPart.text) |> Stdlib.Result.Result.Ok)


          match openQuoteNode, closeQuoteNode with
          | Ok openQuote, Ok closeQuote ->
            (WrittenTypes.Const.CString(
              node.range,
              contents,
              openQuote.range,
              closeQuote.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseCharConst
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let openQuoteNode = findField node "symbol_open_single_quote"

          let charNode =
            findAndParseOptional node "content" (fun charPart ->
              (charPart.range, charPart.text) |> Stdlib.Result.Result.Ok)

          let closeQuoteNode = findField node "symbol_close_single_quote"

          match openQuoteNode, closeQuoteNode with
          | Ok openQuote, Ok closeQuote ->
            (WrittenTypes.Const.CChar(
              node.range,
              charNode,
              openQuote.range,
              closeQuote.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseListConst
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let openBracketNode = findField node "symbol_open_bracket"
          let closeBracketNode = findField node "symbol_close_bracket"

          let listContents =
            node
            |> findNodeByFieldName "content"
            |> Stdlib.Option.map (fun contentsNode ->
              contentsNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun constSymbolPair ->
                match constSymbolPair with
                | [ constNode; symbol ] ->
                  match ConstantDeclaration.parseConst constNode with
                  | Ok e ->
                    (e, Stdlib.Option.Option.Some symbol.range)
                    |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError contentsNode

                | [ constNode ] ->
                  match ConstantDeclaration.parseConst constNode with
                  | Ok e ->
                    (e, Stdlib.Option.Option.None) |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError constNode

                | _ -> createUnparseableError contentsNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          match openBracketNode, listContents, closeBracketNode with
          | Ok openBracket, Ok listContents, Ok closeBracket ->
            (WrittenTypes.Const.CList(
              node.range,
              listContents,
              openBracket.range,
              closeBracket.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseDictLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let keywordDictNode = findField node "keyword_dict"
          let openBraceNode = findField node "symbol_open_brace"

          let dictContents =
            node
            |> findNodeByFieldName "content"
            |> Stdlib.Option.map (fun contentsNode ->
              contentsNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun dictSeparatorPair ->
                match dictSeparatorPair with
                | [ dictPairNode; _separator ] ->
                  let keyNode =
                    findAndParseRequired dictPairNode "key" (fun node ->
                      (Parser.getText node) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField dictPairNode "symbol_equals"

                  let valueNode =
                    findAndParseRequired
                      dictPairNode
                      "value"
                      ConstantDeclaration.parseConst

                  match (keyNode, symbolEqualsNode, valueNode) with
                  | (Ok key, Ok symbolEquals, Ok value) ->
                    (symbolEquals, key, value) |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError dictPairNode

                | [ dictPairNode ] ->
                  let keyNode =
                    findAndParseRequired dictPairNode "key" (fun node ->
                      (Parser.getText node) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField dictPairNode "symbol_equals"

                  let valueNode =
                    findAndParseRequired
                      dictPairNode
                      "value"
                      ConstantDeclaration.parseConst

                  match (keyNode, symbolEqualsNode, valueNode) with
                  | (Ok key, Ok symbolEquals, Ok value) ->
                    (symbolEquals, key, value) |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError dictPairNode
                | _ -> createUnparseableError contentsNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          let closeBraceNode = findField node "symbol_close_brace"

          match keywordDictNode, openBraceNode, dictContents, closeBraceNode with
          | Ok keywordDict, Ok openBrace, Ok dictContents, Ok closeBrace ->
            (WrittenTypes.Const.CDict(
              node.range,
              dictContents,
              keywordDict.range,
              openBrace.range,
              closeBrace.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseTupleLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let openParenNode = findField node "symbol_left_paren"

          let first =
            findAndParseRequired node "first" ConstantDeclaration.parseConst

          let second =
            findAndParseRequired node "second" ConstantDeclaration.parseConst

          let rest =
            (findNodeByFieldName node "rest")
            |> Stdlib.Option.map (fun restNode ->
              restNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun symbolConstPair ->
                match symbolConstPair with
                | [ symbol; constNode ] ->
                  match ConstantDeclaration.parseConst constNode with
                  | Ok constant ->
                    (symbol.range, constant) |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError constNode

                | [ constNode ] ->
                  match ConstantDeclaration.parseConst constNode with
                  | Ok constant ->
                    (Stdlib.Option.Option.None, constant)
                    |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError constNode
                | _ -> createUnparseableError restNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          let commaSymbol = findField node "symbol_comma"
          let closeParenNode = findField node "symbol_right_paren"

          match openParenNode, first, commaSymbol, second, rest, closeParenNode with
          | Ok openParen, Ok first, Ok symComma, Ok second, Ok rest, Ok closeParen ->
            (WrittenTypes.Const.CTuple(
              node.range,
              first,
              symComma.range,
              second,
              rest,
              openParen.range,
              closeParen.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseEnumLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          let typeNameNode = findField node "type_name"
          let symbolDotNode = findField node "symbol_dot"
          let caseNameNode = findField node "case_name"

          let enumFieldsNode =
            (findNodeByFieldName node "enum_fields")
            |> Stdlib.Option.map (fun enumFieldsNode ->
              enumFieldsNode.children
              |> Stdlib.List.map (fun field -> ConstantDeclaration.parseConst field)
              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          match typeNameNode, symbolDotNode, caseNameNode, enumFieldsNode with
          | Ok typeNameNode, Ok symbolDotNode, Ok caseNameNode, Ok enumFieldsNode ->

            let typeName = typeNameNode.text |> Stdlib.String.split "."

            (WrittenTypes.Const.CEnum(
              node.range,
              (typeNameNode.range, typeName),
              (caseNameNode.range, caseNameNode.text),
              enumFieldsNode,
              symbolDotNode.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseConst
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Const, WrittenTypes.Unparseable> =
          match node.typ with
          | "unit" ->
            (WrittenTypes.Const.CUnit node.range) |> Stdlib.Result.Result.Ok
          | "bool_literal" -> parseBoolConst node
          | "int8_literal" -> parseIntConst node
          | "uint8_literal" -> parseIntConst node
          | "int16_literal" -> parseIntConst node
          | "uint16_literal" -> parseIntConst node
          | "int32_literal" -> parseIntConst node
          | "uint32_literal" -> parseIntConst node
          | "int64_literal" -> parseIntConst node
          | "uint64_literal" -> parseIntConst node
          | "int128_literal" -> parseIntConst node
          | "uint128_literal" -> parseIntConst node
          | "float_literal" -> parseFloatConst node
          | "string_literal" -> parseStringConst node
          | "char_literal" -> parseCharConst node
          | "const_list_literal" -> parseListConst node
          | "const_dict_literal" -> parseDictLiteral node
          | "const_tuple_literal" -> parseTupleLiteral node
          | "const_enum_literal" -> parseEnumLiteral node
          | "consts" ->
            match node.children with
            | [ constNode ] -> parseConst constNode
            | _ -> createUnparseableError node
          | _ -> createUnparseableError node


        /// Parses a package constant declaration
        ///
        /// i.e. `const waterBoilingPointCelsius = 100y`,
        ///
        /// - `waterBoilingPointCelsius` is the constant name
        /// - `100y` is the body
        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.ConstantDeclaration.ConstantDeclaration, WrittenTypes.Unparseable> =
          if node.typ == "const_decl" then
            let nameNode =
              findAndParseRequired node "name" (fun node ->
                (Identifiers.parseConst node) |> Stdlib.Result.Result.Ok)

            let value = (findNodeByFieldName node "value") |> Builtin.unwrap

            let valueNode =
              match value.children with
              | [ valueNode ] -> ConstantDeclaration.parseConst valueNode
              | _ -> createUnparseableError node

            let keywordConstNode = findField node "keyword_const"
            let symEqualsNode = findField node "symbol_equals"

            match nameNode, valueNode, keywordConstNode, symEqualsNode with
            | Ok name, Ok value, Ok keywordConst, Ok equals ->
              (WrittenTypes.ConstantDeclaration.ConstantDeclaration
                { range = node.range
                  name = name
                  body = value
                  keywordConst = keywordConst.range
                  symbolEquals = equals.range })
              |> Stdlib.Result.Result.Ok

            | _ -> createUnparseableError node