module Darklang =
  module LanguageTools =
    module RuntimeTypes =
      module FQName =
        /// A name that is built into the runtime
        type BuiltIn<'name> =
          { modules: List<String>
            name: 'name
            version: Int }

        /// Part of the user's program (e.g. canvas or CLI)
        type UserProgram<'name> =
          { modules: List<String>
            name: 'name
            version: Int }

        type Package<'name> =
          { owner: String
            modules: List<String>
            name: 'name
            version: Int }

        type FQName<'name> =
          | BuiltIn of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQName.BuiltIn<'name>
          | UserProgram of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQName.UserProgram<'name>
          | Package of
            PACKAGE.Darklang.LanguageTools.RuntimeTypes.FQName.Package<'name>

        type NameValidator<'name> = 'name -> Unit
        type NamePrinter<'name> = 'name -> String


        let builtinToString (s: BuiltIn<'name>) (f: NamePrinter<'name>) : String =
          let name = (s.modules @ [ f s.name ]) |> String.concat "."
          if s.version = 0 then name else $"{name}_v{s.version}"

        let userProgramToString
          (s: UserProgram<'name>)
          (f: NamePrinter<'name>)
          : string =
          let name = (s.modules @ [ f s.name ]) |> String.concat "."
          if s.version = 0 then name else $"{name}_v{s.version}"

        let packageToString (s: Package<'name>) (f: NamePrinter<'name>) : string =
          let name =
            ([ "PACKAGE"; s.owner ] @ s.modules @ [ f s.name ]) |> String.concat "."

          if s.version = 0 then name else $"{name}_v{s.version}"

        let toString (name: T<'name>) (f: NamePrinter<'name>) : String =
          match name with
          | BuiltIn b -> builtinToString b f
          | UserProgram user -> userProgramToString user f
          | Package pkg -> packageToString pkg f



      module TypeName =
        type Name = TypeName of String
        type TypeName = FQName.FQName<Name>
        type BuiltIn = FQName.BuiltIn<Name>
        type UserProgram = FQName.UserProgram<Name>
        type Package = FQName.Package<Name>

      // let builtinToString (s: BuiltIn) : String =
      //   FQName.builtinToString s (fun (TypeName name) -> name)

      // let userProgramToString (s: UserProgram) : String =
      //   FQName.userProgramToString s (fun (TypeName name) -> name)

      // let packageToString (s: Package) : String =
      //   FQName.packageToString s (fun (TypeName name) -> name)

      // let toString (name: T) : String =
      //   FQName.toString name (fun (TypeName name) -> name)

      // let toShortName (name: T) : String =
      //   match name with
      //   | FQName.BuiltIn { name = TypeName name
      //                      version = version } ->
      //     if version = 0 then name else $"{name}_v{version}"

      //   | FQName.UserProgram { name = TypeName name
      //                          version = version } ->
      //     if version = 0 then name else $"{name}_v{version}"

      //   | FQName.Package { name = TypeName name
      //                      version = version } ->
      //     if version = 0 then name else $"{name}_v{version}"


      module FnName =
        type Name = FnName of String
        type FnName = FQName.FQName<Name>
        type BuiltIn = FQName.BuiltIn<Name>
        type UserProgram = FQName.UserProgram<Name>
        type Package = FQName.Package<Name>

      //   let builtinToString (s : BuiltIn) : string =
      //     FQName.builtinToString s (fun (FnName name) -> name)

      //   let userProgramToString (s : UserProgram) : string =
      //     FQName.userProgramToString s (fun (FnName name) -> name)

      //   let packageToString (s : Package) : string =
      //     FQName.packageToString s (fun (FnName name) -> name)

      //   let toString (name : T) : string = FQName.toString name (fun (FnName name) -> name)

      //   let isInternalFn (fnName : BuiltIn) : bool =
      //     List.tryHead fnName.modules = Some "DarkInternal"

      /// A Fully-Qualified Constant Name
      /// Includes package, module, and version information where relevant.
      module ConstantName =
        type Name = ConstantName of String

        type ConstantName =
          FQName.FQName<PACKAGE.Darklang.LanguageTools.RuntimeTypes.ConstantName.Name>

        type BuiltIn = FQName.BuiltIn<Name>
        type UserProgram = FQName.UserProgram<Name>
        type Package = FQName.Package<Name>

      //   let toString (name : T) : string =
      //     FQName.toString name (fun (ConstantName name) -> name)


      type NameResolution<'a> =
        Result<'a, PACKAGE.Darklang.LanguageTools.RuntimeTypes.RuntimeError>

      type TypeReference =
        | TUnit
        | TBool
        | TInt
        | TFloat
        | TChar
        | TString
        | TUuid
        | TBytes
        | TDateTime
        | TPassword
        | TList of PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference
        | TTuple of
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference *
          List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference>
        | TFn of
          List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference> *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference
        | TDB of PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference
        | TVariable of String
        | TCustomType of
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.NameResolution<PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeName.TypeName> *
          typeArgs: List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference>
        | TDict of PACKAGE.Darklang.LanguageTools.RuntimeTypes.TypeReference

      type Expr =
        | EInt of PACKAGE.Darklang.LanguageTools.ID * Int
        | EBool of PACKAGE.Darklang.LanguageTools.ID * Bool
        | EString of
          PACKAGE.Darklang.LanguageTools.ID *
          List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.StringSegment>
        | EChar of PACKAGE.Darklang.LanguageTools.ID * string
        | EFloat of PACKAGE.Darklang.LanguageTools.ID * double
        | EUnit of PACKAGE.Darklang.LanguageTools.ID
        | EConstant of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.ConstantName.ConstantName
        | ELet of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.LetPattern *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr
        | EIf of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr
        | ELambda of
          PACKAGE.Darklang.LanguageTools.ID *
          List<PACKAGE.Darklang.LanguageTools.ID * string> *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr
        | EFieldAccess of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          string
        | EVariable of PACKAGE.Darklang.LanguageTools.ID * string
        | EApply of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          typeArgs: List<TypeReference> *
          args: List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | EFnName of PACKAGE.Darklang.LanguageTools.ID * FnName.FnName
        | EList of
          PACKAGE.Darklang.LanguageTools.ID *
          List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | ETuple of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | ERecord of
          PACKAGE.Darklang.LanguageTools.ID *
          TypeName.TypeName *
          List<string * PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | ERecordUpdate of
          PACKAGE.Darklang.LanguageTools.ID *
          record: PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          updates: List<string * PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | EDict of
          PACKAGE.Darklang.LanguageTools.ID *
          List<string * PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | EEnum of
          PACKAGE.Darklang.LanguageTools.ID *
          TypeName.TypeName *
          caseName: string *
          fields: List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | EMatch of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          List<MatchPattern * PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>
        | EAnd of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr
        | EOr of
          PACKAGE.Darklang.LanguageTools.ID *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr *
          PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr
        | EError of
          PACKAGE.Darklang.LanguageTools.ID *
          RuntimeError *
          List<PACKAGE.Darklang.LanguageTools.RuntimeTypes.Expr>

      type LetPattern =
        | LPVariable of PACKAGE.Darklang.LanguageTools.ID * name: String
        | LPTuple of
          PACKAGE.Darklang.LanguageTools.ID *
          first: LetPattern *
          second: LetPattern *
          theRest: List<LetPattern>

      type StringSegment =
        | StringText of String
        | StringInterpolation of Expr

      type MatchPattern =
        | MPVariable of PACKAGE.Darklang.LanguageTools.ID * string
        | MPEnum of
          PACKAGE.Darklang.LanguageTools.ID *
          caseName: string *
          fieldPatterns: List<MatchPattern>
        | MPInt of PACKAGE.Darklang.LanguageTools.ID * int64
        | MPBool of PACKAGE.Darklang.LanguageTools.ID * bool
        | MPChar of PACKAGE.Darklang.LanguageTools.ID * string
        | MPString of PACKAGE.Darklang.LanguageTools.ID * string
        | MPFloat of PACKAGE.Darklang.LanguageTools.ID * double
        | MPUnit of id
        | MPTuple of
          PACKAGE.Darklang.LanguageTools.ID *
          MatchPattern *
          MatchPattern *
          List<MatchPattern>
        | MPList of PACKAGE.Darklang.LanguageTools.ID * List<MatchPattern>
        | MPListCons of
          PACKAGE.Darklang.LanguageTools.ID *
          head: MatchPattern *
          tail: MatchPattern

      type DvalMap = Map<string, Dval>

      type LambdaImpl =
        { typeArgTable: TypeArgTable
          symtable: Symtable
          parameters: List<PACKAGE.Darklang.LanguageTools.ID * String>
          body: Expr }

      type FnValImpl =
        | Lambda of LambdaImpl
        | NamedFn of FnName.FnName

      type RuntimeError = RuntimeError of Dval

      type Dval =
        | DUnit
        | DBool of Bool
        | DInt of Int
        | DFloat of double
        | DChar of String
        | DString of String
        | DDateTime of DateTime
        | DBytes of Bytes
        | DUuid of System.Guid

        | DList of List<Dval>
        | DDict of DvalMap
        | DTuple of Dval * Dval * List<Dval>

        | DFnVal of FnValImpl

        | DDB of String
        | DPassword of Password

        | DRecord of
          runtimeTypeName: TypeName.TypeName *
          sourceTypeName: TypeName.TypeName *
          DvalMap
        | DEnum of
          runtimeTypeName: TypeName.TypeName *
          sourceTypeName: TypeName.TypeName *
          caseName: String *
          List<Dval>

        | DError of DvalSource * RuntimeError
        | DIncomplete of DvalSource


      // /// our record of any variable bindings in scope
      // ///
      // /// i.e. within the execution of `x+y` in
      // ///  `let x = 1; let y = 2; x + y`
      // /// , we would have a Symtable of
      // ///   `{ "x" => DInt 1; "y" => DInt 2 }`
      // and Symtable = Map<string, Dval>

      // and TypeArgTable = Map<string, TypeReference>


      // // Record the source of an incomplete or error. Would be useful to add more
      // // information later, such as the iteration count that led to this, or
      // // something like a stack trace
      // and DvalSource =
      //   // We do not have context to supply an identifier
      //   | SourceNone

      //   // Caused by an expression of `id` within the given `tlid`
      //   | SourceID of tlid * id

      and BuiltInParam =
        { name: String
          typ: Darklang.LanguageTools.RuntimeTypes.TypeReference
          blockArgs: List<String>
          description: String }

      // and Param = { name : string; typ : TypeReference }


      // module RuntimeError =
      //   let toDT (RuntimeError e : RuntimeError) : Dval = e
      //   let fromDT (dv : Dval) : RuntimeError = RuntimeError dv


      // type Deprecation<'name> =
      //   | NotDeprecated
      //   | RenamedTo of 'name
      //   | ReplacedBy of 'name
      //   | DeprecatedBecause of string


      // module TypeDeclaration =
      //   type RecordField = { name : string; typ : TypeReference }
      //   type EnumCase = { name : string; fields : List<TypeReference> }

      //   type Definition =
      //     | Alias of TypeReference
      //     | Record of NEList<RecordField>
      //     | Enum of NEList<EnumCase>

      //   type T = { typeParams : List<string>; definition : Definition }

      // module Handler =
      //   type CronInterval =
      //     | EveryDay
      //     | EveryWeek
      //     | EveryFortnight
      //     | EveryHour
      //     | Every12Hours
      //     | EveryMinute

      //   type Spec =
      //     | HTTP of path: string * method: string
      //     | Worker of name: string
      //     | Cron of name: string * interval: CronInterval
      //     | REPL of name: string

      //   type Handler = { tlid: tlid; ast: Expr; spec: Spec }

      // module DB =
      //   type T = { tlid : tlid; name : string; typ : TypeReference; version : int }

      // module UserType =
      //   type T =
      //     { tlid : tlid; name : TypeName.UserProgram; declaration : TypeDeclaration.T }

      // module UserConstant =
      //   type T = { tlid : tlid; name : ConstantName.UserProgram; body : Dval }

      // module UserFunction =
      //   type Parameter = { name : string; typ : TypeReference }

      //   type T =
      //     { tlid : tlid
      //       name : FnName.UserProgram
      //       typeParams : List<string>
      //       parameters : List<Parameter>
      //       returnType : TypeReference
      //       body : Expr }

      // module Toplevel =
      //   type T =
      //     | TLHandler of Handler.T
      //     | TLDB of DB.T
      //     | TLFunction of UserFunction.T
      //     | TLType of UserType.T
      //     | TLConstant of UserConstant.T

      //   let toTLID (tl : T) : tlid =
      //     match tl with
      //     | TLHandler h -> h.tlid
      //     | TLDB db -> db.tlid
      //     | TLFunction f -> f.tlid
      //     | TLType t -> t.tlid
      //     | TLConstant c -> c.tlid

      // module Secret =
      //   type T = { name : string; value : string; version : int }


      // // ------------
      // // Functions
      // // ------------

      // module PackageFn =
      //   type Parameter = { name : string; typ : TypeReference }

      //   type T =
      //     { name : FnName.Package
      //       tlid : tlid
      //       typeParams : List<string>
      //       parameters : List<Parameter>
      //       returnType : TypeReference
      //       body : Expr }

      // module PackageType =
      //   type T = { name : TypeName.Package; declaration : TypeDeclaration.T }

      // module PackageConstant =
      //   type T = { name : ConstantName.Package; body : Dval }

      // type Previewable =
      //   // The same inputs will always yield the same outputs,
      //   // so we don't need to save results. e.g. `DateTime.addSeconds`
      //   | Pure

      //   // Output may vary with the same inputs, though we can safely preview.
      //   // e.g. `DateTime.now`. We should save the results.
      //   | ImpurePreviewable

      //   // Can only be run on the server. e.g. `DB.update`
      //   // We should save the results.
      //   | Impure

      // type SqlSpec =
      //   | NotYetImplemented
      //   | NotQueryable
      //   | QueryFunction
      //   | SqlUnaryOp of string
      //   | SqlBinOp of string
      //   | SqlFunction of string
      //   | SqlFunctionWithPrefixArgs of string * List<string>
      //   | SqlFunctionWithSuffixArgs of string * List<string>
      //   | SqlCallback2 of (string -> string -> string)

      // // A built-in standard library type
      // type BuiltInType =
      //   { name : TypeName.BuiltIn
      //     declaration : TypeDeclaration.T
      //     // description and deprecated are here because they're not needed in
      //     // TypeDeclaration for Package and UserProgram types, where we have them in
      //     // ProgramTypes and don't propagate them to RuntimeTypes
      //     description : string
      //     deprecated : Deprecation<TypeName.TypeName> }

      // type BuiltInConstant =
      //   { name : ConstantName.BuiltIn
      //     typ : TypeReference
      //     description : string
      //     deprecated : Deprecation<ConstantName.ConstantName>
      //     body : Dval }

      // // A built-in standard library function
      // type BuiltInFn =
      //   { name : FnName.BuiltIn
      //     typeParams : List<string>
      //     parameters : List<BuiltInParam>
      //     returnType : TypeReference
      //     description : string
      //     previewable : Previewable
      //     deprecated : Deprecation<FnName.FnName>
      //     sqlSpec : SqlSpec
      //     fn : BuiltInFnSig }

      // and Fn =
      //   { name : FnName.FnName
      //     typeParams : List<string>
      //     parameters : List<Param>
      //     returnType : TypeReference
      //     previewable : Previewable
      //     sqlSpec : SqlSpec
      //     fn : FnImpl }

      // and BuiltInFnSig =
      //   (ExecutionState *

      //   // type args
      //   List<TypeReference> *

      //   // fn args
      //   List<Dval>)
      //     -> DvalTask

      // and FnImpl =
      //   | BuiltInFunction of BuiltInFnSig
      //   | UserProgramFunction of tlid * Expr
      //   | PackageFunction of tlid * Expr


      // and RealOrPreview =
      //   | Real
      //   | Preview

      // and FunctionRecord = tlid * FnName.FnName * id

      // and TraceDval = bool -> id -> Dval -> unit

      // and TraceTLID = tlid -> unit

      // and LoadFnResult = FunctionRecord -> List<Dval> -> Option<Dval * NodaTime.Instant>

      // and StoreFnResult = FunctionRecord -> Dval list -> Dval -> unit

      // /// Per-runtime configuration allowing different settings for eg cloud, test, CLI
      // and Config = { allowLocalHttpAccess : bool; httpclientTimeoutInMs : int }

      // /// Every part of a user's program
      // and Program =
      //   { canvasID : CanvasID
      //     internalFnsAllowed : bool // whether this canvas is allowed call internal functions
      //     dbs : Map<string, DB.T>
      //     fns : Map<FnName.UserProgram, UserFunction.T>
      //     types : Map<TypeName.UserProgram, UserType.T>
      //     constants : Map<ConstantName.UserProgram, UserConstant.T>
      //     secrets : List<Secret.T> }

      // /// Set of callbacks used to trace the interpreter, and other context needed to run code
      // and Tracing =
      //   { traceDval : TraceDval
      //     traceTLID : TraceTLID
      //     loadFnResult : LoadFnResult
      //     storeFnResult : StoreFnResult
      //     realOrPreview : RealOrPreview }

      // // Used for testing
      // and TestContext =
      //   { mutable sideEffectCount : int

      //     mutable exceptionReports : List<string * string * Metadata>
      //     mutable expectedExceptionCount : int
      //     postTestExecutionHook : TestContext -> Dval -> unit }

      // // Functionally written in F# and shipped with the executable
      // and BuiltIns =
      //   { types : Map<TypeName.BuiltIn, BuiltInType>
      //     constants : Map<ConstantName.BuiltIn, BuiltInConstant>
      //     fns : Map<FnName.BuiltIn, BuiltInFn> }

      // // Functionality written in Dark stored and managed outside of user space
      // and PackageManager =
      //   { getType : TypeName.Package -> Ply<Option<PackageType.T>>
      //     getFn : FnName.Package -> Ply<Option<PackageFn.T>>
      //     getConstant : ConstantName.Package -> Ply<Option<PackageConstant.T>>
      //     init : Ply<unit> }

      //   static member Empty =
      //     { getType = (fun _ -> Ply None)
      //       getFn = (fun _ -> Ply None)
      //       getConstant = (fun _ -> Ply None)
      //       init = uply { return () } }

      // and ExceptionReporter = ExecutionState -> Metadata -> exn -> unit

      // and Notifier = ExecutionState -> string -> Metadata -> unit

      // // All state used while running a program
      // and ExecutionState =
      //   { builtIns : BuiltIns
      //     packageManager : PackageManager
      //     tracing : Tracing
      //     program : Program
      //     config : Config
      //     test : TestContext

      //     // Called to report exceptions
      //     reportException : ExceptionReporter

      //     // Called to notify that something of interest (that isn't an exception)
      //     // has happened.
      //     //
      //     // Useful for tracking behaviour we want to deprecate, understanding what
      //     // users are doing, etc.
      //     notify : Notifier

      //     // TLID of the currently executing handler/fn
      //     tlid : tlid

      //     executingFnName : Option<FnName.FnName>

      //     // <summary>
      //     // Callstack of functions that have been called as part of execution
      //     // </summary>
      //     //
      //     // <remarks>
      //     // Used for recursion detection in the editor.
      //     // In the editor, we call all paths to show live values,
      //     // but with recursion that causes infinite recursion.
      //     // </remarks>
      //     callstack : Set<FnName.FnName>

      //     // Whether the currently executing code is really being executed
      //     // (as opposed to being previewed for traces)
      //     onExecutionPath : bool }

      // and Types =
      //   { builtIn : Map<TypeName.BuiltIn, BuiltInType>
      //     package : TypeName.Package -> Ply<Option<PackageType.T>>
      //     userProgram : Map<TypeName.UserProgram, UserType.T> }

      let x = 1