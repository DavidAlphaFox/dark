module Darklang =
  module LanguageTools =
    module RuntimeTypes =
      module FQName =
        /// A name that is built into the runtime
        type BuiltIn<'name> =
          { modules: List<String>
            name: 'name
            version: Int }

        /// Part of the user's program (e.g. canvas or CLI)
        type UserProgram<'name> =
          { modules: List<String>
            name: 'name
            version: Int }

        type Package<'name> =
          { owner: String
            modules: NEList<String>
            name: 'name
            version: Int }

        type FQName<'name> =
          | BuiltIn of BuiltIn<'name>
          | UserProgram of UserProgram<'name>
          | Package of Package<'name>

        type NameValidator<'name> = 'name -> Unit
        type NamePrinter<'name> = 'name -> Serializationtring


        let builtinToString (s: BuiltIn<'name>) (f: NamePrinter<'name>) : String =
          let name = (s.modules @ [ f s.name ]) |> String.concat "."
          if s.version = 0 then name else $"{name}_v{s.version}"

        let userProgramToString
          (s: UserProgram<'name>)
          (f: NamePrinter<'name>)
          : string =
          let name = (s.modules @ [ f s.name ]) |> String.concat "."
          if s.version = 0 then name else $"{name}_v{s.version}"

        let packageToString (s: Package<'name>) (f: NamePrinter<'name>) : string =
          let name =
            ([ "PACKAGE"; s.owner ] @ NEList.toList s.modules @ [ f s.name ])
            |> String.concat "."

          if s.version = 0 then name else $"{name}_v{s.version}"

        let toString (name: T<'name>) (f: NamePrinter<'name>) : String =
          match name with
          | BuiltIn b -> builtinToString b f
          | UserProgram user -> userProgramToString user f
          | Package pkg -> packageToString pkg f

      module TypeName =
        type Name = TypeName of String
        type T = FQName.T<Name>
        type BuiltIn = FQName.BuiltIn<Name>
        type UserProgram = FQName.UserProgram<Name>
        type Package = FQName.Package<Name>

      // let builtinToString (s: BuiltIn) : String =
      //   FQName.builtinToString s (fun (TypeName name) -> name)

      // let userProgramToString (s: UserProgram) : String =
      //   FQName.userProgramToString s (fun (TypeName name) -> name)

      // let packageToString (s: Package) : String =
      //   FQName.packageToString s (fun (TypeName name) -> name)

      // let toString (name: T) : String =
      //   FQName.toString name (fun (TypeName name) -> name)

      // let toShortName (name: T) : String =
      //   match name with
      //   | FQName.BuiltIn { name = TypeName name
      //                      version = version } ->
      //     if version = 0 then name else $"{name}_v{version}"

      //   | FQName.UserProgram { name = TypeName name
      //                          version = version } ->
      //     if version = 0 then name else $"{name}_v{version}"

      //   | FQName.Package { name = TypeName name
      //                      version = version } ->
      //     if version = 0 then name else $"{name}_v{version}"


      module FnName =
        type Name = FnName of String
        type T = FQName.T<Name>
        type BuiltIn = FQName.BuiltIn<Name>
        type UserProgram = FQName.UserProgram<Name>
        type Package = FQName.Package<Name>

      //   let builtinToString (s : BuiltIn) : string =
      //     FQName.builtinToString s (fun (FnName name) -> name)

      //   let userProgramToString (s : UserProgram) : string =
      //     FQName.userProgramToString s (fun (FnName name) -> name)

      //   let packageToString (s : Package) : string =
      //     FQName.packageToString s (fun (FnName name) -> name)

      //   let toString (name : T) : string = FQName.toString name (fun (FnName name) -> name)

      //   let isInternalFn (fnName : BuiltIn) : bool =
      //     List.tryHead fnName.modules = Some "DarkInternal"

      /// A Fully-Qualified Constant Name
      /// Includes package, module, and version information where relevant.
      module ConstantName =
        type Name = ConstantName of String
        type T = FQName.T<Name>
        type BuiltIn = FQName.BuiltIn<Name>
        type UserProgram = FQName.UserProgram<Name>
        type Package = FQName.Package<Name>

      //   let toString (name : T) : string =
      //     FQName.toString name (fun (ConstantName name) -> name)


      type NameResolution<'a> = Result<'a, RuntimeError>

      type TypeReference =
        | TUnit
        | TBool
        | TInt
        | TFloat
        | TChar
        | TString
        | TUuid
        | TBytes
        | TDateTime
        | TPassword
        | TList of TypeReference
        | TTuple of TypeReference * TypeReference * List<TypeReference>
        | TFn of List<TypeReference> * TypeReference
        | TDB of TypeReference
        | TVariable of String
        | TCustomType of NameResolution<TypeName.T> * typeArgs: List<TypeReference>
        | TDict of TypeReference

      type Expr =
        | EInt of id * Int
        | EBool of id * Bool
        | EString of id * List<StringSegment>
        | EChar of id * string
        | EFloat of id * double
        | EUnit of id
        | EConstant of id * ConstantName.T
        | ELet of id * LetPattern * Expr * Expr
        | EIf of id * Expr * Expr * Expr
        | ELambda of id * List<id * string> * Expr
        | EFieldAccess of id * Expr * string
        | EVariable of id * string
        | EApply of id * Expr * typeArgs: List<TypeReference> * args: List<Expr>
        | EFnName of id * FnName.T
        | EList of id * List<Expr>
        | ETuple of id * Expr * Expr * List<Expr>
        | ERecord of id * TypeName.T * List<string * Expr>
        | ERecordUpdate of id * record: Expr * updates: List<string * Expr>
        | EDict of id * List<string * Expr>
        | EEnum of id * TypeName.T * caseName: string * fields: List<Expr>
        | EMatch of id * Expr * List<MatchPattern * Expr>
        | EAnd of id * Expr * Expr
        | EOr of id * Expr * Expr
        | EError of id * RuntimeError * List<Expr>

      type LetPattern =
        | LPVariable of id * name: String
        | LPTuple of
          id *
          first: LetPattern *
          second: LetPattern *
          theRest: List<LetPattern>

      type StringSegment =
        | StringText of String
        | StringInterpolation of Expr

      type MatchPattern =
        | MPVariable of id * string
        | MPEnum of id * caseName: string * fieldPatterns: List<MatchPattern>
        | MPInt of id * int64
        | MPBool of id * bool
        | MPChar of id * string
        | MPString of id * string
        | MPFloat of id * double
        | MPUnit of id
        | MPTuple of id * MatchPattern * MatchPattern * List<MatchPattern>
        | MPList of id * List<MatchPattern>
        | MPListCons of id * head: MatchPattern * tail: MatchPattern

      type DvalMap = Map<string, Dval>

      type LambdaImpl =
        { typeArgTable: TypeArgTable
          symtable: Symtable
          parameters: List<id * String>
          body: Expr }

      type FnValImpl =
        | Lambda of LambdaImpl
        | NamedFn of FnName.T

      type RuntimeError = RuntimeError of Dval

      type Dval =
        | DUnit
        | DBool of Bool
        | DInt of Int
        | DFloat of double
        | DChar of String
        | DString of String
        | DDateTime of DateTime
        | DBytes of Bytes
        | DUuid of System.Guid

        | DList of List<Dval>
        | DDict of DvalMap
        | DTuple of Dval * Dval * List<Dval>

        | DFnVal of FnValImpl

        | DDB of String
        | DPassword of Password

        | DRecord of
          runtimeTypeName: TypeName.T *
          sourceTypeName: TypeName.T *
          DvalMap
        | DEnum of
          runtimeTypeName: TypeName.T *
          sourceTypeName: TypeName.T *
          caseName: String *
          List<Dval>

        | DError of DvalSource * RuntimeError
        | DIncomplete of DvalSource


      // /// our record of any variable bindings in scope
      // ///
      // /// i.e. within the execution of `x+y` in
      // ///  `let x = 1; let y = 2; x + y`
      // /// , we would have a Symtable of
      // ///   `{ "x" => DInt 1; "y" => DInt 2 }`
      // and Symtable = Map<string, Dval>

      // and TypeArgTable = Map<string, TypeReference>


      // // Record the source of an incomplete or error. Would be useful to add more
      // // information later, such as the iteration count that led to this, or
      // // something like a stack trace
      // and DvalSource =
      //   // We do not have context to supply an identifier
      //   | SourceNone

      //   // Caused by an expression of `id` within the given `tlid`
      //   | SourceID of tlid * id

      // and BuiltInParam =
      //   { name : string
      //     typ : TypeReference
      //     blockArgs : List<string>
      //     description : string }

      // and Param = { name : string; typ : TypeReference }


      // module RuntimeError =
      //   let toDT (RuntimeError e : RuntimeError) : Dval = e
      //   let fromDT (dv : Dval) : RuntimeError = RuntimeError dv


      // type Deprecation<'name> =
      //   | NotDeprecated
      //   | RenamedTo of 'name
      //   | ReplacedBy of 'name
      //   | DeprecatedBecause of string


      // module TypeDeclaration =
      //   type RecordField = { name : string; typ : TypeReference }
      //   type EnumCase = { name : string; fields : List<TypeReference> }

      //   type Definition =
      //     | Alias of TypeReference
      //     | Record of NEList<RecordField>
      //     | Enum of NEList<EnumCase>

      //   type T = { typeParams : List<string>; definition : Definition }

      // module Handler =
      //   type CronInterval =
      //     | EveryDay
      //     | EveryWeek
      //     | EveryFortnight
      //     | EveryHour
      //     | Every12Hours
      //     | EveryMinute

      //   type Spec =
      //     | HTTP of path: string * method: string
      //     | Worker of name: string
      //     | Cron of name: string * interval: CronInterval
      //     | REPL of name: string

      //   type Handler = { tlid: tlid; ast: Expr; spec: Spec }

      // module DB =
      //   type T = { tlid : tlid; name : string; typ : TypeReference; version : int }

      // module UserType =
      //   type T =
      //     { tlid : tlid; name : TypeName.UserProgram; declaration : TypeDeclaration.T }

      // module UserConstant =
      //   type T = { tlid : tlid; name : ConstantName.UserProgram; body : Dval }

      // module UserFunction =
      //   type Parameter = { name : string; typ : TypeReference }

      //   type T =
      //     { tlid : tlid
      //       name : FnName.UserProgram
      //       typeParams : List<string>
      //       parameters : List<Parameter>
      //       returnType : TypeReference
      //       body : Expr }

      // module Toplevel =
      //   type T =
      //     | TLHandler of Handler.T
      //     | TLDB of DB.T
      //     | TLFunction of UserFunction.T
      //     | TLType of UserType.T
      //     | TLConstant of UserConstant.T

      //   let toTLID (tl : T) : tlid =
      //     match tl with
      //     | TLHandler h -> h.tlid
      //     | TLDB db -> db.tlid
      //     | TLFunction f -> f.tlid
      //     | TLType t -> t.tlid
      //     | TLConstant c -> c.tlid

      // module Secret =
      //   type T = { name : string; value : string; version : int }


      // // ------------
      // // Functions
      // // ------------

      // module PackageFn =
      //   type Parameter = { name : string; typ : TypeReference }

      //   type T =
      //     { name : FnName.Package
      //       tlid : tlid
      //       typeParams : List<string>
      //       parameters : List<Parameter>
      //       returnType : TypeReference
      //       body : Expr }

      // module PackageType =
      //   type T = { name : TypeName.Package; declaration : TypeDeclaration.T }

      // module PackageConstant =
      //   type T = { name : ConstantName.Package; body : Dval }

      // type Previewable =
      //   // The same inputs will always yield the same outputs,
      //   // so we don't need to save results. e.g. `DateTime.addSeconds`
      //   | Pure

      //   // Output may vary with the same inputs, though we can safely preview.
      //   // e.g. `DateTime.now`. We should save the results.
      //   | ImpurePreviewable

      //   // Can only be run on the server. e.g. `DB.update`
      //   // We should save the results.
      //   | Impure

      // type SqlSpec =
      //   | NotYetImplemented
      //   | NotQueryable
      //   | QueryFunction
      //   | SqlUnaryOp of string
      //   | SqlBinOp of string
      //   | SqlFunction of string
      //   | SqlFunctionWithPrefixArgs of string * List<string>
      //   | SqlFunctionWithSuffixArgs of string * List<string>
      //   | SqlCallback2 of (string -> string -> string)

      // // A built-in standard library type
      // type BuiltInType =
      //   { name : TypeName.BuiltIn
      //     declaration : TypeDeclaration.T
      //     // description and deprecated are here because they're not needed in
      //     // TypeDeclaration for Package and UserProgram types, where we have them in
      //     // ProgramTypes and don't propagate them to RuntimeTypes
      //     description : string
      //     deprecated : Deprecation<TypeName.T> }

      // type BuiltInConstant =
      //   { name : ConstantName.BuiltIn
      //     typ : TypeReference
      //     description : string
      //     deprecated : Deprecation<ConstantName.T>
      //     body : Dval }

      // // A built-in standard library function
      // type BuiltInFn =
      //   { name : FnName.BuiltIn
      //     typeParams : List<string>
      //     parameters : List<BuiltInParam>
      //     returnType : TypeReference
      //     description : string
      //     previewable : Previewable
      //     deprecated : Deprecation<FnName.T>
      //     sqlSpec : SqlSpec
      //     fn : BuiltInFnSig }

      // and Fn =
      //   { name : FnName.T
      //     typeParams : List<string>
      //     parameters : List<Param>
      //     returnType : TypeReference
      //     previewable : Previewable
      //     sqlSpec : SqlSpec
      //     fn : FnImpl }

      // and BuiltInFnSig =
      //   (ExecutionState *

      //   // type args
      //   List<TypeReference> *

      //   // fn args
      //   List<Dval>)
      //     -> DvalTask

      // and FnImpl =
      //   | BuiltInFunction of BuiltInFnSig
      //   | UserProgramFunction of tlid * Expr
      //   | PackageFunction of tlid * Expr


      // and RealOrPreview =
      //   | Real
      //   | Preview

      // and FunctionRecord = tlid * FnName.T * id

      // and TraceDval = bool -> id -> Dval -> unit

      // and TraceTLID = tlid -> unit

      // and LoadFnResult = FunctionRecord -> List<Dval> -> Option<Dval * NodaTime.Instant>

      // and StoreFnResult = FunctionRecord -> Dval list -> Dval -> unit

      // /// Per-runtime configuration allowing different settings for eg cloud, test, CLI
      // and Config = { allowLocalHttpAccess : bool; httpclientTimeoutInMs : int }

      // /// Every part of a user's program
      // and Program =
      //   { canvasID : CanvasID
      //     internalFnsAllowed : bool // whether this canvas is allowed call internal functions
      //     dbs : Map<string, DB.T>
      //     fns : Map<FnName.UserProgram, UserFunction.T>
      //     types : Map<TypeName.UserProgram, UserType.T>
      //     constants : Map<ConstantName.UserProgram, UserConstant.T>
      //     secrets : List<Secret.T> }

      // /// Set of callbacks used to trace the interpreter, and other context needed to run code
      // and Tracing =
      //   { traceDval : TraceDval
      //     traceTLID : TraceTLID
      //     loadFnResult : LoadFnResult
      //     storeFnResult : StoreFnResult
      //     realOrPreview : RealOrPreview }

      // // Used for testing
      // and TestContext =
      //   { mutable sideEffectCount : int

      //     mutable exceptionReports : List<string * string * Metadata>
      //     mutable expectedExceptionCount : int
      //     postTestExecutionHook : TestContext -> Dval -> unit }

      // // Functionally written in F# and shipped with the executable
      // and BuiltIns =
      //   { types : Map<TypeName.BuiltIn, BuiltInType>
      //     constants : Map<ConstantName.BuiltIn, BuiltInConstant>
      //     fns : Map<FnName.BuiltIn, BuiltInFn> }

      // // Functionality written in Dark stored and managed outside of user space
      // and PackageManager =
      //   { getType : TypeName.Package -> Ply<Option<PackageType.T>>
      //     getFn : FnName.Package -> Ply<Option<PackageFn.T>>
      //     getConstant : ConstantName.Package -> Ply<Option<PackageConstant.T>>
      //     init : Ply<unit> }

      //   static member Empty =
      //     { getType = (fun _ -> Ply None)
      //       getFn = (fun _ -> Ply None)
      //       getConstant = (fun _ -> Ply None)
      //       init = uply { return () } }

      // and ExceptionReporter = ExecutionState -> Metadata -> exn -> unit

      // and Notifier = ExecutionState -> string -> Metadata -> unit

      // // All state used while running a program
      // and ExecutionState =
      //   { builtIns : BuiltIns
      //     packageManager : PackageManager
      //     tracing : Tracing
      //     program : Program
      //     config : Config
      //     test : TestContext

      //     // Called to report exceptions
      //     reportException : ExceptionReporter

      //     // Called to notify that something of interest (that isn't an exception)
      //     // has happened.
      //     //
      //     // Useful for tracking behaviour we want to deprecate, understanding what
      //     // users are doing, etc.
      //     notify : Notifier

      //     // TLID of the currently executing handler/fn
      //     tlid : tlid

      //     executingFnName : Option<FnName.T>

      //     // <summary>
      //     // Callstack of functions that have been called as part of execution
      //     // </summary>
      //     //
      //     // <remarks>
      //     // Used for recursion detection in the editor.
      //     // In the editor, we call all paths to show live values,
      //     // but with recursion that causes infinite recursion.
      //     // </remarks>
      //     callstack : Set<FnName.T>

      //     // Whether the currently executing code is really being executed
      //     // (as opposed to being previewed for traces)
      //     onExecutionPath : bool }

      // and Types =
      //   { builtIn : Map<TypeName.BuiltIn, BuiltInType>
      //     package : TypeName.Package -> Ply<Option<PackageType.T>>
      //     userProgram : Map<TypeName.UserProgram, UserType.T> }

      let x = 1