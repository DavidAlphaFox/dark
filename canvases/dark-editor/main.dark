let rUnwrap (result: Result<'a, 'b>) : 'a =
  match result with
  | Ok s -> s
  | Error e ->
    log e // TODO: this won't work if non-string
    alert "Expected OK, got Error - see log"


[<HttpHandler("GET", "/openai-apikey-yikes")>]
let _handler _req =
  PACKAGE.Darklang.Stdlib.Http.response (String.toBytes OPENAI_API_KEY) 200

[<HttpHandler("GET", "/")>]
let _handler _req =
  let filePath = "dark-editor-vue/dist/index.html"
  let file = Experiments.readFromCanvases filePath

  let body =
    match file with
    | Ok f -> f

  PACKAGE.Darklang.Stdlib.Http.responseWithHtml (String.fromBytes body) 200

[<HttpHandler("GET", "/assets/:path")>]
let _handler _req =
  match Experiments.readFromCanvases ("dark-editor-vue/dist/assets/" ++ path) with
  | Ok fileContents ->
    let contentType =
      match (String.split path ".") |> List.last |> Option.withDefault "" with
      | "js" -> "application/javascript"
      | "json" -> "application/json"
      | "css" -> "text/css"
      | _ -> "text/plain"

    let headers = [ ("content-type", contentType) ]

    PACKAGE.Darklang.Stdlib.Http.responseWithHeaders fileContents headers 200

  | Error _e ->
    PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "Couldn't load asset") 400

// We're sharing the Worker script between this canvas and
// dark-repl, and Worker scripts can't be loaded across
// origins, so we need to serve it from the same origin.
// Nothing else should be served from this handler,
// so let's assume JS content-type.
[<HttpHandler("GET", "/static/:path")>]
let _handler _req =
  let body =
    (Experiments.readFromStaticDir $"{path}") |> Result.withDefault Bytes.empty

  let headers = [ ("Content-type", "text/javascript") ]
  PACKAGE.Darklang.Stdlib.Http.responseWithHeaders body headers 200

[<HttpHandler("GET", "/assets/client.dark")>]
let _handler _req =
  match Experiments.readFromCanvases "dark-editor/client.dark" with
  | Ok sourceInBytes -> PACKAGE.Darklang.Stdlib.Http.response sourceInBytes 200
  | Error _err ->
    PACKAGE.Darklang.Stdlib.Http.response
      (String.toBytes "Couldn't load client.dark from disk")
      500


// TODO: remove once a parser can run in WASM runtime
[<HttpHandler("POST", "/get-program-json")>]
let _handler _req =
  let sourceInBytes = request.body

  let program =
    Experiments.parseAndSerializeProgram
      (String.fromBytes sourceInBytes)
      "user-code.dark"

  match program with
  | Ok program ->
    let types = Option.withDefault (Dict.get program "types") "[]"
    let fns = Option.withDefault (Dict.get program "fns") "[]"
    let exprs = Option.withDefault (Dict.get program "exprs") "[]"

    let json =
      "{ \"types\": "
      ++ types
      ++ ", \"fns\": "
      ++ fns
      ++ ", \"exprs\": "
      ++ exprs
      ++ "}"

    PACKAGE.Darklang.Stdlib.Http.responseWithHeaders
      (String.toBytes json)
      [ ("content-type", "application-json") ]
      200

  | Error err ->
    PACKAGE.Darklang.Stdlib.Http.response
      (String.toBytes ("Couldn't parse the program \n" ++ err))
      400


[<HttpHandler("GET", "/system-prompt")>]
let _handler _req =
  match Experiments.readFromCanvases "dark-editor/system-prompt.txt" with
  | Ok prompt -> PACKAGE.Darklang.Stdlib.Http.response prompt 200
  | Error _e ->
    PACKAGE.Darklang.Stdlib.Http.response
      (String.toBytes "Couldn't load prompt from disk")
      500


[<HttpHandler("GET", "/task-creation-prompt")>]
let _handler _req =
  match Experiments.readFromCanvases "dark-editor/task-creation-prompt.txt" with
  | Ok prompt -> PACKAGE.Darklang.Stdlib.Http.response prompt 200
  | Error e ->
    PACKAGE.Darklang.Stdlib.Http.response
      (String.toBytes ("Couldn't load prompt from disk" ++ e))
      500

// below, some import/export stuff
// TODO, move this to a `/scripts/deployment/data-backup.dark`
// to be called like `.../data-backup export --test`

[<HttpHandler("GET", "/export-this-canvas")>]
let _handler _req =
  let canvasId = DarkInternal.Canvas.darkEditorCanvasID ()

  let take =
    match PACKAGE.Darklang.Stdlib.Http.Request.queryParam request "take" with
    | Nothing -> 100
    | Just take -> take |> Int.parse |> rUnwrap

  let drop =
    match PACKAGE.Darklang.Stdlib.Http.Request.queryParam request "drop" with
    | Nothing -> 0
    | Just drop -> drop |> Int.parse |> rUnwrap

  match DarkInternal.Canvas.fullProgram canvasId with
  | Ok program ->
    let prettyTypes =
      program.types
      |> List.drop drop
      |> List.take take
      |> List.map (fun t -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.userType t)
      |> String.join "\n\n"

    let prettyFns =
      program.fns
      |> List.map (fun fn ->
        PACKAGE.Darklang.PrettyPrinter.ProgramTypes.userFunction fn)
      |> String.join "\n\n"

    let response = prettyTypes ++ "\n------------------\n" ++ prettyFns

    PACKAGE.Darklang.Stdlib.Http.responseWithHeaders
      (response |> String.toBytes)
      [ ("Content-Type", "text/plain") ]
      200


// dark-exportable is `c622b6ab-f117-4c9b-826d-51ea2d175b18`
[<HttpHandler("GET", "/export-canvas/:canvasId")>]
let _handler _req =
  let canvasId = canvasId |> Uuid.parse |> rUnwrap

  match DarkInternal.Canvas.fullProgram canvasId with
  | Ok program ->
    let prettyTypes =
      program.types
      |> List.map (fun t -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.userType t)

    PACKAGE.Darklang.Stdlib.Http.responseWithHeaders
      (prettyTypes |> String.join "\n\n" |> String.toBytes)
      [ ("Content-Type", "text/plain") ]
      200



[<HttpHandler("GET", "/all-packages")>]
let _handler _req =
  let packages = DarkInternal.Packages.all ()


  let prettyPackages = PACKAGE.Darklang.PrettyPrinter.packages packages

  let result = prettyPackages

  PACKAGE.Darklang.Stdlib.Http.response (String.toBytes result) 200

// to delete once PACKAGE.Darklang.PrettyPrinter.packages packages errors are resolved
[<HttpHandler("GET", "/all-functions")>]
let _handler _req =
  let functions =
    """
    let rUnwrap (result: Result<'a, 'b>) : 'a =
      match result with
      | Ok s -> s
      | Error e ->
        log e // TODO: this won't work if non-string
        alert "Expected OK, got Error - see log"

    let log (s: String) : Unit =
      let _ = WASM.Editor.callJSFunction "console.log" [ s ]
      ()

    let logErr (s: String) : Unit =
      let _ = WASM.Editor.callJSFunction "console.error" [ s ]
      ()
    """

  PACKAGE.Darklang.Stdlib.Http.response (String.toBytes functions) 200