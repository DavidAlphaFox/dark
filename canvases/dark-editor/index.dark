(
  let body =
    """
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dark Editor - GPT-4 API</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body,
      html {
        margin: 0;
        height: 100%;
      }
      .split-container {
        display: flex;
        height: 100%;
      }
      .left-half,
      .right-half {
        height: 100%;
        flex: 1;
        padding: 20px;
      }
      .left-half {
        background-color: #f9f9f9;
      }
      .right-half {
        background-color: #ddd;
      }
      textarea {
        width: 100%;
        height: 80%;
        padding: 10px;
        font-size: 16px;
        border-radius: 5px;
        border: 1px solid #ccc;
        resize: none;
      }
      #dark-prompt{
        height: 20%;
      }
      input[type="text"],
      input[type="submit"],
      #copy-btn {
        width: 100%;
        padding: 10px;
        font-size: 16px;
        border-radius: 5px;
        border: 1px solid #ccc;
      }
      input[type="submit"],
      #copy-btn {
        background-color: #4caf50;
        color: white;
        cursor: pointer;
      }
      input[type="submit"]:hover {
        background-color: #45a049;
      }
      textarea:disabled {
        background-color: #f2f2f2;
        color: #aaa;
      }
      form{
        height:80%;
      }
    </style>
  </head>
  <body>
    <div class="split-container">
      <div class="left-half">
        <form id="gpt4-form">
          <input type="text" name="dark-editor" value="dark-editor" />
          <textarea id="dark-prompt" name="dark-prompt">
You are a tool that is used by Dark developers to write and manipulate their Dark programs.
Dark is a programming language used to write backends. In addition to the language, it has built-in support for DBs, REPLs, CRONs, Workers, etc. The term "toplevels" it used to refer to these distinct parts of a user's program - a user DB, a REPL, a CRON, etc.

Dark is very similar to F#, including syntax and semantics, with these exceptions:
- Dark does not support "record deconstruction" in `match` expressions
- field and function names use camelCase in Dark, not snake_case
- Dark does not support mutation.
- all names must be fully-qualified (eg `String.trimLeft`) and imports (or `open`) are not supported
- string interpolation replaces `sprintf`, for example `$"My name is {name}"`

# Dark features:
## Types:
Dark is statically typed, and supports type definitions. Types are good and should be used often.
- records are supported, such as `type MyType = { x : int }`
- enums are supported, such as `type MyType = | OptionOne of Int | SecondOption | Another of Int * String * Bool`

## HTTP handlers
HTTP handlers are expressions, with each handler stored in a .dark file, and HTTP
metadata stored in config.yml.

A request has a `request` variable available:
`{ url: String; headers: List<String*String>; body: Bytes }`

The expression should return a response with this type:
`{ statusCode: int; headers: List<String*String>; body: byte[] }`

For example:

hello.dark
```
(
  let requestSize = request.body |> Bytes.length |> Int.toString
  let body = "hello " ++ user ++ "\n" ++ "Request size: " ++ requestSize
  {
    statusCode = 200
    headers = []
    body = String.toBytes body
  }
)
```

config.yml:
```
http-handlers:
  hello:
    method: GET
    path: /hello/:user
```

## Standard library

type HttpResponse = {
  statusCode: int
  headers: List<String*String>
  body: Bytes
}

Here are some functions available in Dark:
- DB.set (dbName: String) (item: 'a) : Uuid
- DB.get (dbName: String) (key: String) : 'a
- HttpClient.request (method: String) (url: String) (headers: List<String*String>) (body: Bytes) : HttpResponse
- String.fromBytes (bytes: Bytes): String
- String.toBytes (text: String): Bytes
- Json.toString<'a> (v: 'a): String
- Json.parse<'a> (j: String) : 'a

These are the available standard library modules:
- Int
- Character
- String
- Float
- Bool
- List
- Option
- Result
- DB
- HttpClient
- Json

## Json
To use Json, create types that match the JSON request and response, and use the types
to create and parse json. For example:

```
type TwilioRequest = {
  message : String
  from: String
  to: String
  retries: Int
}

type TwilioResponse = {
  error : Option<String>
  successCode : Int
}

let request = ...
let requestBody = Json.toString<TwilioRequest>(request)
...
let response = Json.parse<TwilioResponse>(responseBody)
```

Only use type names, not anonymous type definitions.

## Secrets

Secrets are supported. Secrets are string variables named using ALL_CAPS, such as
`TWILIO_APIKEY` or `AWS_OIDC_FEDERATION_ID`. They are already available, you do not
need to call any functions.


Your job is to assist in building an application in Dark. When you reply, only provide the code and config.yml with no explanation.
Wait for the user to provide a prompt.
          </textarea>

          <textarea name="prompt" placeholder="Insert prompt here"></textarea>
          <input type="submit" value="Submit" />
        </form>
      </div>
      <div class="right-half">
        <textarea id="output" disabled></textarea>
        <button id="copy-btn">Copy</button>
      </div>
    </div>
    <script>
      document
        .getElementById("gpt4-form")
        .addEventListener("submit", async event => {
          event.preventDefault();
          const formData = new FormData(event.target);
          const prompt = formData.get("prompt");
          const darkPrompt = formData.get("dark-prompt");

          const response = await fetch("/api/gpt4", {
            method: "POST",
            headers: { "Content-Type": "text/plain" },
            body: darkPrompt + prompt,
          });

          if (response.ok) {
            const data = await response.json();
            document.getElementById("output").value = data.choices[0].text;
          } else {
            window.response = response;
            let text = await response.text();
            document.getElementById("output").value =
              "Error calling the GPT-4 API: " + response.status + " " + response.statusText + " " + text;
          }
        });
        const copyBtn = document.getElementById("copy-btn");
        copyBtn.addEventListener("click", () => {
          const output = document.getElementById("output");
          navigator.clipboard.writeText(output.value).then(() => {
            console.log('Text copied to clipboard');
          }).catch((error) => {
            console.error('Error copying text to clipboard:', error);
          });
        });
    </script>
  </body>
</html>
  """

  Http.responseWithHeaders (String.toBytes body) (Dict.fromListOverwritingDuplicates [("Content-Type", "text/html")]) 200
)
