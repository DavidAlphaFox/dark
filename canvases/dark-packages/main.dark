type PackageItem =
  | Fn of PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.PackageFn
  | Type of PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType
  | Constant of PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant

type Category =
  | Fn
  | Type
  | Constant

type GenericName =
  { owner: String
    modules: List<String>
    name: String
    version: Int }

type Entry =
  { name: GenericName
    package: PackageItem
    category: Category }

[<DB>]
type PackagesDB = Entry

[<HttpHandler("POST", "/types")>]
let _handler _req =
  let value =
    request.body
    |> PACKAGE.Darklang.Stdlib.String.fromBytesWithReplacement
    |> Builtin.Json.parse<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType>
    |> Builtin.unwrap

  let item =
    Entry
      { name =
          GenericName
            { name =
                value.name.name
                |> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name
              modules = value.name.modules
              owner = value.name.owner
              version = value.name.version }
        package = PackageItem.Type value
        category = Category.Type }

  let key = Builtin.DB.generateKey_v0 ()
  Builtin.DB.set item key PackagesDB

  PACKAGE.Darklang.Stdlib.Http.response
    (PACKAGE.Darklang.Stdlib.String.toBytes "added")
    200

[<HttpHandler("POST", "/functions")>]
let _handler _req =
  let value =
    request.body
    |> PACKAGE.Darklang.Stdlib.String.fromBytesWithReplacement
    |> Builtin.Json.parse<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.PackageFn>
    |> Builtin.unwrap

  let item =
    Entry
      { name =
          GenericName
            { name =
                value.name.name
                |> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name
              modules = value.name.modules
              owner = value.name.owner
              version = value.name.version }
        package = PackageItem.Fn value
        category = Category.Fn }

  let key = Builtin.DB.generateKey_v0 ()
  Builtin.DB.set item key PackagesDB

  PACKAGE.Darklang.Stdlib.Http.response
    (PACKAGE.Darklang.Stdlib.String.toBytes "added")
    200

[<HttpHandler("POST", "/constants")>]
let _handler _req =
  let value =
    request.body
    |> PACKAGE.Darklang.Stdlib.String.fromBytesWithReplacement
    |> Builtin.Json.parse<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant>
    |> Builtin.unwrap

  let item =
    Entry
      { name =
          GenericName
            { name =
                value.name.name
                |> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name
              modules = value.name.modules
              owner = value.name.owner
              version = value.name.version }
        package = PackageItem.Constant value
        category = Category.Constant }

  let key = Builtin.DB.generateKey_v0 ()
  Builtin.DB.set item key PackagesDB

  PACKAGE.Darklang.Stdlib.Http.response
    (PACKAGE.Darklang.Stdlib.String.toBytes "added")
    200



[<HttpHandler("GET", "/stats")>]
let _handler _req =
  let types =
    Builtin.DB.queryCount PackageDB (fun entry -> entry.category == Category.Type)

  let fns =
    Builtin.DB.queryCount PackageDB (fun entry -> entry.category == Category.Fn)

  let constants =
    Builtin.DB.queryCount PackageDB (fun entry ->
      entry.category == Category.Constant)

  let items = Builtin.DB.count PackageDB

  let body =
    $"Package stats:\ntypes: {types}, fns: {fns}, constants: {constants}\n\ntotal items in DB: {items}"
    |> PACKAGE.Darklang.Stdlib.String.toBytes

  PACKAGE.Darklang.Stdlib.Http.response body 200


let parseName (name: String) : GenericName =
  match PACKAGE.Darklang.Stdlib.String.split name "." with
  | owner :: rest ->
    match PACKAGE.Darklang.Stdlib.List.reverse rest with
    | name :: modulesInReverse ->

      GenericName
        { owner = owner
          modules = PACKAGE.Darklang.Stdlib.List.reverse modulesInReverse
          name = name
          version = 0 }


[<HttpHandler("GET", "/type/by-name/:name")>]
let _handler _req =
  let name = parseName name

  let found =
    Builtin.DB.queryOne PackagesDB (fun v ->
      v.name == name && v.category == Category.Type)

  match found with
  | None -> PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "not found") 404
  | Some type_ ->
    let respBody =
      type_
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType>
      |> unwrap
      |> String.toBytes

    PACKAGE.Darklang.Stdlib.Http.response respBody 200

[<HttpHandler("GET", "/constant/by-name/:name")>]
let _handler _req =
  let name = parseName name

  let found =
    Builtin.DB.queryOne PackagesDB (fun v ->
      v.name == name && v.category == Category.Constant)

  match found with
  | None -> PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "not found") 404
  | Some constant ->
    let respBody =
      constant
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant>
      |> unwrap
      |> String.toBytes

    PACKAGE.Darklang.Stdlib.Http.response respBody 200


[<HttpHandler("GET", "/function/by-name/:name")>]
let _handler _req =
  let name = parseName name

  let found =
    Builtin.DB.queryOne PackagesDB (fun v ->
      v.name == name && v.category == Category.Fn)

  match found with
  | None -> PACKAGE.Darklang.Stdlib.Http.response (String.toBytes "not found") 404
  | Some fn ->
    let respBody =
      fn
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.PackageFn>
      |> unwrap
      |> String.toBytes

    PACKAGE.Darklang.Stdlib.Http.response respBody 200


[<HttpHandler("GET", "/owner/:owner")>]
let _handler _req =
  let allItems =
    (Builtin.DB.query PackagesDB (fun v -> v.name.owner == owner))
    |> PACKAGE.Darklang.Stdlib.List.map (fun i ->
      (i.owner, i.modules |> String.join ".", i.name))
    |> PACKAGE.Darklang.Stdlib.List.map (fun m ->
      let (owner, modules, name) = m
      $"{owner}.{modules}.{name}")
    |> PACKAGE.Darklang.Stdlib.List.sort
    |> PACKAGE.Darklang.Stdlib.String.join "\n"

  let respBody =
    if allItems == "" then
      ($"owner {owner} not found") |> PACKAGE.Darklang.Stdlib.String.toBytes
    else
      allItems |> PACKAGE.Darklang.Stdlib.String.toBytes

  PACKAGE.Darklang.Stdlib.Http.response respBody 200


[<HttpHandler("GET", "/modules/:name")>]
let _handler _req =
  let owner =
    name
    |> PACKAGE.Darklang.Stdlib.String.split "."
    |> PACKAGE.Darklang.Stdlib.List.head
    |> Builtin.unwrap

  let modules =
    name
    |> PACKAGE.Darklang.Stdlib.String.split "."
    |> PACKAGE.Darklang.Stdlib.List.drop 1

  let fns =
    Builtin.DB.query PackageDB (fun v ->
      v.name.owner == owner
      && v.name.modules == modules
      && v.category == Category.Fn)

  let types =
    Builtin.DB.query PackageDB (fun v ->
      v.name.owner == owner
      && v.name.modules == modules
      && v.category == Category.Type)

  let constants =
    Builtin.DB.query PackageDB (fun v ->
      v.name.owner == owner
      && v.name.modules == modules
      && v.category == Category.Constant)

  let respBody =
    (PACKAGE.Darklang.Stdlib.Packages
      { types = types
        fns = fns
        constants = constants })
    |> Json.serialize<PACKAGE.Darklang.Stdlib.Packages>
    |> unwrap
    |> String.toBytes

  PACKAGE.Darklang.Stdlib.Http.response respBody 200