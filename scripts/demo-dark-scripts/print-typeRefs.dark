(let typeReferences: List<PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference> =
  [ PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference.TInt
    PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference.TFloat
    PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference.TBool
    PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference.TUnit
    PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference.TString

    // PT.TList PT.TInt
    // PT.TTuple(PT.TBool, PT.TBool, [ PT.TBool ])
    // PT.TDict PT.TBool
    // PT.TDB PT.TBool
    // PT.TCustomType(
    //   PT.FQName.UserProgram
    //     { modules = [ "Mod" ]; name = PT.TypeName.TypeName "User"; version = 0 },

    //   [ PT.TBool ]
    // )
    // PT.TCustomType(
    //   PT.FQName.BuiltIn
    //     { modules = [ "Mod" ]; name = PT.TypeName.TypeName "User"; version = 0 },
    //   [ PT.TBool ]
    // )
    // PT.TCustomType(
    //   PT.FQName.Package
    //     { owner = "dark"
    //       modules = NonEmptyList.ofList [ "Mod1"; "Mod2" ]
    //       name = PT.TypeName.TypeName "Pack"
    //       version = 0 },
    //   [ PT.TBool ]
    // )
    // PT.TBytes
    // PT.TVariable "test"
    // PT.TFn([ PT.TBool ], PT.TBool)
    ]

 let prettyPrinted =
   typeReferences
   |> List.map (fun t -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference t)
   |> String.join "\n"

 print prettyPrinted

 0)