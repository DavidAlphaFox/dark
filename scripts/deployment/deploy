#!/usr/bin/env python3

# Script to manage deployment of kubernetes services

# See description in services/README.md

import os
from posixpath import join
import sys

if os.getenv("IN_DEV_CONTAINER") != "true":
  print ("Must be run in dev container")
  sys.exit(1)

import glob
import re
import yaml
import argparse
import os.path
import subprocess
import jsonschema

##################################
# Utility functions
##################################

def bad(str):
  print(str)
  sys.exit(1)

should_debug = False
should_dry_run = False

def debug(str):
  if should_debug:
    print("DEBUG: ", str)

def run(dir, name, args, shell=False):
  try:
    if should_dry_run:
      print(f"Running {name} command: (dry-run)\n  {args}")
    else:
      print(f"Running {name} command:\n  {args}")
      subprocess.run(args, shell=shell, check=True)
      print()
  except subprocess.CalledProcessError as e:
    bad(f"Error running {name} command in {dir}:\n  {e}\n  (command:{args})")



##################################
# Assertions
##################################

def assert_file_exists(dir, f):
  if not os.path.exists(os.path.join(dir, f)):
    bad(f"File {dir}/{f} does not exist")


def assert_dir_exists(service, d):
  if not os.path.exists(d):
    bad(f"Directory {d} does not exist")

def assert_string_in_file (filename, file_str, substr):
  if substr not in file_str:
    bad(f"String missing from {filename}: {substr}")

##################################
# Load services / config
##################################
def dirs_from_args(args):
  dirs = args.services
  if dirs == []:
    dirs = [ path for path in glob.glob(r'services/**') if "README.md" not in path ]
  elif len(dirs) == 1 and dirs[0].endswith("deploy.yaml"):
    dirs = [ os.path.dirname(dirs[0]) ]
  sorted_dirs = sorted(dirs)
  return sorted_dirs

def config_from_dir(dir):
  try:
    file = open(dir + "/deploy.yaml")
  except:
    bad(f"Missing config file in {dir}/deploy.yaml")
  try:
    return yaml.load(file, Loader=yaml.Loader)
  except Exception as e:
    bad(f"Bad yaml in {dir}/deploy.yaml\n  {e}")


##################################
# Config commands
##################################

def config_diff(args):
  validate(args)
  files = []
  for dir in dirs_from_args(args):
    config = config_from_dir(dir)
    for f in config['k8s']["manually-deployed-config"]["configs"]:
      files.append(os.path.join(dir, f))
    for c in config['k8s']["manually-deployed-config"].get("custom-diff", []):
      run(dir, "custom diff", c, shell=True)

  if files == []:
    debug("No files to diff, skipping")
  else:
    file_args = ["kubectl", "diff"]
    for f in files:
      file_args.append("-f")
      file_args.append(f)
    run(dir, "kubectl diff", file_args)

def config_apply_manually(args):
  args.services = [args.service]
  validate(args)
  files = []
  for dir in dirs_from_args(args):
    config = config_from_dir(dir)
    for f in config['k8s']["manually-deployed-config"]["configs"]:
      files.append(os.path.join(dir, f))
    for c in config['k8s']["manually-deployed-config"].get("custom-apply", []):
      run(dir, "custom apply", c, shell=True)

  if files == []:
    print("No files to apply, skipping")
  else:
    file_args = ["kubectl", "apply"]
    for f in files:
      file_args.append("-f")
      file_args.append(f)
    run(dir, "kubectl apply", file_args)


##################################
# Validate config files
##################################

config_schema = """
type: object
properties:
  k8s:
    type: object
    properties:
      manually-deployed-config:
        type: object
        properties:
          configs:
            type: array
            items:
              type: string
          custom-diff:
            type: array
            items:
              type: string
          custom-apply:
            type: array
            items:
              type: string
        required: [configs]
        additionalProperties: false
      deployment:
        type: object
        properties:
          config-template:
            type: string
          containers:
            type: array
            items:
              type: string
          template-vars:
            type: array
            items:
              type: string
        required: [containers, config-template, template-vars]
        additionalProperties: false
    required: [manually-deployed-config]
    additionalProperties: false
"""

def validate(args):
  for dir in dirs_from_args(args):
    config = config_from_dir(dir)
    debug(f"Validating config for {dir}")
    try:
      jsonschema.validate(config, yaml.load(config_schema, Loader=yaml.Loader))
    except jsonschema.exceptions.ValidationError as e:
      bad(f"Error in {dir}/deploy.yaml:\n  {e}")

    k8s = config['k8s']

    manually_deployed_config = k8s["manually-deployed-config"]
    configs = manually_deployed_config["configs"]
    for f in configs:
      assert_file_exists(dir, f)

    deployment = config['k8s'].get("deployment", None)
    if deployment:
      assert_file_exists(dir, deployment['config-template'])
      template_filename = os.path.join(dir, deployment['config-template'])
      template_contents = open(template_filename).read()

      for c in deployment["containers"]:
        assert_dir_exists(dir, f"containers/{c}")
        # Check the containers are used in the template
        assert_string_in_file(template_filename, template_contents, f"{{IMAGEID:{c}}}")

      # Check the vars are used in the template
      for var in deployment["template-vars"]:
        assert_string_in_file(template_filename, template_contents, f"{{VAR:{var}}}")

      # Check all template vars are defined
      for match in re.findall(r"\{([-A-Z0-9a-z:_]+)}", template_contents, re.MULTILINE):
        varmatch = re.match(r"^VAR:([A-Z0-9_]+)$", match)
        imageid_match = re.match(r"^IMAGEID:([-a-z0-9]+)$", match)
        if varmatch:
          var = varmatch.group(1)
          if var not in deployment["template-vars"]:
            bad(f"var \"{var}\" not in `k8s.deployment.template-vars` in\n{template_filename}")
        elif imageid_match:
          id = imageid_match.group(1)
          if id not in deployment["containers"]:
            bad(f"imageid \"{id}\" not in `k8s.deployment.containers` in\n{template_filename}")
        else:
          bad(f"Unexpected placeholder \"{{{match}}}\" in\n{template_filename}")


##################################
# Argument parser
##################################

def create_arg_parser():
  # The base parser has the commands shared by ALL subcommands
  base_parser = argparse.ArgumentParser(add_help=False)
  base_parser.add_argument('--debug', action='store_true', help="Print debug info about what's running")
  base_parser.add_argument('--dry-run', action='store_true', help="paths to the service definitions. Leave empty to run on all services")
  base_parser.set_defaults(debug=False)
  base_parser.set_defaults(dry_run=False)

  # We want to be explicit about listing services for side-effecting commands
  services_parser = argparse.ArgumentParser(add_help=False)
  services_parser.add_argument('services', action="store", nargs="*", help="paths to the service definitions. Leave empty to run on all services")

  main_parser = argparse.ArgumentParser(description='Manage deployment of kubernetes services')
  main_subparsers = main_parser.add_subparsers()

  validate_parser = main_subparsers.add_parser('validate', description="Validates deploy.yaml files", parents=[base_parser])
  validate_parser.set_defaults(func=validate)

  config_parser = main_subparsers.add_parser('config')
  config_subparser = config_parser.add_subparsers()

  config_diff_parser = config_subparser.add_parser('diff', description="Checks that the config files listed in the k8s.manually-deployed-config key of deploy.yaml are already properly deployed, using `kubectl diff`", parents=[base_parser, services_parser])
  config_diff_parser.set_defaults(func=config_diff)

  config_apply_parser = config_subparser.add_parser('apply-manually', description="Checks that the config files listed in the k8s.manually-deployed-config key of deploy.yaml are already properly deployed, using `kubectl diff`", parents=[base_parser])
  config_apply_parser.add_argument('service', action="store", help="path to the service definition. Required and only one service is supported")
  config_apply_parser.set_defaults(func=config_apply_manually)

  return main_parser

##################################
# Main
##################################

def main():
  global should_debug
  global should_dry_run
  parser = create_arg_parser()
  args = parser.parse_args()
  should_debug = args.debug
  should_dry_run = args.dry_run
  args.func(args)

main()
