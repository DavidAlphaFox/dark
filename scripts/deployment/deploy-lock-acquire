#!/usr/bin/env bash
. ./scripts/devcontainer/_assert-in-container "$0" "$@"

set -euo pipefail

DEPLOY_LOCK_BUCKET="gs://darklang-deploy-lock"

LOCKFILE_ID=$1

echo "Lock file: ${LOCKFILE_ID}"
LOCKFILE_NAME="deploy-lock-${LOCKFILE_ID}"

cleanup_deploy_lock() {
  trap '' EXIT # some shells will call EXIT after the INT handler
  if [[ "${LOCKFILE_ID}" != "" ]];
  then
    echo "Removing deploy lock"
    ./scripts/deployment/deploy-lock-clear
  fi
  exit 1
}

deploy_lock_claimed=""
while [[ "${deploy_lock_claimed}" != "true" ]]; do
  # If there's a manual lock, loop
  if (./scripts/deployment/deploy-lock-list-manual); then
    true # loop
  else
    max_deploy_lock=$( (./scripts/deployment/deploy-lock-list-manual || true) \
      | sed 's/.*-//' | sort -nr | head -n 1)

    # if there are no deploy locks, create ours and continue
    if [[ "${max_deploy_lock}" == "" ]]; then
      echo date > "${LOCKFILE_NAME}"
      gsutil cp "${LOCKFILE_NAME}" "${DEPLOY_LOCK_BUCKET}"
      # Make sure we remove the lockfile if this script exits early for some reason
      trap cleanup_deploy_lock INT QUIT TERM ERR

      deploy_lock_claimed="true"
    elif [[ "${LOCKFILE_ID}" == "manual-deploy" ]]; then
      true
    # if the biggest # is greater than ours, then exit instead of deploying
    elif [[ "${max_deploy_lock}" -gt "${LOCKFILE_ID}"  ]]; then
      echo "Currently-running deploy ${max_deploy_lock} > ${LOCKFILE_ID}, so not deploying."
      exit 1
    # if the biggest # is smaller than ours, loop (we will deploy after)
    else
      true # loop
    fi
  fi

  echo "At $(date), sleeping 5s to wait for deploy lock..."
  sleep 5
done


