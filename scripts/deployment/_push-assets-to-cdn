#!/usr/bin/env python3.8

import glob
import os
import sys
import json
import subprocess

PREFIX_TO_REMOVE="backend/static/"
BUCKET="gs://darklang-static-assets"

# Fetch all files
allStaticFiles = [f for f in glob.glob('backend/static/**', recursive=True) if os.path.isfile(f)]


# Filter out files we don't care about
def shouldCopyFile(filename):
  filesToSkip = ["backend/static/.gitkeep", "backend/static/etags.json"]
  if filename in filesToSkip:
    return False

  if filename.endswith(".gz") or filename.endswith(".br"):
    return False

  return True

staticFilesToCopy = [f for f in allStaticFiles if shouldCopyFile(f)]


# Determine content-type / mimetype
# See also ApiServer.configureStaticContent
def mimeTypeFor(filename):
  # Common web stuff
  if filename.endswith(".css"): return "text/css"
  elif filename.endswith(".js"): return "application/javascript"
  elif filename.endswith(".json"): return "application/json"
  elif filename.endswith(".txt"): return "text/plain"
  elif filename.endswith(".png"): return "image/png"
  elif filename.endswith(".svg"): return "image/svg+xml"
  elif filename.endswith(".html"): return "text/html"
  # Fonts
  elif filename.endswith(".ttf"): return "font/ttf"
  elif filename.endswith(".woff"): return "font/woff"
  elif filename.endswith(".woff2"): return "font/woff2"
  elif filename.endswith(".eot"): return "application/vnd.ms-fontobject"
  # Blazor
  elif filename.endswith(".wasm"): return "application/wasm"
  elif filename.endswith(".pdb"): return "text/plain"
  elif filename.endswith(".dll"): return "application/octet-stream"
  elif filename.endswith(".dat"): return "application/octet-stream"
  elif filename.endswith(".blat"): return "application/octet-stream"
  else:
    # Don't allow anything else
    print(f'Unknown extension for {filename}')
    sys.exit(-1)


# key = mimetype, value = list of static file (by local name))
filesGroupedByMimetype = {}
for f in staticFilesToCopy:
  mimetype = mimeTypeFor(f)

  if mimetype in filesGroupedByMimetype:
    filesGroupedByMimetype[mimetype].append(f)
  else:
    filesGroupedByMimetype[mimetype] = [f]


# Copy the files to CDN - some of the files are hashed
def shouldHash(filename):
  return not filename.startswith("backend/static/vendor/")

with open('backend/static/etags.json', 'r') as f:
  etags = json.load(f)

def remoteFileName(filename):
  filename = filename.replace(PREFIX_TO_REMOVE, '')

  if shouldHash(filename):
    filehash = etags[filename]
    (base, _dot, extension) = filename.rpartition('.')
    hashedFile = f'{base}-{filehash}.{extension}'
    return hashedFile
  else:
    return filename

def remoteFilePath(fileName):
  return f'{BUCKET}/{remoteFileName(fileName)}'


for mimetype in filesGroupedByMimetype:
  localFilesForMimeType = filesGroupedByMimetype[mimetype]
  for file in localFilesForMimeType:
    remotePath = remoteFileName(file)

    gsutilCommand = '''gsutil \
      -h "Content-Type:{mimetype}" \
      -h "Cache-Control:public" \
      cp \
        -Z \
        -n \
        "{localpath}" \
        "{remotepath}" &
      '''.format(mimetype=mimetype, localpath=file, remotepath=remoteFilePath(file))

    subprocess.run(gsutilCommand, shell=True)

# Wrap up
print("Done!")