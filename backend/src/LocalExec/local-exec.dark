let listDirectoryRecursive (dir: String) : List<String> =
  let contents = Directory.list dir
  let (files, dirs) = contents |> List.partition (fun x -> File.isNormal x)

  let nested =
    dirs
    |> List.map (fun d -> listDirectoryRecursive d)
    |> LocalExec.BuiltIns.List.flatten

  dirs |> List.append files |> List.append nested


// Packages
let listPackageFilesOnDisk (dir: String) : List<String> =
  dir
  |> listDirectoryRecursive
  |> List.filter (fun x -> x |> LocalExec.BuiltIns.String.endsWith ".dark")




let saveItemToCanvas
  (json: String)
  (name: String)
  : PACKAGE.Darklang.Stdlib.Result.Result<Unit, String> =
  let response =
    HttpClient.request
      "POST"
      $"http://dark-packages.dlio.localhost:11003/{name}s"
      []
      (String.toBytes json)

  let errMsg = $"Error saving {name} to canvas"

  match response with
  | Ok response ->
    match response.statusCode with
    | 200 -> PACKAGE.Darklang.Stdlib.Result.Result.Ok()
    | _ ->
      print $"Type: {name}; Json: {json}"
      print $"Status: {Int.toString response.statusCode}"
      print $"Body: {response.body |> String.fromBytes}"
      print errMsg
      PACKAGE.Darklang.Stdlib.Result.Result.Error errMsg
  | Error err ->
    print $"Type: {name}; Json: {json}"
    print err
    print errMsg
    PACKAGE.Darklang.Stdlib.Result.Result.Error errMsg



let loadPackageFileIntoDarkCanvas
  (filename: String)
  : PACKAGE.Darklang.Stdlib.Result.Result<Unit, String> =
  let package =
    filename
    |> File.read
    |> unwrap
    |> String.fromBytes
    |> LocalExec.Packages.parse filename
    |> unwrap

  let fnResults =
    package.fns
    |> List.map (fun fn ->
      fn
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.PackageFn>
      |> unwrap
      |> saveItemToCanvas "function")

  let typeResults =
    package.types
    |> List.map (fun t ->
      t
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType>
      |> unwrap
      |> saveItemToCanvas "type")

  let constantResults =
    package.constants
    |> List.map (fun c ->
      c
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant>
      |> unwrap
      |> saveItemToCanvas "constant")

  // Flatten all the result lists into one list
  let allResults =
    [ fnResults; typeResults; constantResults ]
    |> PACKAGE.Darklang.Stdlib.List.flatten

  let firstError =
    List.findFirst allResults (fun r ->
      match r with
      | Error _ -> true
      | Ok _ -> false)

  // Find the first error in the flattened list
  match firstError with
  | Some(Error err) -> PACKAGE.Darklang.Stdlib.Result.Result.Error err
  | _ -> PACKAGE.Darklang.Stdlib.Result.Result.Ok()


let printPackageFunction (p: LocalExec.Packages.Function) : Unit =
  let modules = p.modules |> String.join "."

  print $"Package Function {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printPackageType (p: LocalExec.Packages.Type) : Unit =
  let modules = p.modules |> String.join "."
  print $"Package Type {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printPackageConstant (p: LocalExec.Packages.Constant) : Unit =
  let modules = p.modules |> String.join "."
  print $"Package Constant {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printAllPackagesInDb () : Unit =
  let functions = LocalExec.Packages.listFunctions ()
  functions |> LocalExec.BuiltIns.List.iter (fun p -> printPackageFunction p)

  let types = LocalExec.Packages.listTypes ()
  types |> LocalExec.BuiltIns.List.iter (fun p -> printPackageType p)

  let constants = LocalExec.Packages.listConstants ()
  constants |> LocalExec.BuiltIns.List.iter (fun p -> printPackageConstant p)


// parse args and execute
type CliOptions =
  | Help
  | LoadPackagesIntoDarkCanvas
  | ListPackages
  | BadOption of String

let usage () : String =
  "Usage: LocalExec [options]

    Options:
      -h, --help          Show this help message and exit
      load-packages-dark  Load packages from disk into dark packages canvas
      list-packages       List packages
  "


let parseArgs (args: List<String>) : CliOptions =
  match args with
  | [] -> CliOptions.Help
  | [ "-h" ] -> CliOptions.Help
  | [ "--help" ] -> CliOptions.Help

  | [ "list-packages" ] -> CliOptions.ListPackages
  | [ "load-packages" ] ->
    CliOptions.BadOption
      "`load-packages` now executes in F# (not sure how you got here)"
  | [ "load-packages-dark" ] -> CliOptions.LoadPackagesIntoDarkCanvas

  | _ -> CliOptions.BadOption "Invalid arguments"



let main (args: List<String>) : Int =
  match parseArgs args with
  | Help ->
    print (usage ())
    0

  | ListPackages ->
    printAllPackagesInDb ()
    0

  | LoadPackagesIntoDarkCanvas ->
    let files = listPackageFilesOnDisk "/home/dark/app/packages"

    // TODO: clear packages from dark canvas first?

    // Wait for canvas to be ready
    let available =
      List.fold
        (PACKAGE.Darklang.Stdlib.List.range 0 10)
        (PACKAGE.Darklang.Stdlib.Result.Result.Error "Not started")
        (fun found num ->
          match found with
          | Ok() -> PACKAGE.Darklang.Stdlib.Result.Result.Ok()
          | Error _ ->
            (HttpClient.request
              "GET"
              ("http://dark-packages.dlio.localhost:11003/health")
              []
              Bytes.empty)
            |> PACKAGE.Darklang.Stdlib.Result.map (fun _ -> ())
            |> PACKAGE.Darklang.Stdlib.Result.mapError (fun err ->
              print $"Error: {err}"
              Time.sleep 1000.0
              err))


    match available with
    | Error msg ->
      print $"Error waiting for dark packages canvas: {msg}"
      1
    | Ok() ->
      print "Dark packages canvas is ready"

      let result =
        List.fold files (PACKAGE.Darklang.Stdlib.Result.Result.Ok()) (fun (acc, f) ->
          print $"Loading {f}"

          match acc with
          | Error _err -> acc
          | Ok() ->
            match loadPackageFileIntoDarkCanvas f with
            | Error err ->
              PACKAGE.Darklang.Stdlib.Result.Result.Error(
                $"Failed to load packages from {f}:\n" ++ err
              )
            | Ok() -> PACKAGE.Darklang.Stdlib.Result.Result.Ok())

      match result with
      | Error err ->
        print err
        1
      | Ok() ->
        print "Done loading packages from disk"
        printAllPackagesInDb ()
        0

  | BadOption msg ->
    print ("Error: " ++ msg)
    1

main args