let listDirectoryRecursive (dir: String) : List<String> =
  let contents = Directory.list dir
  let (files, dirs) = contents |> List.partition (fun x -> File.isNormal x)

  let nested =
    dirs
    |> List.map (fun d -> listDirectoryRecursive d)
    |> LocalExec.BuiltIns.List.flatten

  dirs |> List.append files |> List.append nested


// Packages
let listPackageFilesOnDisk (dir: String) : List<String> =
  dir
  |> listDirectoryRecursive
  |> List.filter (fun x -> x |> LocalExec.BuiltIns.String.endsWith ".dark")


let saveFunctionToCanvas
  (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.T)
  : Unit =
  let reqBody =
    p
    |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.T>
    |> unwrap
    |> String.toBytes

  let response =
    HttpClient.request
      "POST"
      ("http://dark-packages.dlio.localhost:11003/functions")
      []
      reqBody

  let response = unwrap response

  // TODO: ensure 200 OK

  ()

let saveTypeToCanvas
  (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType.T)
  : Unit =
  let reqBody =
    p
    |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType.T>
    |> unwrap
    |> String.toBytes

  let response =
    HttpClient.request
      "POST"
      ("http://dark-packages.dlio.localhost:11003/types")
      []
      reqBody

  let response = unwrap response

  // TODO: ensure 200 OK

  ()

let saveConstantToCanvas
  (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant.T)
  : Unit =
  let reqBody =
    p
    |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant.T>
    |> unwrap
    |> String.toBytes

  let response =
    HttpClient.request
      "POST"
      ("http://dark-packages.dlio.localhost:11003/constants")
      []
      reqBody

  let response = unwrap response

  // TODO: ensure 200 OK

  ()

// TODO: this should return a Result<Unit, String>
// and the consumer should handle the error appropriately
let loadPackageFileIntoDarkCanvas (filename: String) : Unit =
  let package =
    filename
    |> File.read
    |> unwrap
    |> String.fromBytes
    |> LocalExec.Packages.parse filename
    |> unwrap

  package.fns |> LocalExec.BuiltIns.List.iter (fun fn -> saveFunctionToCanvas fn)

  package.types |> LocalExec.BuiltIns.List.iter (fun t -> saveTypeToCanvas t)

  package.constants
  |> LocalExec.BuiltIns.List.iter (fun t -> saveConstantToCanvas t)


let printPackageFunction (p: LocalExec.Packages.Function) : Unit =
  let modules = p.modules |> String.join "."

  print $"Package Function {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printPackageType (p: LocalExec.Packages.Type) : Unit =
  let modules = p.modules |> String.join "."
  print $"Package Type {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printPackageConstant (p: LocalExec.Packages.Constant) : Unit =
  let modules = p.modules |> String.join "."
  print $"Package Constant {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printAllPackages () : Unit =
  let functions = LocalExec.Packages.listFunctions ()
  functions |> LocalExec.BuiltIns.List.iter (fun p -> printPackageFunction p)

  let types = LocalExec.Packages.listTypes ()
  types |> LocalExec.BuiltIns.List.iter (fun p -> printPackageType p)

  let constants = LocalExec.Packages.listConstants ()
  constants |> LocalExec.BuiltIns.List.iter (fun p -> printPackageConstant p)


// parse args and execute
type CliOptions =
  | Help
  | LoadPackagesIntoDarkCanvas
  | ListPackages
  | BadOption of String

let usage () : String =
  "Usage: LocalExec [options]

    Options:
      -h, --help          Show this help message and exit
      load-packages-dark  Load packages from disk into dark packages canvas
      list-packages       List packages
  "


let parseArgs (args: List<String>) : CliOptions =
  match args with
  | [] -> CliOptions.Help
  | [ "-h" ] -> CliOptions.Help
  | [ "--help" ] -> CliOptions.Help

  | [ "list-packages" ] -> CliOptions.ListPackages
  | [ "load-packages" ] ->
    CliOptions.BadOption
      "`load-packages` now executes in F# (not sure how you got here)"
  | [ "load-packages-dark" ] -> CliOptions.LoadPackagesIntoDarkCanvas

  | _ -> CliOptions.BadOption "Invalid arguments"



let main (args: List<String>) : Int =
  match parseArgs args with
  | Help ->
    print (usage ())
    0

  | ListPackages ->
    printAllPackages ()
    0

  | LoadPackagesIntoDarkCanvas ->
    let files = listPackageFilesOnDisk "/home/dark/app/packages"

    // TODO: clear packages from dark canvas first?

    LocalExec.BuiltIns.List.iter files (fun f ->
      print $"Loading {f}"
      loadPackageFileIntoDarkCanvas f)

    print "Done loading packages from dark packages canvas"
    printAllPackages ()
    0

  | BadOption msg ->
    print ("Error: " ++ msg)
    1

main args