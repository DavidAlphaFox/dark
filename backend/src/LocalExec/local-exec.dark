let listDirectoryRecursive (dir: String) : List<String> =
  let contents = Directory.list dir
  let (files, dirs) = contents |> List.partition (fun x -> File.isNormal x)

  let nested =
    dirs
    |> List.map (fun d -> listDirectoryRecursive d)
    |> LocalExec.BuiltIns.List.flatten

  dirs |> List.append files |> List.append nested


// Packages
let listPackageFilesOnDisk (dir: String) : List<String> =
  dir
  |> listDirectoryRecursive
  |> List.filter (fun x -> x |> LocalExec.BuiltIns.String.endsWith ".dark")




let saveItemToCanvas
  (json: String)
  (name: String)
  : PACKAGE.Darklang.Stdlib.Result.Result<Unit, String> =
  let response =
    HttpClient.request
      "POST"
      $"http://dark-packages.dlio.localhost:11003/{name}s"
      []
      (String.toBytes json)

  let errMsg = $"Error saving {name} to canvas"

  match response with
  | Ok response ->
    match response.statusCode with
    | 200 -> PACKAGE.Darklang.Stdlib.Result.Result.Ok()
    | _ ->
      print $"Status: {Int.toString response.statusCode}"
      print $"Body: {response.body |> String.fromBytes}"
      print errMsg
      PACKAGE.Darklang.Stdlib.Result.Result.Error errMsg
  | Error _err ->
    print errMsg
    PACKAGE.Darklang.Stdlib.Result.Result.Error errMsg



// TODO: this should return a Result<Unit, String>
// and the consumer should handle the error appropriately
let loadPackageFileIntoDarkCanvas
  (filename: String)
  : PACKAGE.Darklang.Stdlib.Result.Result<Unit, String> =
  let package =
    filename
    |> File.read
    |> unwrap
    |> String.fromBytes
    |> LocalExec.Packages.parse filename
    |> unwrap

  let _fnResults =
    package.fns
    |> List.map (fun fn ->
      fn
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.PackageFn>
      |> unwrap
      |> saveItemToCanvas "function")

  let _typeResults =
    package.types
    |> List.map (fun t ->
      t
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType>
      |> unwrap
      |> saveItemToCanvas "type")

  let _constantResults =
    package.constants
    |> List.map (fun c ->
      c
      |> Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant>
      |> unwrap
      |> saveItemToCanvas "constant")

  // todo: flatten results, return first error if any are errors
  PACKAGE.Darklang.Stdlib.Result.Result.Ok()
//   (PACKAGE.Darklang.Stdlib.List.flatten_v0 fnResults typeResults constantResults)
// |>


let printPackageFunction (p: LocalExec.Packages.Function) : Unit =
  let modules = p.modules |> String.join "."

  print $"Package Function {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printPackageType (p: LocalExec.Packages.Type) : Unit =
  let modules = p.modules |> String.join "."
  print $"Package Type {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printPackageConstant (p: LocalExec.Packages.Constant) : Unit =
  let modules = p.modules |> String.join "."
  print $"Package Constant {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printAllPackagesInDb () : Unit =
  let functions = LocalExec.Packages.listFunctions ()
  functions |> LocalExec.BuiltIns.List.iter (fun p -> printPackageFunction p)

  let types = LocalExec.Packages.listTypes ()
  types |> LocalExec.BuiltIns.List.iter (fun p -> printPackageType p)

  let constants = LocalExec.Packages.listConstants ()
  constants |> LocalExec.BuiltIns.List.iter (fun p -> printPackageConstant p)


// parse args and execute
type CliOptions =
  | Help
  | LoadPackagesIntoDarkCanvas
  | ListPackages
  | BadOption of String

let usage () : String =
  "Usage: LocalExec [options]

    Options:
      -h, --help          Show this help message and exit
      load-packages-dark  Load packages from disk into dark packages canvas
      list-packages       List packages
  "


let parseArgs (args: List<String>) : CliOptions =
  match args with
  | [] -> CliOptions.Help
  | [ "-h" ] -> CliOptions.Help
  | [ "--help" ] -> CliOptions.Help

  | [ "list-packages" ] -> CliOptions.ListPackages
  | [ "load-packages" ] ->
    CliOptions.BadOption
      "`load-packages` now executes in F# (not sure how you got here)"
  | [ "load-packages-dark" ] -> CliOptions.LoadPackagesIntoDarkCanvas

  | _ -> CliOptions.BadOption "Invalid arguments"



let main (args: List<String>) : Int =
  match parseArgs args with
  | Help ->
    print (usage ())
    0

  | ListPackages ->
    printAllPackagesInDb ()
    0

  | LoadPackagesIntoDarkCanvas ->
    let files = listPackageFilesOnDisk "/home/dark/app/packages"

    // TODO: clear packages from dark canvas first?

    let _fileResults =
      List.map files (fun f ->
        print $"Loading {f}"
        loadPackageFileIntoDarkCanvas f)

    // TODO: look at fileResults; fail first error if any

    print "Done loading packages from dark packages canvas"
    printAllPackagesInDb ()
    0

  | BadOption msg ->
    print ("Error: " ++ msg)
    1

main args