{
  // FSTODO: These use a different sort order in OCaml
  "knownDifferingFunctions": [
    "List::sort",
    "List::sortBy",
    // Known formatting differences
    "Object::toJSON",
    "Object::toJSON_v1",
    "Dict::toJSON",
    "Dict::toJSON_v1",
    // Don't know what the bug is
    "String::base64Decode",
    // OCaml seems to trim wrong here
    "String::trim",
    "String::trimEnd",
    "String::trimStart",
    // .NET doesn't handle "full" case mapping
    "String::toUppercase_v1",
    "String::toLowercase_v1",
    // Bug in unicode probably
    "AWS::urlencode",
    // The lambda gives the same value for all elements,
    // and we don't guarantee which one wins
    "List::uniqueBy",
    // Returns a DError on invalid UTF-8 strings, while F# returns a Result.Error
    "JSON::parse_v1"
  ],
  "knownErrors": [
    [
      // comments are allowed
      "function name or regex",
      "actual (F#) error message (regex)",
      "expected (OCaml) error message (regex)"
    ],
    // -----------------------------
    // Dict::fromList.*
    // -----------------------------
    [
      // The old message was better, but this will go away with tuples so who cares
      "Dict::fromList.*",
      "All list items must be `\\[key, value\\]`",
      "Expected every value within the `entries` argument passed to `Dict::fromList.*` to be a `\\[key, value\\]` list. However, that is not the case for the value at index \\d+: `.*`. It is of type `.*` instead of `List`."
    ],
    [
      // The old message was better, but this will go away with tuples so who cares.
      // There's two versions here, one is missing the word "is"
      "Dict::fromList.*",
      "Expected the argument `key` to be a string, but it was `.*`",
      "Expected every value within the `entries` argument passed to `Dict::fromList.*` to be a `\\[key, value\\]` list. However, that is not the case for the value at index \\d+: `.*`. Keys must be `String`s but the type of `.*`."
    ],
    [
      // The old message was better, but this will go away with tuples so who cares
      "Dict::fromList.*",
      "All list items must be `\\[key, value\\]`",
      "Expected every value within the `entries` argument passed to `Dict::fromList.*` to be a `\\[key, value\\]` list. However, that is not the case for the value at index \\d+: `.*`. It has length \\d+ but must have length 2."
    ],
    // -----------------------------
    // Http::setCookie_v2
    // -----------------------------
    [
      "Http::setCookie_v2",
      "Keys must be `Expires`, `Max-Age`, `Domain`, `Path`, `Secure`, `HttpOnly`, and/or `SameSite`, but one of the keys was (?<result>.*)",
      "Expected the params dict passed to `Http::setCookie_v2` to only contain the keys `Expires`, `Max-Age`, `Domain`, `Path`, `Secure`, `HttpOnly`, and/or `SameSite`, but one of the keys was `(?<result>.*)`."
    ],
    // -----------------------------
    // List::sortByComparator
    // -----------------------------
    [
      // FSTODO: the different impls run comparisons in a different order, so if the arguments are Errors, a different one might be compared first
      "List::sortByComparator",
      "Expected `f` to return -1, 0, 1, but it returned `<Error: .*>`",
      "`f` must return one of -1, 0, 1, but returned .*: <Error: .*>"
    ],
    [
      "List::sortByComparator",
      "Expected `f` to return -1, 0, 1, but it returned `(?<result>.*)`",
      "`f` must return one of -1, 0, 1, but returned .*: (?<result>.*)"
    ],
    // -----------------------------
    // List::unzip
    // -----------------------------
    [
      // tuples coming soon, bad error doesn't matter
      "List::unzip",
      "Expected the argument `pairs` to be a list with exactly two values, but it was `(?<pairs>.*)`. It has length (?<len>\\d+) but should have length 2",
      "Expected every value within the `pairs` argument passed to `List::unzip` to be a list with exactly two values. However, that is not the case for the value at index \\d+: (?<pairs>.*). It has length (?<len>\\d+) but must have length 2."
    ],
    // -----------------------------
    // Int::mod
    // -----------------------------
    [
      "(Int::mod|%)",
      "Expected the argument `(?<arg>.*)` to be positive, but it was `(?<result>.*)`",
      "Expected the argument `(?<arg>.*)` argument passed to `.*` to be positive, but it was `(?<result>.*)`."
    ],

    // -----------------------------
    // JSON
    // -----------------------------
    [
      // Line is off by one - ocaml starts counting at 1
      "(JSON::parse|JSON::read).*",
      "Unexpected character encountered while parsing (?:number|value): .*. Path '', line \\d+, position (?<pos>\\d+).",
      "Json Err: Line \\d+, bytes (?<pos>\\d+)-\\d+:\nInvalid token '.*'"
    ],
    [
      "(JSON::parse|JSON::read).*",
      "JSON string was empty",
      "Json Err: Blank input data"
    ],
    [
      // JSON::parse in ocaml actually has the _v0 in the name
      "JSON::parse",
      "(?<name>.*) was called with a .* \\(.*\\), but `(?<arg>.*)` expected a .*.",
      "(?<name>.*)_v0 was called with the wrong type to parameter: (?<arg>.*)"
    ],
    // -----------------------------
    // Incorrect argument
    // -----------------------------
    [
      "Float::sum",
      "Expected the argument `.*` to be a list of floats, but it was `.*`",
      "Sum expects you to pass a list of floats"
    ],
    [
      "String::pad.*",
      "Expected the argument `padWith` to be 1 character long, but it was `\"(?<arg>.*)\"`",
      "Expected the argument `padWith` passed to `String::padEnd` to be one character long. However, `\"(?<arg>.*)\"` is \\d+ characters long."
    ],
    [
      ".*",
      "(?<name>.*) was called with a .* \\(.*\\), but `(?<arg>.*)` expected a .*.",
      "(?<name>.*) was called with the wrong type to parameter: (?<arg>.*)"
    ],
    [
      "String::fromList",
      "Expected `l` to be a list of Characters, but the list contained `.*`",
      "expected a char"
    ],
    [
      ".*",
      "Expected the argument `value` to be a string, but it was `.*`",
      "expecting str"
    ],
    [
      "(Int::multiply|Int::subtract|Int::divide|Int::add|Int::lessThan|Int::greaterThan|Int::lessThanOrEquals|Int::greaterThanOrEquals|\\+\\|\\-|\\*|\\/|\\<|\\>|<=|>=)",
      "(?<fn>.*) was called with a Float \\((?<value>.*)\\), but `.*` expected a Int. Try using Float::.*, or use Float::truncate to truncate Floats to Ints.",
      "The .* param \\((?<value>.*)\\) is a Float, but (?<fn>.*) only works on Ints. Use Float::.* to .* Floats or use Float::truncate to truncate Floats to Ints."
    ],
    [
      "(Int:add|\\+)",
      "(?<fn>.*) was called with a Float ((?<value>.*)), but `.*` expected a Int.",
      "The .* param ((?<value>.*)) is a Float, but (?<fn>.*) only works on Ints.  Use \\+\\+ or String::append to join Strings or parse Strings to Ints with String::toInt."
    ],

    // -----------------------------
    // Incorrect return type from a lambda
    // -----------------------------
    [
      ".*",
      "Expected `f` to return .*, but it returned .*",
      "Expected .* to return .*"
    ],
    [
      ".*",
      "Expected `f` to return .*, but it returned .*",
      "Expecting .* to return .*"
    ],
    [
      // FSTODO: could be worded much better - not clear that this is the lambda function
      ".*",
      "Expected `.*` to return a result",
      "Expected the function to return `(?<arg>.*)`, but the result was .*"
    ],
    [
      // FSTODO: are there parameters here we could improve
      ".*",
      "Expected `(?<arg>.*)` to return a .*, but it returned `.*`",
      "Expected the argument `(?<arg>.*)` passed to `.*` to return .*. However, it returned `.*` for the input `.*`."
    ],
    // -----------------------------
    // Remove functions
    // -----------------------------
    [".*", ".* was removed from Dark", "This function no longer exists."]
  ]
}
